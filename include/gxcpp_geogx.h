#pragma once
#define C_MICROSOFT
#include <gx_extern.h>
#include <gx_lib.h>

#include "stdint.h"
#include <assert.h>
#include <memory>
#include <string>
#include <vector>
#include <exception>
#include <functional>

#ifdef _UNICODE
typedef wchar_t gx_string_char_type;
#define gx_string_len(a) ::wcslen(a)
typedef std::wstring gx_string_type;
#define STRING_CHAR_SIZE 2
#define gx_string_literal(x) L ## x
#else
typedef char gx_string_char_type;
#define gx_string_len(a) ::strlen(a)
typedef std::string gx_string_type;
#define STRING_CHAR_SIZE 1
#define gx_string_literal(x) x
#endif

#ifdef GXPYTHON
np::ndarray make_ndarray(size_t elements, bp::object dtype_obj, int32_t& gs_type, size_t& total_size);
np::ndarray validate_and_make_contiguous_ndarray(np::ndarray np_array, size_t& elements, int32_t& gs_type, size_t& total_size);
np::ndarray validate_and_make_2d_contiguous_ndarray(np::ndarray np_array, size_t& num_rows, size_t& num_columns, int32_t& gs_type, size_t& total_size);
#endif

namespace geosoft
{
    namespace gx
    {
        namespace geogx
        {

// CRC_INIT_VALUE
            constexpr auto CRC_INIT_VALUE = 4294967295;
// DATE_FORMAT
            constexpr auto DATE_FORMAT_YYYYMMDD = 1;
            constexpr auto DATE_FORMAT_DDMMYYYY = 2;
            constexpr auto DATE_FORMAT_MMDDYYYY = 3;
// GEO_DUMMY
            constexpr auto iDUMMY = -2147483647;
            constexpr auto rDUMMY = -1.0E32;
// GEO_FULL_LIMITS
            constexpr auto GS_S1MX = 127;
            constexpr auto GS_S1MN = -126;
            constexpr auto GS_S1DM = -127;
            constexpr auto GS_U1MX = 254U;
            constexpr auto GS_U1MN = 0U;
            constexpr auto GS_U1DM = 255U;
            constexpr auto GS_S2MX = 32767;
            constexpr auto GS_S2MN = -32766;
            constexpr auto GS_S2DM = -32767;
            constexpr auto GS_U2MX = 65534U;
            constexpr auto GS_U2MN = 0U;
            constexpr auto GS_U2DM = 65535U;
            constexpr auto GS_S4MX = 2147483647L;
            constexpr auto GS_S4MN = -2147483646L;
            constexpr auto GS_S4DM = -2147483647L;
            constexpr auto GS_U4MX = 0xFFFFFFFE;
            constexpr auto GS_U4MN = 0x00000000;
            constexpr auto GS_U4DM = 0xFFFFFFFF;
            constexpr auto GS_S8MX = 0x7FFFFFFFFFFFFFFF;
            constexpr auto GS_S8MN = 0x8000000000000001;
            constexpr auto GS_S8DM = 0x8000000000000000;
            constexpr auto GS_U8MX = 0xFFFFFFFFFFFFFFFE;
            constexpr auto GS_U8MN = 0x0000000000000000;
            constexpr auto GS_U8DM = 0xFFFFFFFFFFFFFFFF;
            constexpr auto GS_R4MX = 1.0E32f;
            constexpr auto GS_R4MN = -0.9E32f;
            constexpr auto GS_R4DM = -1.0E32f;
            constexpr auto GS_R8MX = 1.0E32;
            constexpr auto GS_R8MN = -0.9E+32;
            constexpr auto GS_R8DM = -1.0E+32;
            constexpr auto GS_R4EPSILON = 1.0E-32f;
            constexpr auto GS_R8EPSILON = 1.0E-32;
// GEO_LIMITS
            constexpr auto iMIN = -2147483646;
            constexpr auto iMAX = 2147483647;
            constexpr auto rMIN = -0.9E32;
            constexpr auto rMAX = 1.0E32;
// GEO_STRING_SIZE
            constexpr auto STR_DEFAULT = 128;
            constexpr auto STR_DEFAULT_SHORT = 64;
            constexpr auto STR_DEFAULT_LONG = 1024;
            constexpr auto STR_ERROR = 2048;
            constexpr auto STR_VERY_LONG = 16384;
            constexpr auto STR_VIEW = 2080;
            constexpr auto STR_GROUP = 1040;
            constexpr auto STR_VIEW_GROUP = 2080;
            constexpr auto STR_FILE = 1040;
            constexpr auto STR_MULTI_FILE = 16384;
            constexpr auto STR_DB_SYMBOL = 64;
            constexpr auto STR_GXF = 160;
            constexpr auto STR_MAX_PATH = 1040;
            constexpr auto STR_MULTI_PATH = 16384;
            constexpr auto GS_MAX_PATH = STR_FILE;
            constexpr auto GS_MULTI_PATH = STR_MULTI_FILE;
// GEO_VAR
            constexpr auto GS_INT = 0;
            constexpr auto GS_REAL = 1;
// GS_FORMATS
            constexpr auto FORMAT_DECIMAL = 0;
            constexpr auto FORMAT_SIG_DIG = 5;
            constexpr auto FORMAT_EXP = 1;
            constexpr auto FORMAT_TIME_COLON = 2;
            constexpr auto FORMAT_TIME_HMS = 8;
            constexpr auto FORMAT_TIME_HHMMSS = 9;
            constexpr auto FORMAT_DATE_YYYYMMDD = 3;
            constexpr auto FORMAT_DATE_DDMMYYYY = 6;
            constexpr auto FORMAT_DATE_MMDDYYYY = 7;
            constexpr auto FORMAT_GEOGRAPHIC = 4;
            constexpr auto FORMAT_GEOGRAPHIC_1 = 10;
            constexpr auto FORMAT_GEOGRAPHIC_2 = 11;
            constexpr auto FORMAT_GEOGRAPHIC_3 = 12;
// GS_TYPES
            constexpr auto GS_BYTE = 0;
            constexpr auto GS_USHORT = 1;
            constexpr auto GS_SHORT = 2;
            constexpr auto GS_LONG = 3;
            constexpr auto GS_FLOAT = 4;
            constexpr auto GS_DOUBLE = 5;
            constexpr auto GS_UBYTE = 6;
            constexpr auto GS_ULONG = 7;
            constexpr auto GS_LONG64 = 8;
            constexpr auto GS_ULONG64 = 9;
            constexpr auto GS_FLOAT3D = 10;
            constexpr auto GS_DOUBLE3D = 11;
            constexpr auto GS_FLOAT2D = 12;
            constexpr auto GS_DOUBLE2D = 13;
            constexpr auto GS_MAXTYPE = 13;
            constexpr auto GS_TYPE_DEFAULT = -32767;
// SYS_CRYPT_KEY
            constexpr auto SYS_CRYPT_LICENSE_KEY = gx_string_literal("{***LICENSE_KEY***}");
            constexpr auto SYS_CRYPT_COMPUTER_ID = gx_string_literal("{***COMPUTER_ID***}");
            constexpr auto SYS_CRYPT_GLOBAL_ID = gx_string_literal("{***GLOBAL_COMPUTER_ID***}");
// TIME_FORMAT
            constexpr auto TIME_FORMAT_COLON = 1;
            constexpr auto TIME_FORMAT_HMS = 2;
// GEO3DV_OPEN
            constexpr auto GEO3DV_MVIEW_READ = 0;
            constexpr auto GEO3DV_MVIEW_WRITEOLD = 2;
// ACQUIRE_SEL
            constexpr auto ACQUIRE_SEL_HOLES = 0;
            constexpr auto ACQUIRE_SEL_POINT = 1;
// AGG_LAYER_ZONE
            constexpr auto AGG_LAYER_ZONE_DEFAULT = 0;
            constexpr auto AGG_LAYER_ZONE_LINEAR = 1;
            constexpr auto AGG_LAYER_ZONE_NORMAL = 2;
            constexpr auto AGG_LAYER_ZONE_EQUALAREA = 3;
            constexpr auto AGG_LAYER_ZONE_SHADE = 4;
            constexpr auto AGG_LAYER_ZONE_LOGLINEAR = 5;
            constexpr auto AGG_LAYER_ZONE_LAST = 6;
// AGG_MODEL
            constexpr auto AGG_MODEL_HSV = 1;
            constexpr auto AGG_MODEL_RGB = 2;
            constexpr auto AGG_MODEL_CMY = 3;
// AGG_RENDER
            constexpr auto AGG_RENDER_ADD = 0;
            constexpr auto AGG_RENDER_BLEND = 1;
            constexpr auto AGG_RENDER_BLEND_ALL = 2;
            constexpr auto AGG_RENDER_FADE = 3;
// ARC_SELTBL_TYPE
            constexpr auto ARC_SELTBL_STANDALONE = 0;
            constexpr auto ARC_SELTBL_FEATURELAYER = 1;
            constexpr auto ARC_SELTBL_CANCELED = -1;
// ARCMAP_LOAD_FLAGS
            constexpr auto ARCMAP_LOAD_DELFRAME = 1;
            constexpr auto ARCMAP_LOAD_DELLAYER = 2;
            constexpr auto ARCMAP_LOAD_EXISTFRAME = 4;
            constexpr auto ARCMAP_LOAD_COPYLAYER = 8;
            constexpr auto ARCMAP_LOAD_HIDESIBLINGS = 16;
            constexpr auto ARCMAP_LOAD_PREFIXMAPFRAME = 32;
            constexpr auto ARCMAP_LOAD_PREFIXMAPLAYER = 64;
            constexpr auto ARCMAP_LOAD_MERGETOSINGLEVIEW = 128;
            constexpr auto ARCMAP_LOAD_INTOCURRENTFRAME = 256;
            constexpr auto ARCMAP_LOAD_NOMAPLAYERS = 512;
            constexpr auto ARCMAP_LOAD_ACTIVATE = 1024;
            constexpr auto ARCMAP_LOAD_NEW = 2048;
            constexpr auto ARCMAP_LOAD_NAMETAGISPREFIX = 4096;
// BF_BYTEORDER
            constexpr auto BF_BYTEORDER_LSB = 256;
            constexpr auto BF_BYTEORDER_MSB = 512;
// BF_CLOSE
            constexpr auto BF_KEEP = 0;
            constexpr auto BF_DELETE = 1;
// BF_ENCODE
            constexpr auto BF_ENCODE_ANSI = 0;
            constexpr auto BF_ENCODE_UTF8 = 1;
// BF_OPEN_MODE
            constexpr auto BF_READ = 0;
            constexpr auto BF_READWRITE_NEW = 1;
            constexpr auto BF_READWRITE_OLD = 2;
            constexpr auto BF_READWRITE_APP = 4;
// BF_SEEK
            constexpr auto BF_SEEK_START = 0;
            constexpr auto BF_SEEK_CURRENT = 1;
            constexpr auto BF_SEEK_EOF = 2;
// CHIMERA_MAX_CHAN
            constexpr auto CHIMERA_MAX_CHAN = 128;
// CHIMERA_PLOT
            constexpr auto CHIMERA_PLOT_ROSE = 0;
            constexpr auto CHIMERA_PLOT_PIE = 1;
            constexpr auto CHIMERA_PLOT_BAR = 2;
// COM_BAUD
            constexpr auto COM_BAUD_110 = 0;
            constexpr auto COM_BAUD_300 = 1;
            constexpr auto COM_BAUD_600 = 2;
            constexpr auto COM_BAUD_1200 = 3;
            constexpr auto COM_BAUD_2400 = 4;
            constexpr auto COM_BAUD_4800 = 5;
            constexpr auto COM_BAUD_9600 = 6;
            constexpr auto COM_BAUD_14400 = 7;
            constexpr auto COM_BAUD_19200 = 8;
            constexpr auto COM_BAUD_56000 = 9;
            constexpr auto COM_BAUD_57600 = 10;
            constexpr auto COM_BAUD_115200 = 11;
            constexpr auto COM_BAUD_128000 = 12;
            constexpr auto COM_BAUD_256000 = 13;
            constexpr auto COM_BAUD_38400 = 14;
// COM_DATASIZE
            constexpr auto COM_DATASIZE_FIVE = 5;
            constexpr auto COM_DATASIZE_SIX = 6;
            constexpr auto COM_DATASIZE_SEVEN = 7;
            constexpr auto COM_DATASIZE_EIGHT = 8;
// COM_FLOWCONTROL
            constexpr auto COM_FLOWCONTROL_NONE = 0;
            constexpr auto COM_FLOWCONTROL_RTS_CTS = 1;
            constexpr auto COM_FLOWCONTROL_DTR_DSR = 2;
            constexpr auto COM_FLOWCONTROL_XON_XOFF = 3;
// COM_PARITY
            constexpr auto COM_PARITY_EVEN = 0;
            constexpr auto COM_PARITY_NARK = 1;
            constexpr auto COM_PARITY_NONE = 2;
            constexpr auto COM_PARITY_ODD = 3;
            constexpr auto COM_PARITY_SPACE = 4;
// COM_STOPBITS
            constexpr auto COM_STOPBITS_ONE = 0;
            constexpr auto COM_STOPBITS_ONE5 = 1;
            constexpr auto COM_STOPBITS_TWO = 2;
// CSYMB_COLOR
            constexpr auto CSYMB_COLOR_EDGE = 0;
            constexpr auto CSYMB_COLOR_FILL = 1;
// DAT_FILE
            constexpr auto DAT_FILE_GRID = 1;
            constexpr auto DAT_FILE_IMAGE = 2;
// DAT_FILE_FORM
            constexpr auto DAT_FILE_FORM_OPEN = 0;
            constexpr auto DAT_FILE_FORM_SAVE = 1;
// DAT_XGD
            constexpr auto DAT_XGD_READ = 0;
            constexpr auto DAT_XGD_NEW = 1;
            constexpr auto DAT_XGD_WRITE = 2;
// GIS_DMTYPE
            constexpr auto GIS_DMTYPE_STRING = 2;
            constexpr auto GIS_DMTYPE_WIREFRAME_TR = 8;
            constexpr auto GIS_DMTYPE_DTM = 16;
            constexpr auto GIS_DMTYPE_BLOCKMODEL = 32;
            constexpr auto GIS_DMTYPE_WIREFRAME_PT = 64;
            constexpr auto GIS_DMTYPE_POINTDATA = 1024;
// DB_ACTIVITY_BLOB
            constexpr auto DB_ACTIVITY_BLOB = gx_string_literal("OE.DB_ACTIVITY_LOG");
// DB_CATEGORY_BLOB
            constexpr auto DB_CATEGORY_BLOB_NORMAL = 0;
// DB_CATEGORY_CHAN
            constexpr auto DB_CATEGORY_CHAN_BYTE = GS_BYTE;
            constexpr auto DB_CATEGORY_CHAN_USHORT = GS_USHORT;
            constexpr auto DB_CATEGORY_CHAN_SHORT = GS_SHORT;
            constexpr auto DB_CATEGORY_CHAN_LONG = GS_LONG;
            constexpr auto DB_CATEGORY_CHAN_FLOAT = GS_FLOAT;
            constexpr auto DB_CATEGORY_CHAN_DOUBLE = GS_DOUBLE;
            constexpr auto DB_CATEGORY_CHAN_UBYTE = GS_UBYTE;
            constexpr auto DB_CATEGORY_CHAN_ULONG = GS_ULONG;
            constexpr auto DB_CATEGORY_CHAN_LONG64 = GS_LONG64;
            constexpr auto DB_CATEGORY_CHAN_ULONG64 = GS_ULONG64;
// DB_CATEGORY_LINE
            constexpr auto DB_CATEGORY_LINE_FLIGHT = 100;
            constexpr auto DB_CATEGORY_LINE_GROUP = 200;
            constexpr auto DB_CATEGORY_LINE_NORMAL = DB_CATEGORY_LINE_FLIGHT;
// DB_CATEGORY_USER
            constexpr auto DB_CATEGORY_USER_NORMAL = 0;
// DB_CHAN_FORMAT
            constexpr auto DB_CHAN_FORMAT_NORMAL = FORMAT_DECIMAL;
            constexpr auto DB_CHAN_FORMAT_EXP = FORMAT_EXP;
            constexpr auto DB_CHAN_FORMAT_TIME = FORMAT_TIME_COLON;
            constexpr auto DB_CHAN_FORMAT_DATE = FORMAT_DATE_YYYYMMDD;
            constexpr auto DB_CHAN_FORMAT_GEOGR = FORMAT_GEOGRAPHIC;
            constexpr auto DB_CHAN_FORMAT_SIGDIG = FORMAT_SIG_DIG;
            constexpr auto DB_CHAN_FORMAT_HEX = 6;
// DB_CHAN_PROTECTION
            constexpr auto DB_CHAN_UNPROTECTED = 0;
            constexpr auto DB_CHAN_PROTECTED = 1;
// DB_CHAN_SYMBOL
            constexpr auto DB_CHAN_X = 0;
            constexpr auto DB_CHAN_Y = 1;
            constexpr auto DB_CHAN_Z = 2;
// DB_COMP
            constexpr auto DB_COMP_NONE = 0;
            constexpr auto DB_COMP_SPEED = 1;
            constexpr auto DB_COMP_SIZE = 2;
// DB_COORDPAIR
            constexpr auto DB_COORDPAIR_NONE = 0;
            constexpr auto DB_COORDPAIR_X = 1;
            constexpr auto DB_COORDPAIR_Y = 2;
// DB_GROUP_CLASS_SIZE
            constexpr auto DB_GROUP_CLASS_SIZE = 16;
// DB_INFO
            constexpr auto DB_INFO_BLOBS_MAX = 0;
            constexpr auto DB_INFO_LINES_MAX = 1;
            constexpr auto DB_INFO_CHANS_MAX = 2;
            constexpr auto DB_INFO_USERS_MAX = 3;
            constexpr auto DB_INFO_BLOBS_USED = 4;
            constexpr auto DB_INFO_LINES_USED = 5;
            constexpr auto DB_INFO_CHANS_USED = 6;
            constexpr auto DB_INFO_USERS_USED = 7;
            constexpr auto DB_INFO_PAGE_SIZE = 8;
            constexpr auto DB_INFO_DATA_SIZE = 9;
            constexpr auto DB_INFO_LOST_SIZE = 10;
            constexpr auto DB_INFO_FREE_SIZE = 11;
            constexpr auto DB_INFO_COMP_LEVEL = 16;
            constexpr auto DB_INFO_BLOB_SIZE = 19;
            constexpr auto DB_INFO_FILE_SIZE = 17;
            constexpr auto DB_INFO_INDEX_SIZE = 18;
            constexpr auto DB_INFO_MAX_BLOCK_SIZE = 20;
            constexpr auto DB_INFO_CHANGESLOST = 21;
// DB_LINE_LABEL_FORMAT
            constexpr auto DB_LINE_LABEL_FORMAT_LINE = 1;
            constexpr auto DB_LINE_LABEL_FORMAT_VERSION = 2;
            constexpr auto DB_LINE_LABEL_FORMAT_TYPE = 4;
            constexpr auto DB_LINE_LABEL_FORMAT_FLIGHT = 8;
            constexpr auto DB_LINE_LABEL_FORMAT_FULL = 15;
            constexpr auto DB_LINE_LABEL_FORMAT_DATE = 16;
            constexpr auto DB_LINE_LABEL_FORMAT_LINK = 7;
// DB_LINE_SELECT
            constexpr auto DB_LINE_SELECT_INCLUDE = 0;
            constexpr auto DB_LINE_SELECT_EXCLUDE = 1;
// DB_LINE_TYPE
            constexpr auto DB_LINE_TYPE_NORMAL = 0;
            constexpr auto DB_LINE_TYPE_BASE = 1;
            constexpr auto DB_LINE_TYPE_TIE = 2;
            constexpr auto DB_LINE_TYPE_TEST = 3;
            constexpr auto DB_LINE_TYPE_TREND = 4;
            constexpr auto DB_LINE_TYPE_SPECIAL = 5;
            constexpr auto DB_LINE_TYPE_RANDOM = 6;
// DB_LOCK
            constexpr auto DB_LOCK_NONE = -1;
            constexpr auto DB_LOCK_READONLY = 0;
            constexpr auto DB_LOCK_READWRITE = 1;
// DB_NAME
            constexpr auto DB_NAME_FILE = 0;
// DB_OWN
            constexpr auto DB_OWN_SHARED = 0;
            constexpr auto DB_OWN_USER = 1;
// DB_SYMB_TYPE
            constexpr auto DB_SYMB_BLOB = 0;
            constexpr auto DB_SYMB_LINE = 1;
            constexpr auto DB_SYMB_CHAN = 2;
            constexpr auto DB_SYMB_USER = 3;
// DB_SYMB_NAME_SIZE
            constexpr auto DB_SYMB_NAME_SIZE = STR_DB_SYMBOL;
// DB_WAIT
            constexpr auto DB_WAIT_NONE = 0;
            constexpr auto DB_WAIT_INFINITY = -1;
// DB_ARRAY_BASETYPE
            constexpr auto DB_ARRAY_BASETYPE_NONE = 0;
            constexpr auto DB_ARRAY_BASETYPE_TIME_WINDOWS = 1;
            constexpr auto DB_ARRAY_BASETYPE_TIMES = 2;
            constexpr auto DB_ARRAY_BASETYPE_FREQUENCIES = 3;
            constexpr auto DB_ARRAY_BASETYPE_ELEVATIONS = 4;
            constexpr auto DB_ARRAY_BASETYPE_DEPTHS = 5;
            constexpr auto DB_ARRAY_BASETYPE_VELOCITIES = 6;
            constexpr auto DB_ARRAY_BASETYPE_DISCRETE_TIME_WINDOWS = 7;
// NULLSYMB
            constexpr auto NULLSYMB = -1;
// BRIGHT
            constexpr auto BRIGHT_ALL = 0;
            constexpr auto BRIGHT_LAYER = 1;
// BRIGHTNESS_TYPES
            constexpr auto BRIGHTNESS_ALL = 0;
            constexpr auto BRIGHTNESS_ALL_AND_LAYERS = 1;
// DCOL_TYPE
            constexpr auto DCOL_TYPE_UNKNOWN = 0;
            constexpr auto DCOL_TYPE_GRID = 1;
            constexpr auto DCOL_TYPE_SYMBOLS = 2;
            constexpr auto DCOL_TYPE_VOXEL = 3;
            constexpr auto DCOL_TYPE_VECTOR_VOXEL = 4;
// DGW_OBJECT
            constexpr auto DGW_LABEL = 0;
            constexpr auto DGW_TEXT = 1;
            constexpr auto DGW_PATH = 2;
            constexpr auto DGW_FILEPATH = 3;
            constexpr auto DGW_LISTVAL = 4;
            constexpr auto DGW_LISTALIAS = 5;
            constexpr auto DGW_EXT = 7;
            constexpr auto DGW_HIDE = 8;
// DH_DEFAULT_FILENAMES
            constexpr auto DH_DEFAULT_ROCKCODE_FILE = gx_string_literal("agso.csv");
            constexpr auto DH_DEFAULT_STRUCTURECODE_FILE = gx_string_literal("structcodes.csv");
// STR_DH_HOLES
            constexpr auto STR_DH_HOLES = 1048576;
// DH_COMP_CHOICE
            constexpr auto DH_COMP_DONE = 0;
            constexpr auto DH_COMP_CANCEL = -1;
            constexpr auto DH_COMP_SELECT = 1;
            constexpr auto DH_COMP_REFRESH = 2;
// DH_COMPSTDB_HOLSEL
            constexpr auto DH_COMPSTDB_HOLSEL_ALL = 0;
            constexpr auto DH_COMPSTDB_HOLSEL_SELECTED = 1;
// DH_COMPSTDB_INTSEL
            constexpr auto DH_COMPSTDB_INTSEL_FIXED = 0;
            constexpr auto DH_COMPSTDB_INTSEL_LITHOLOGY = 1;
            constexpr auto DH_COMPSTDB_INTSEL_BESTFITLITH = 2;
            constexpr auto DH_COMPSTDB_INTSEL_INTFILE = 3;
// DH_DATA
            constexpr auto DH_DATA_DIPAZIMUTH = 0;
            constexpr auto DH_DATA_EASTNORTH = 1;
            constexpr auto DH_DATA_FROMTO = 2;
            constexpr auto DH_DATA_POINT = 3;
            constexpr auto DH_DATA_COLLAR = 4;
            constexpr auto DH_DATA_UNKNOWN = 100;
// DH_DEFINE_PLAN
            constexpr auto DH_DEFINE_PLAN = 1;
// DH_DEFINE_SECT
            constexpr auto DH_DEFINE_SECT_NS = 1;
            constexpr auto DH_DEFINE_SECT_EW = 2;
            constexpr auto DH_DEFINE_SECT_ANGLED = 3;
// DH_EXP
            constexpr auto DH_EXP_CSV = 0;
            constexpr auto DH_EXP_ASCII = 1;
            constexpr auto DH_EXP_ACCESS = 2;
            constexpr auto DH_EXP_SHP = 3;
            constexpr auto DH_EXP_SURPAC = 4;
            constexpr auto DH_EXP_SHP_TRACES = 5;
// DH_HOLES
            constexpr auto DH_HOLES_ALL = 0;
            constexpr auto DH_HOLES_SELECTED = 1;
// DH_MASK
            constexpr auto DH_MASK_APPEND = 0;
            constexpr auto DH_MASK_NEW = 1;
// DH_PLOT
            constexpr auto DH_PLOT_PLAN = 0;
            constexpr auto DH_PLOT_SECTION = 1;
            constexpr auto DH_PLOT_STRIPLOG = 2;
            constexpr auto DH_PLOT_HOLE_TRACES = 3;
            constexpr auto DH_PLOT_3D = 4;
            constexpr auto DH_PLOT_SECTION_STACK = 5;
            constexpr auto DH_PLOT_SECTION_FENCE = 6;
            constexpr auto DH_PLOT_SECTION_CROOKED = 7;
// DH_SECT_PAGE
            constexpr auto DH_SECT_PAGE_SECTION = 1;
// DH_SURFACE
            constexpr auto DH_SURFACE_FIRST_LAYER_FROM = 0;
            constexpr auto DH_SURFACE_FIRST_LAYER_TO = 1;
            constexpr auto DH_SURFACE_SECOND_LAYER_FROM = 2;
            constexpr auto DH_SURFACE_SECOND_LAYER_TO = 3;
            constexpr auto DH_SURFACE_LAST_LAYER_FROM = 4;
            constexpr auto DH_SURFACE_LAST_LAYER_TO = 5;
// DIP_CONVENTION
            constexpr auto DIP_CONVENTION_NEGATIVE = -1;
            constexpr auto DIP_CONVENTION_POSITIVE = 1;
// DH_DESURVEY
            constexpr auto DH_DESURVEY_RAD_CURVE = 0;
            constexpr auto DH_DESURVEY_POLYNOMIAL = 1;
            constexpr auto DH_DESURVEY_STRAIGHT_SEG = 2;
// DOCU_OPEN
            constexpr auto DOCU_OPEN_VIEW = 0;
            constexpr auto DOCU_OPEN_EDIT = 1;
// DSEL_PICTURE_QUALITY
            constexpr auto DSEL_PICTURE_QUALITY_DEFAULT = 0;
            constexpr auto DSEL_PICTURE_QUALITY_LOSSLESS = 1;
            constexpr auto DSEL_PICTURE_QUALITY_SEMILOSSY = 2;
            constexpr auto DSEL_PICTURE_QUALITY_LOSSY = 3;
            constexpr auto DSEL_PICTURE_QUALITY_NATIVE = 4;
            constexpr auto DSEL_PICTURE_QUALITY_ECW = 5;
            constexpr auto DSEL_PICTURE_QUALITY_JPG = 6;
            constexpr auto DSEL_PICTURE_QUALITY_PNG = 7;
            constexpr auto DSEL_PICTURE_QUALITY_BMP = 8;
            constexpr auto DSEL_PICTURE_QUALITY_TIF = 9;
// DB_DUP
            constexpr auto DB_DUP_FIRST = 1;
            constexpr auto DB_DUP_AVERAGE = 2;
            constexpr auto DB_DUP_MINIMUM = 3;
            constexpr auto DB_DUP_MAXIMUM = 4;
            constexpr auto DB_DUP_MEDIAN = 5;
            constexpr auto DB_DUP_LAST = 6;
// DB_DUPEDIT
            constexpr auto DB_DUPEDIT_SINGLE = 0;
            constexpr auto DB_DUPEDIT_ALL = 1;
// DU_CHANNELS
            constexpr auto DU_CHANNELS_DISPLAYED = 0;
            constexpr auto DU_CHANNELS_ALL = 1;
// DU_EXPORT
            constexpr auto DU_EXPORT_CSV = 0;
            constexpr auto DU_EXPORT_ODDF = 1;
            constexpr auto DU_EXPORT_POST_PC = 2;
            constexpr auto DU_EXPORT_POST_UNIX = 3;
// DU_FILL
            constexpr auto DU_FILL_INSIDE = 0;
            constexpr auto DU_FILL_OUTSIDE = 1;
// DU_IMPORT
            constexpr auto DU_IMPORT_APPEND = 0;
            constexpr auto DU_IMPORT_REPLACE = 1;
            constexpr auto DU_IMPORT_MERGE = 2;
            constexpr auto DU_IMPORT_MERGE_APPEND = 3;
// DU_INTERP
            constexpr auto DU_INTERP_NEAREST = 1;
            constexpr auto DU_INTERP_LINEAR = 2;
            constexpr auto DU_INTERP_CUBIC = 3;
            constexpr auto DU_INTERP_AKIMA = 4;
            constexpr auto DU_INTERP_PREDICT = 5;
// DU_INTERP_EDGE
            constexpr auto DU_INTERP_EDGE_NONE = 0;
            constexpr auto DU_INTERP_EDGE_SAME = 1;
            constexpr auto DU_INTERP_EDGE_NEAREST = 2;
            constexpr auto DU_INTERP_EDGE_LINEAR = 3;
// DU_LAB_TYPE
            constexpr auto DU_LAB_TYPE_FREE = 1;
            constexpr auto DU_LAB_TYPE_COMMA = 2;
// DU_LEVEL
            constexpr auto DU_LEVEL_LINES = 0;
            constexpr auto DU_LEVEL_TIES = 1;
            constexpr auto DU_LEVEL_ALL = 2;
// DU_LINEOUT
            constexpr auto DU_LINEOUT_SINGLE = 0;
            constexpr auto DU_LINEOUT_MULTIPLE = 1;
// DU_FEATURE_TYPE_OUTPUT
            constexpr auto DU_FEATURE_TYPE_OUTPUT_POINT = 0;
            constexpr auto DU_FEATURE_TYPE_OUTPUT_LINE = 1;
// DU_GEODATABASE_EXPORT_TYPE
            constexpr auto DU_GEODATABASE_EXPORT_TYPE_OVERWRITE_GEODATABASE = 0;
            constexpr auto DU_GEODATABASE_EXPORT_TYPE_OVERWRITE_FEATURECLASS = 1;
            constexpr auto DU_GEODATABASE_EXPORT_TYPE_APPEND = 2;
// DU_LINES
            constexpr auto DU_LINES_DISPLAYED = 0;
            constexpr auto DU_LINES_SELECTED = 1;
            constexpr auto DU_LINES_ALL = 2;
// DU_LOADLTB
            constexpr auto DU_LOADLTB_REPLACE = 0;
            constexpr auto DU_LOADLTB_APPEND = 1;
// DU_LOOKUP
            constexpr auto DU_LOOKUP_EXACT = 0;
            constexpr auto DU_LOOKUP_NEAREST = 1;
            constexpr auto DU_LOOKUP_INTERPOLATE = 2;
            constexpr auto DU_LOOKUP_NEARESTCLOSE = 3;
            constexpr auto DU_LOOKUP_INTERPCLOSE = 4;
            constexpr auto DU_LOOKUP_INTERPOLATE_DUMMYOUTSIDE = 5;
            constexpr auto DU_LOOKUP_INTERPOLATE_CONSTOUTSIDE = 6;
            constexpr auto DU_LOOKUP_INTERPOLATE_EXTPLOUTSIDE = 7;
            constexpr auto DU_LOOKUP_MAXOPTION = 8;
// DU_MASK
            constexpr auto DU_MASK_INSIDE = 0;
            constexpr auto DU_MASK_OUTSIDE = 1;
// DU_MERGE
            constexpr auto DU_MERGE_APPEND = 0;
// DU_MODFID
            constexpr auto DU_MODFID_INSERT = 0;
            constexpr auto DU_MODFID_DELETE = 1;
            constexpr auto DU_MODFID_APPEND = 2;
// DU_MOVE
            constexpr auto DU_MOVE_ABSOLUTE = 0;
            constexpr auto DU_MOVE_MINUS = 1;
            constexpr auto DU_MOVE_PLUS = 2;
            constexpr auto DU_MOVE_INTERP = 3;
// DU_REFID
            constexpr auto DU_REFID_LINEAR = 0;
            constexpr auto DU_REFID_MINCUR = 1;
            constexpr auto DU_REFID_AKIMA = 2;
            constexpr auto DU_REFID_NEAREST = 3;
// DU_SORT
            constexpr auto DU_SORT_ASCENDING = 0;
            constexpr auto DU_SORT_DESCENDING = 1;
// DU_SPLITLINE
            constexpr auto DU_SPLITLINE_XYPOSITION = 0;
            constexpr auto DU_SPLITLINE_SEQUENTIAL = 1;
            constexpr auto DU_SPLITLINE_TOVERSIONS = 2;
// DU_STORAGE
            constexpr auto DU_STORAGE_LINE = 0;
            constexpr auto DU_STORAGE_GROUP = 1;
// QC_PLAN_TYPE
            constexpr auto QC_PLAN_SURVEYLINE = 0;
            constexpr auto QC_PLAN_TIELINE = 1;
            constexpr auto QC_PLAN_BOTHLINES = 2;
// DU_DISTANCE_CHANNEL_TYPE
            constexpr auto DU_DISTANCE_CHANNEL_MAINTAIN_DIRECTION = 0;
            constexpr auto DU_DISTANCE_CHANNEL_CARTESIAN_COORDINATES = 1;
// DU_DIRECTGRID_METHOD
            constexpr auto DU_DIRECTGRID_MIN = 0;
            constexpr auto DU_DIRECTGRID_MAX = 1;
            constexpr auto DU_DIRECTGRID_MEAN = 2;
// MAX_PROF_WND
            constexpr auto MAX_PROF_WND = 5;
// EDB_PATH
            constexpr auto EDB_PATH_FULL = 0;
            constexpr auto EDB_PATH_DIR = 1;
            constexpr auto EDB_PATH_NAME_EXT = 2;
            constexpr auto EDB_PATH_NAME = 3;
// EDB_PROF
            constexpr auto EDB_PROF_I_CHANNEL = 0;
            constexpr auto EDB_PROF_I_LINE_STYLE = 1;
            constexpr auto EDB_PROF_I_LINE_WEIGHT = 2;
            constexpr auto EDB_PROF_I_SYMBOL = 3;
            constexpr auto EDB_PROF_I_SYMBOL_WEIGHT = 4;
            constexpr auto EDB_PROF_I_COLOR = 5;
            constexpr auto EDB_PROF_I_WRAP = 6;
            constexpr auto EDB_PROF_I_BREAK_ON_DUMMY = 7;
            constexpr auto EDB_PROF_I_GRID_LINE = 8;
            constexpr auto EDB_PROF_R_GRID_LINE_INTERVAL = 9;
            constexpr auto EDB_PROF_I_LOG = 10;
            constexpr auto EDB_PROF_R_LOG_MINIMUM = 11;
            constexpr auto EDB_PROF_I_SAMESCALE = 12;
            constexpr auto EDB_PROF_I_SOURCELINE = 13;
            constexpr auto EDB_PROF_I_SCALEOPTION = 14;
            constexpr auto EDB_PROF_I_SAMERANGE = 15;
// EDB_PROFILE_SCALE
            constexpr auto EDB_PROFILE_SCALE_LINEAR = 0;
            constexpr auto EDB_PROFILE_SCALE_LOG = 1;
            constexpr auto EDB_PROFILE_SCALE_LOGLINEAR = 2;
// EDB_REMOVE
            constexpr auto EDB_REMOVE_SAVE = 0;
            constexpr auto EDB_REMOVE_PROMPT = 1;
            constexpr auto EDB_REMOVE_DISCARD = 2;
// EDB_UNLOAD
            constexpr auto EDB_UNLOAD_NO_PROMPT = 0;
            constexpr auto EDB_UNLOAD_SINGLE_PROMPT = 1;
            constexpr auto EDB_UNLOAD_MULTI_PROMPT = 2;
// EDB_WINDOW_POSITION
            constexpr auto EDB_WINDOW_POSITION_DOCKED = 0;
            constexpr auto EDB_WINDOW_POSITION_FLOATING = 1;
// EDB_WINDOW_STATE
            constexpr auto EDB_WINDOW_RESTORE = 0;
            constexpr auto EDB_WINDOW_MINIMIZE = 1;
            constexpr auto EDB_WINDOW_MAXIMIZE = 2;
// EDB_YAXIS_DIRECTION
            constexpr auto EDB_YAXIS_NORMAL = 0;
            constexpr auto EDB_YAXIS_INVERTED = 1;
// EDOC_PATH
            constexpr auto EDOC_PATH_FULL = 0;
            constexpr auto EDOC_PATH_DIR = 1;
            constexpr auto EDOC_PATH_NAME_EXT = 2;
            constexpr auto EDOC_PATH_NAME = 3;
// EDOC_TYPE
            constexpr auto EDOC_TYPE_GMS3D = 0;
            constexpr auto EDOC_TYPE_VOXEL = 1;
            constexpr auto EDOC_TYPE_VOXEL_INVERSION = 2;
            constexpr auto EDOC_TYPE_GMS2D = 3;
            constexpr auto EDOC_TYPE_GEOSURFACE = 4;
// EDOC_UNLOAD
            constexpr auto EDOC_UNLOAD_NO_PROMPT = 0;
            constexpr auto EDOC_UNLOAD_PROMPT = 1;
// EDOC_WINDOW_POSITION
            constexpr auto EDOC_WINDOW_POSITION_DOCKED = 0;
            constexpr auto EDOC_WINDOW_POSITION_FLOATING = 1;
// EDOC_WINDOW_STATE
            constexpr auto EDOC_WINDOW_RESTORE = 0;
            constexpr auto EDOC_WINDOW_MINIMIZE = 1;
            constexpr auto EDOC_WINDOW_MAXIMIZE = 2;
// GMS3D_MODELTYPE
            constexpr auto GMS3D_MODELTYPE_DEPTH = 0;
            constexpr auto GMS3D_MODELTYPE_TIME = 1;
// GMS2D_MODELTYPE
            constexpr auto GMS2D_MODELTYPE_DEPTH = 0;
            constexpr auto GMS2D_MODELTYPE_TIME = 1;
// EMAP_FONT
            constexpr auto EMAP_FONT_TT = 0;
            constexpr auto EMAP_FONT_GFN = 1;
// EMAP_PATH
            constexpr auto EMAP_PATH_FULL = 0;
            constexpr auto EMAP_PATH_DIR = 1;
            constexpr auto EMAP_PATH_NAME_EXT = 2;
            constexpr auto EMAP_PATH_NAME = 3;
// EMAP_REDRAW
            constexpr auto EMAP_REDRAW_NO = 0;
            constexpr auto EMAP_REDRAW_YES = 1;
// EMAP_REMOVE
            constexpr auto EMAP_REMOVE_SAVE = 0;
            constexpr auto EMAP_REMOVE_PROMPT = 1;
            constexpr auto EMAP_REMOVE_DISCARD = 2;
// EMAP_TRACK
            constexpr auto EMAP_TRACK_ERASE = 1;
            constexpr auto EMAP_TRACK_RMENU = 2;
            constexpr auto EMAP_TRACK_CYCLE = 4;
// EMAP_VIEWPORT
            constexpr auto EMAP_VIEWPORT_NORMAL = 0;
            constexpr auto EMAP_VIEWPORT_BROWSEZOOM = 1;
            constexpr auto EMAP_VIEWPORT_BROWSEAOI = 2;
// EMAP_WINDOW_POSITION
            constexpr auto EMAP_WINDOW_POSITION_DOCKED = 0;
            constexpr auto EMAP_WINDOW_POSITION_FLOATING = 1;
// EMAP_WINDOW_STATE
            constexpr auto EMAP_WINDOW_RESTORE = 0;
            constexpr auto EMAP_WINDOW_MINIMIZE = 1;
            constexpr auto EMAP_WINDOW_MAXIMIZE = 2;
// LAYOUT_VIEW_UNITS
            constexpr auto LAYOUT_VIEW_MM = 0;
            constexpr auto LAYOUT_VIEW_CM = 1;
            constexpr auto LAYOUT_VIEW_IN = 2;
// EMAPTEMPLATE_PATH
            constexpr auto EMAPTEMPLATE_PATH_FULL = 0;
            constexpr auto EMAPTEMPLATE_PATH_DIR = 1;
            constexpr auto EMAPTEMPLATE_PATH_NAME_EXT = 2;
            constexpr auto EMAPTEMPLATE_PATH_NAME = 3;
// EMAPTEMPLATE_TRACK
            constexpr auto EMAPTEMPLATE_TRACK_ERASE = 1;
            constexpr auto EMAPTEMPLATE_TRACK_RMENU = 2;
            constexpr auto EMAPTEMPLATE_TRACK_CYCLE = 4;
// EMAPTEMPLATE_WINDOW_POSITION
            constexpr auto EMAPTEMPLATE_WINDOW_POSITION_DOCKED = 0;
            constexpr auto EMAPTEMPLATE_WINDOW_POSITION_FLOATING = 1;
// EMAPTEMPLATE_WINDOW_STATE
            constexpr auto EMAPTEMPLATE_WINDOW_RESTORE = 0;
            constexpr auto EMAPTEMPLATE_WINDOW_MINIMIZE = 1;
            constexpr auto EMAPTEMPLATE_WINDOW_MAXIMIZE = 2;
// EUL3_RESULT
            constexpr auto EUL3_RESULT_X = 1;
            constexpr auto EUL3_RESULT_Y = 2;
            constexpr auto EUL3_RESULT_DEPTH = 3;
            constexpr auto EUL3_RESULT_BACKGROUND = 4;
            constexpr auto EUL3_RESULT_DEPTHERROR = 5;
            constexpr auto EUL3_RESULT_LOCATIONERROR = 6;
            constexpr auto EUL3_RESULT_WINDOWX = 7;
            constexpr auto EUL3_RESULT_WINDOWY = 8;
// FFT_DETREND
            constexpr auto FFT_DETREND_NONE = 0;
            constexpr auto FFT_DETREND_ENDS = 1;
            constexpr auto FFT_DETREND_ALL = 2;
            constexpr auto FFT_DETREND_MEAN = 3;
// FFT_WHITE_NOISE
            constexpr auto FFT_WHITE_NOISE_ADD = 0;
            constexpr auto FFT_WHITE_NOISE_SET = 1;
// FFT2_PG
            constexpr auto FFT2_PG_FORWARD = 0;
            constexpr auto FFT2_PG_INVERSE = 1;
// GD_STATUS
            constexpr auto GD_STATUS_READONLY = 0;
            constexpr auto GD_STATUS_NEW = 1;
            constexpr auto GD_STATUS_OLD = 2;
// GEOSTRING_OPEN
            constexpr auto GEOSTRING_OPEN_READ = 0;
            constexpr auto GEOSTRING_OPEN_READWRITE = 1;
// SECTION_ORIENTATION
            constexpr auto SECTION_ORIENTATION_UNKNOWN = 0;
            constexpr auto SECTION_ORIENTATION_PLAN = 1;
            constexpr auto SECTION_ORIENTATION_SECTION = 2;
            constexpr auto SECTION_ORIENTATION_CROOKED = 2;
            constexpr auto SECTION_ORIENTATION_GMSYS = 2;
// GIS_MAP2D
            constexpr auto GIS_MAP2D_PLAN = 0;
            constexpr auto GIS_MAP2D_EWSECTION = 1;
            constexpr auto GIS_MAP2D_NSSECTION = 2;
// GIS_TYPE
            constexpr auto GIS_TYPE_MAPINFO = 1;
            constexpr auto GIS_TYPE_ARCVIEW = 2;
            constexpr auto GIS_TYPE_DGN = 3;
            constexpr auto GIS_TYPE_SURPAC = 4;
            constexpr auto GIS_TYPE_DATAMINE = 5;
            constexpr auto GIS_TYPE_GEMCOM = 6;
            constexpr auto GIS_TYPE_MICROMINE = 7;
            constexpr auto GIS_TYPE_MINESIGHT = 8;
// GRID3D_TYPE
            constexpr auto GRID3D_DOUBLE = 0;
            constexpr auto GRID3D_VECTOR = 1;
            constexpr auto GRID3D_THEMATIC = 2;
// EM_ERR
            constexpr auto EM_ERR_UNSCALED = 0;
            constexpr auto EM_ERR_LOGSCALING = 1;
// EM_INV
            constexpr auto EM_INV_INPHASE = 0;
            constexpr auto EM_INV_QUADRATURE = 1;
            constexpr auto EM_INV_BOTH = 2;
// EMPLATE_DOMAIN
            constexpr auto EMPLATE_FREQUENCY = 1;
            constexpr auto EMPLATE_TIME = 9;
// EMPLATE_TX
            constexpr auto EMPLATE_TX_X = 1;
            constexpr auto EMPLATE_TX_Y = 2;
            constexpr auto EMPLATE_TX_Z = 3;
// GU_DAARC500_DATATYPE
            constexpr auto GU_DAARC500_UNKNOWN = 0;
            constexpr auto GU_DAARC500_GENERIC_ASCII = 1;
            constexpr auto GU_DAARC500_GPS = 2;
            constexpr auto GU_DAARC500_GR820_256D = 3;
            constexpr auto GU_DAARC500_GR820_256DU = 4;
            constexpr auto GU_DAARC500_GR820_512DU = 5;
            constexpr auto GU_DAARC500_NAV = 6;
// PEAKEULER_XY
            constexpr auto PEAKEULER_XY_NOFIT = 0;
            constexpr auto PEAKEULER_XY_FIT = 1;
// AOI_RETURN_STATE
            constexpr auto AOI_RETURN_CANCEL = -1;
            constexpr auto AOI_RETURN_NODEFINE = 0;
            constexpr auto AOI_RETURN_DEFINE = 1;
// COORDSYS_MODE
            constexpr auto COORDSYS_MODE_ALL = 0;
            constexpr auto COORDSYS_MODE_GCS = 1;
            constexpr auto COORDSYS_MODE_PCS = 2;
            constexpr auto COORDSYS_MODE_GCS_PCS = 3;
            constexpr auto COORDSYS_MODE_PCS_UNKNOWN = 4;
// DAT_TYPE
            constexpr auto DAT_TYPE_GRID = 0;
            constexpr auto DAT_TYPE_IMAGE = 1;
            constexpr auto DAT_TYPE_GRID_AND_IMAGE = 2;
// FILE_FILTER
            constexpr auto FILE_FILTER_ALL = 1;
            constexpr auto FILE_FILTER_GDB = 2;
            constexpr auto FILE_FILTER_GX = 3;
            constexpr auto FILE_FILTER_GS = 4;
            constexpr auto FILE_FILTER_INI = 5;
            constexpr auto FILE_FILTER_OMN = 6;
            constexpr auto FILE_FILTER_VU = 7;
            constexpr auto FILE_FILTER_MAP = 8;
            constexpr auto FILE_FILTER_PRJ = 9;
            constexpr auto FILE_FILTER_CON = 10;
            constexpr auto FILE_FILTER_MNU = 11;
            constexpr auto FILE_FILTER_PDF = 12;
            constexpr auto FILE_FILTER_PLT = 13;
            constexpr auto FILE_FILTER_GWS = 14;
            constexpr auto FILE_FILTER_AGG = 15;
            constexpr auto FILE_FILTER_TBL = 16;
            constexpr auto FILE_FILTER_ZON = 17;
            constexpr auto FILE_FILTER_ITR = 18;
            constexpr auto FILE_FILTER_DXF = 19;
            constexpr auto FILE_FILTER_TIF = 20;
            constexpr auto FILE_FILTER_EMF = 21;
            constexpr auto FILE_FILTER_BMP = 22;
            constexpr auto FILE_FILTER_LUT = 23;
            constexpr auto FILE_FILTER_PNG = 24;
            constexpr auto FILE_FILTER_JPG = 25;
            constexpr auto FILE_FILTER_PCX = 26;
            constexpr auto FILE_FILTER_GIF = 27;
            constexpr auto FILE_FILTER_GRD = 28;
            constexpr auto FILE_FILTER_ERS = 29;
            constexpr auto FILE_FILTER_EPS = 30;
            constexpr auto FILE_FILTER_SHP = 31;
            constexpr auto FILE_FILTER_CGM = 32;
            constexpr auto FILE_FILTER_TAB = 33;
            constexpr auto FILE_FILTER_COMPS = 34;
            constexpr auto FILE_FILTER_CSV = 35;
            constexpr auto FILE_FILTER_GPF = 36;
            constexpr auto FILE_FILTER_PLY = 37;
            constexpr auto FILE_FILTER_STM = 38;
            constexpr auto FILE_FILTER_TTM = 39;
            constexpr auto FILE_FILTER_XYZ = 40;
            constexpr auto FILE_FILTER_BAR = 41;
            constexpr auto FILE_FILTER_GEOSOFT_LICENSE = 42;
            constexpr auto FILE_FILTER_XML = 43;
            constexpr auto FILE_FILTER_GXNET = 44;
            constexpr auto FILE_FILTER_ECW = 45;
            constexpr auto FILE_FILTER_J2K = 46;
            constexpr auto FILE_FILTER_JP2 = 47;
            constexpr auto FILE_FILTER_SEL = 48;
            constexpr auto FILE_FILTER_SVG = 49;
            constexpr auto FILE_FILTER_SVZ = 50;
            constexpr auto FILE_FILTER_WRP = 51;
            constexpr auto FILE_FILTER_MAPPLOT = 52;
            constexpr auto FILE_FILTER_DTM = 53;
            constexpr auto FILE_FILTER_VOXEL = 54;
            constexpr auto FILE_FILTER_MAPTEMPLATE = 55;
            constexpr auto FILE_FILTER_ACTION = 56;
            constexpr auto FILE_FILTER_DM = 57;
            constexpr auto FILE_FILTER_KML = 58;
            constexpr auto FILE_FILTER_KMZ = 59;
            constexpr auto FILE_FILTER_TARGET_PLAN = 60;
            constexpr auto FILE_FILTER_TARGET_SECTION = 61;
            constexpr auto FILE_FILTER_TARGET_STRIPLOG = 62;
            constexpr auto FILE_FILTER_TARGET_3D = 63;
            constexpr auto FILE_FILTER_ARGIS_LYR = 64;
            constexpr auto FILE_FILTER_ARGIS_MXD = 65;
            constexpr auto FILE_FILTER_GOCAD_TS = 66;
            constexpr auto FILE_FILTER_LST = 67;
            constexpr auto FILE_FILTER_ECS = 68;
            constexpr auto FILE_FILTER_TARGET_FENCE = 69;
            constexpr auto FILE_FILTER_GMS3D = 70;
            constexpr auto FILE_FILTER_BT2 = 71;
            constexpr auto FILE_FILTER_BPR = 72;
            constexpr auto FILE_FILTER_BPR2 = 73;
            constexpr auto FILE_FILTER_XLS = 74;
            constexpr auto FILE_FILTER_XLSX = 75;
            constexpr auto FILE_FILTER_MDB = 76;
            constexpr auto FILE_FILTER_ACCDB = 77;
            constexpr auto FILE_FILTER_INTERSECTION_TBL = 78;
            constexpr auto FILE_FILTER_UBC_CON = 79;
            constexpr auto FILE_FILTER_UBC_CHG = 80;
            constexpr auto FILE_FILTER_UBC_MSH = 81;
            constexpr auto FILE_FILTER_UBC_MSH_DAT = 82;
            constexpr auto FILE_FILTER_UBC_TOPO_DAT = 83;
            constexpr auto FILE_FILTER_UBC_TOPO_XYZ = 84;
            constexpr auto FILE_FILTER_XYZ_TEMPLATE_I0 = 85;
            constexpr auto FILE_FILTER_PICO_TEMPLATE_I1 = 86;
            constexpr auto FILE_FILTER_BB_TEMPLATE_I2 = 87;
            constexpr auto FILE_FILTER_ASCII_TEMPLATE_I3 = 88;
            constexpr auto FILE_FILTER_ODBC_TEMPLATE_I4 = 89;
            constexpr auto FILE_FILTER_EXP = 90;
            constexpr auto FILE_FILTER_SEGY = 91;
            constexpr auto FILE_FILTER_DAARC500 = 92;
            constexpr auto FILE_FILTER_TXT = 93;
            constexpr auto FILE_FILTER_VOXEL_INVERSION = 94;
            constexpr auto FILE_FILTER_GMS = 95;
            constexpr auto FILE_FILTER_FLT3D = 96;
            constexpr auto FILE_FILTER_RESOURCE_PACK = 97;
            constexpr auto FILE_FILTER_GEOSTRING = 98;
            constexpr auto FILE_FILTER_GEOSURFACE = 99;
            constexpr auto FILE_FILTER_GEOSOFT3DV = 100;
            constexpr auto FILE_FILTER_VECTORVOXEL = 101;
            constexpr auto FILE_FILTER_FLT = 102;
            constexpr auto FILE_FILTER_XYZ_TEMPLATE_O0 = 103;
            constexpr auto FILE_FILTER_GMS2D = 104;
            constexpr auto FILE_FILTER_IP_DATABASE_TEMPLATE = 105;
            constexpr auto FILE_FILTER_GEOSOFT_RESOURCE_MODULE = 106;
            constexpr auto FILE_FILTER_VT = 107;
            constexpr auto FILE_FILTER_INT = 108;
            constexpr auto FILE_FILTER_SGT = 109;
            constexpr auto FILE_FILTER_IMGVIEW = 110;
            constexpr auto FILE_FILTER_ZIP = 111;
            constexpr auto FILE_FILTER_GPS_TABLE = 112;
            constexpr auto FILE_FILTER_VULCAN_TRIANGULATION = 113;
            constexpr auto FILE_FILTER_VULCAN_BLOCK_MODEL = 114;
            constexpr auto FILE_FILTER_PRJVIEW = 115;
            constexpr auto FILE_FILTER_LEAPFROG_MODEL = 116;
            constexpr auto FILE_FILTER_IOGAS = 117;
            constexpr auto FILE_FILTER_ASEG_ESF = 118;
            constexpr auto FILE_FILTER_LACOSTE_DAT = 119;
            constexpr auto FILE_FILTER_VAR = 120;
            constexpr auto FILE_FILTER_P190 = 121;
            constexpr auto FILE_FILTER_UBC_OBS_DAT = 122;
            constexpr auto FILE_FILTER_UBC_LOC = 123;
            constexpr auto FILE_FILTER_UBC_MOD = 124;
            constexpr auto FILE_FILTER_UBC_DEN = 125;
            constexpr auto FILE_FILTER_UBC_SUS = 126;
            constexpr auto FILE_FILTER_GOCAD_VOXET = 127;
            constexpr auto FILE_FILTER_SCINTREX_DAT = 128;
            constexpr auto FILE_FILTER_DMP = 129;
            constexpr auto FILE_FILTER_RAW = 130;
            constexpr auto FILE_FILTER_DAT = 131;
            constexpr auto FILE_FILTER_OMF = 132;
            constexpr auto FILE_FILTER_3DSURVEY = 133;
// FILE_FORM
            constexpr auto FILE_FORM_OPEN = 0;
            constexpr auto FILE_FORM_SAVE = 1;
// GS_DIRECTORY
            constexpr auto GS_DIRECTORY_NONE = 0;
            constexpr auto GS_DIRECTORY_GEOSOFT = 1;
            constexpr auto GS_DIRECTORY_BIN = 2;
            constexpr auto GS_DIRECTORY_GER = 3;
            constexpr auto GS_DIRECTORY_OMN = 4;
            constexpr auto GS_DIRECTORY_TBL = 5;
            constexpr auto GS_DIRECTORY_FONTS = 6;
            constexpr auto GS_DIRECTORY_GX = 7;
            constexpr auto GS_DIRECTORY_GS = 8;
            constexpr auto GS_DIRECTORY_APPS = 9;
            constexpr auto GS_DIRECTORY_ETC = 10;
            constexpr auto GS_DIRECTORY_HLP = 11;
            constexpr auto GS_DIRECTORY_GXDEV = 12;
            constexpr auto GS_DIRECTORY_COMPONENT = 13;
            constexpr auto GS_DIRECTORY_CSV = 14;
            constexpr auto GS_DIRECTORY_LIC = 15;
            constexpr auto GS_DIRECTORY_INI = 16;
            constexpr auto GS_DIRECTORY_TEMP = 17;
            constexpr auto GS_DIRECTORY_UETC = 18;
            constexpr auto GS_DIRECTORY_UMAPTEMPLATE = 19;
            constexpr auto GS_DIRECTORY_COMPONENT_SCRIPTS = 50;
            constexpr auto GS_DIRECTORY_COMPONENT_HTML = 51;
            constexpr auto GS_DIRECTORY_IMG = 52;
            constexpr auto GS_DIRECTORY_BAR = 53;
            constexpr auto GS_DIRECTORY_GXNET = 54;
            constexpr auto GS_DIRECTORY_MAPTEMPLATE = 55;
// IMPCH_TYPE
            constexpr auto IMPCH_TYPE_DATA = 0;
            constexpr auto IMPCH_TYPE_ASSAY = 1;
// WINDOW_STATE
            constexpr auto WINDOW_RESTORE = 0;
            constexpr auto WINDOW_MINIMIZE = 1;
            constexpr auto WINDOW_MAXIMIZE = 2;
// XTOOL_ALIGN
            constexpr auto XTOOL_ALIGN_LEFT = 1;
            constexpr auto XTOOL_ALIGN_TOP = 2;
            constexpr auto XTOOL_ALIGN_RIGHT = 4;
            constexpr auto XTOOL_ALIGN_BOTTOM = 8;
            constexpr auto XTOOL_ALIGN_ANY = 15;
// XTOOL_DOCK
            constexpr auto XTOOL_DOCK_TOP = 1;
            constexpr auto XTOOL_DOCK_LEFT = 2;
            constexpr auto XTOOL_DOCK_RIGHT = 3;
            constexpr auto XTOOL_DOCK_BOTTOM = 4;
            constexpr auto XTOOL_DOCK_FLOAT = 5;
// IMG_DISPLAY_PROPERTY
            constexpr auto IMG_SHADING_INCLINATION = 0;
            constexpr auto IMG_SHADING_DECLINATION = 1;
            constexpr auto IMG_SHADING_SCALE = 2;
            constexpr auto IMG_SHADING_CONTRAST = 3;
            constexpr auto IMG_SHADING_BRIGHTNESS = 4;
            constexpr auto IMG_SHADING_WETLOOK = 5;
            constexpr auto IMG_COLOURS_REVERSED = 6;
            constexpr auto IMG_SMOOTHING_ENABLED = 7;
            constexpr auto IMG_SHADING_ENABLED = 8;
// IMG_FAULT
            constexpr auto IMG_FAULT_POLYLINE = 0;
            constexpr auto IMG_FAULT_POLYGON = 1;
// IMG_FILE
            constexpr auto IMG_FILE_READONLY = 0;
            constexpr auto IMG_FILE_READWRITE = 2;
            constexpr auto IMG_FILE_READORWRITE = 3;
// IMG_QUERY
            constexpr auto IMG_QUERY_iWRITE = 0;
            constexpr auto IMG_QUERY_iPG = 1;
            constexpr auto IMG_QUERY_iWRITEPG = 2;
            constexpr auto IMG_QUERY_iIMGTYPE = 3;
            constexpr auto IMG_QUERY_iDATTYPE = 4;
            constexpr auto IMG_QUERY_iRENDER = 5;
            constexpr auto IMG_QUERY_iKX = 6;
            constexpr auto IMG_QUERY_iNX = 7;
            constexpr auto IMG_QUERY_iNY = 8;
            constexpr auto IMG_QUERY_iNV = 9;
            constexpr auto IMG_QUERY_iNE = 10;
            constexpr auto IMG_QUERY_rXO = 11;
            constexpr auto IMG_QUERY_rYO = 12;
            constexpr auto IMG_QUERY_rDX = 13;
            constexpr auto IMG_QUERY_rDY = 14;
            constexpr auto IMG_QUERY_rROT = 15;
            constexpr auto IMG_QUERY_rBASE = 16;
            constexpr auto IMG_QUERY_rMULT = 17;
            constexpr auto IMG_QUERY_rCOMPRESSION_RATIO = 18;
// IMG_RELOCATE
            constexpr auto IMG_RELOCATE_FIT = 0;
            constexpr auto IMG_RELOCATE_ASPECT = 1;
// IMU_BOOL_OLAP
            constexpr auto IMU_BOOL_OLAP_AVE = 0;
            constexpr auto IMU_BOOL_OLAP_1 = 1;
            constexpr auto IMU_BOOL_OLAP_2 = 2;
            constexpr auto IMU_BOOL_OLAP_MINUS = 4;
// IMU_BOOL_OPT
            constexpr auto IMU_BOOL_OPT_AND = 0;
            constexpr auto IMU_BOOL_OPT_OR = 1;
            constexpr auto IMU_BOOL_OPT_XOR = 2;
// IMU_BOOL_SIZING
            constexpr auto IMU_BOOL_SIZING_MIN = 0;
            constexpr auto IMU_BOOL_SIZING_0 = 1;
            constexpr auto IMU_BOOL_SIZING_1 = 2;
            constexpr auto IMU_BOOL_SIZING_MAX = 3;
// IMU_DOUBLE_CRC_BITS
            constexpr auto IMU_DOUBLE_CRC_BITS_EXACT = 0;
            constexpr auto IMU_DOUBLE_CRC_BITS_DEFAULT = 10;
            constexpr auto IMU_DOUBLE_CRC_BITS_MAX = 51;
// IMU_EXPAND_SHAPE
            constexpr auto IMU_EXPAND_SHAPE_RECTANGLE = 0;
            constexpr auto IMU_EXPAND_SHAPE_SQUARE = 1;
// IMU_FILL_ROLLOPT
            constexpr auto IMU_FILL_ROLLOPT_LINEAR = 1;
            constexpr auto IMU_FILL_ROLLOPT_SQUARE = 2;
// IMU_FILT_DUMMY
            constexpr auto IMU_FILT_DUMMY_NO = 0;
            constexpr auto IMU_FILT_DUMMY_YES = 1;
// IMU_FILT_FILE
            constexpr auto IMU_FILT_FILE_NO = 0;
            constexpr auto IMU_FILT_FILE_YES = 1;
// IMU_FILT_HZDRV
            constexpr auto IMU_FILT_HZDRV_NO = 0;
            constexpr auto IMU_FILT_HZDRV_X = 1;
            constexpr auto IMU_FILT_HZDRV_Y = 2;
// IMU_FLOAT_CRC_BITS
            constexpr auto IMU_FLOAT_CRC_BITS_EXACT = 0;
            constexpr auto IMU_FLOAT_CRC_BITS_DEFAULT = 7;
            constexpr auto IMU_FLOAT_CRC_BITS_MAX = 22;
// IMU_MASK
            constexpr auto IMU_MASK_INSIDE = 0;
            constexpr auto IMU_MASK_OUTSIDE = 1;
// IMU_STAT_FORCED
            constexpr auto IMU_STAT_FORCED_NO = 0;
            constexpr auto IMU_STAT_FORCED_YES = 1;
// IMU_TRANS
            constexpr auto IMU_TRANS_DEFAULT = 0;
            constexpr auto IMU_TRANS_Y = 1;
            constexpr auto IMU_TRANS_X = -1;
// IMU_TREND
            constexpr auto IMU_TREND_ALL = 0;
            constexpr auto IMU_TREND_EDGE = 1;
// IMU_WIND_COORD
            constexpr auto IMU_WIND_GRID = 0;
            constexpr auto IMU_WIND_GROUND = 1;
// IMU_WIND_DUMMIES
            constexpr auto IMU_WIND_DUMMY = 0;
            constexpr auto IMU_WIND_CLIP = 1;
// IMU_XYZ_INDEX
            constexpr auto IMU_XYZ_INDEX_NO = 0;
            constexpr auto IMU_XYZ_INDEX_YES = 1;
// IMU_XYZ_LABEL
            constexpr auto IMU_XYZ_LABEL_NO = 1;
            constexpr auto IMU_XYZ_LABEL_YES = 0;
// IP_ARRAY
            constexpr auto IP_ARRAY_DPDP = 0;
            constexpr auto IP_ARRAY_PLDP = 1;
            constexpr auto IP_ARRAY_PLPL = 2;
            constexpr auto IP_ARRAY_GRAD = 3;
            constexpr auto IP_ARRAY_WENNER = 5;
            constexpr auto IP_ARRAY_SCHLUMBERGER = 6;
            constexpr auto IP_ARRAY_UNKNOWN = 7;
            constexpr auto IP_ARRAY_3D = 9;
            constexpr auto IP_ARRAY_3D_PLDP = 10;
            constexpr auto IP_ARRAY_3D_PLPL = 11;
// IP_CHANNELS
            constexpr auto IP_CHANNELS_DISPLAYED = 0;
            constexpr auto IP_CHANNELS_SELECTED = 1;
            constexpr auto IP_CHANNELS_ALL = 2;
// IP_DOMAIN
            constexpr auto IP_DOMAIN_NONE = -1;
            constexpr auto IP_DOMAIN_TIME = 0;
            constexpr auto IP_DOMAIN_FREQUENCY = 1;
            constexpr auto IP_DOMAIN_BOTH = 2;
// IP_DUPLICATE
            constexpr auto IP_DUPLICATE_APPEND = 0;
            constexpr auto IP_DUPLICATE_OVERWRITE = 1;
// IP_FILTER
            constexpr auto IP_FILTER_PANTLEG = 1;
            constexpr auto IP_FILTER_PANTLEGP = 2;
            constexpr auto IP_FILTER_PYRIAMID = 3;
            constexpr auto IP_FILTER_PYRIAMIDP = 4;
// IP_I2XIMPMODE
            constexpr auto IP_I2XIMPMODE_REPLACE = 0;
            constexpr auto IP_I2XIMPMODE_MERGE = 1;
// IP_I2XINV
            constexpr auto IP_I2XINV_IMAGE = 0;
            constexpr auto IP_I2XINV_ZONGE = 1;
// IP_LINES
            constexpr auto IP_LINES_DISPLAYED = 0;
            constexpr auto IP_LINES_SELECTED = 1;
            constexpr auto IP_LINES_ALL = 2;
// IP_PLOT
            constexpr auto IP_PLOT_PSEUDOSECTION = 0;
            constexpr auto IP_PLOT_STACKEDSECTION = 1;
// IP_QCTYPE
            constexpr auto IP_QCTYPE_RESISTIVITY = 0;
            constexpr auto IP_QCTYPE_IP = 1;
// IP_STACK_TYPE
            constexpr auto IP_STACK_TYPE_MAP = 0;
            constexpr auto IP_STACK_TYPE_EQUAL = 1;
            constexpr auto IP_STACK_TYPE_GEOGRAPHIC = 2;
// IP_STNSCALE
            constexpr auto IP_STNSCALE_NONE = 0;
            constexpr auto IP_STNSCALE_ASPACE = 1;
            constexpr auto IP_STNSCALE_VALUE = 2;
            constexpr auto IP_STNSCALE_FILE = 3;
// IP_SYS
            constexpr auto IP_SYS_IPDATA = 0;
            constexpr auto IP_SYS_IP2 = 1;
            constexpr auto IP_SYS_IP6 = 2;
            constexpr auto IP_SYS_IP10 = 3;
            constexpr auto IP_SYS_SYSCALR2 = 4;
            constexpr auto IP_SYS_IPR11 = 5;
            constexpr auto IP_SYS_IPR12 = 6;
            constexpr auto IP_SYS_PHOENIX = 7;
            constexpr auto IP_SYS_PHOENIX_V2 = 8;
            constexpr auto IP_SYS_ELREC_PRO = 9;
            constexpr auto IP_SYS_PROSYS_II = 10;
// IP_UBC_CONTROL
            constexpr auto IP_UBC_CONTROL_NONE = -1;
            constexpr auto IP_UBC_CONTROL_DEFAULT = 0;
            constexpr auto IP_UBC_CONTROL_FILE = 1;
            constexpr auto IP_UBC_CONTROL_VALUE = 2;
            constexpr auto IP_UBC_CONTROL_LENGTH = 3;
// IP_PLDP_CONV
            constexpr auto IP_PLDP_CONV_CLOSE_RX = 0;
            constexpr auto IP_PLDP_CONV_MID_RX = 1;
            constexpr auto IP_PLDP_CONV_DISTANT_RX = 2;
// IPJ_3D_FLAG
            constexpr auto IPJ_3D_FLAG_NONE = 0;
            constexpr auto IPJ_3D_FLAG_INVERTANGLES = 1;
            constexpr auto IPJ_3D_FLAG_INVERTZ = 2;
            constexpr auto IPJ_3D_FLAG_ORDER_ROTATION = 4;
// IPJ_3D_ROTATE
            constexpr auto IPJ_3D_ROTATE_DEFAULT = 0;
            constexpr auto IPJ_3D_ROTATE_XYZ = 1;
            constexpr auto IPJ_3D_ROTATE_XZY = 2;
            constexpr auto IPJ_3D_ROTATE_YXZ = 3;
            constexpr auto IPJ_3D_ROTATE_YZX = 4;
            constexpr auto IPJ_3D_ROTATE_ZXY = 5;
            constexpr auto IPJ_3D_ROTATE_ZYX = 6;
// IPJ_CSP
            constexpr auto IPJ_CSP_SCALE = 0;
            constexpr auto IPJ_CSP_FALSEEAST = 1;
            constexpr auto IPJ_CSP_FALSENORTH = 2;
            constexpr auto IPJ_CSP_LATORIGIN = 3;
            constexpr auto IPJ_CSP_LONORIGIN = 4;
            constexpr auto IPJ_CSP_PARALLEL_1 = 5;
            constexpr auto IPJ_CSP_PARALLEL_2 = 6;
            constexpr auto IPJ_CSP_AZIMUTH = 7;
            constexpr auto IPJ_CSP_ANGLE = 8;
            constexpr auto IPJ_CSP_POINTLAT_1 = 9;
            constexpr auto IPJ_CSP_POINTLON_1 = 10;
            constexpr auto IPJ_CSP_POINTLAT_2 = 11;
            constexpr auto IPJ_CSP_POINTLON_2 = 12;
// IPJ_NAME
            constexpr auto IPJ_NAME_PCS = 0;
            constexpr auto IPJ_NAME_PROJECTION = 1;
            constexpr auto IPJ_NAME_METHOD = 2;
            constexpr auto IPJ_NAME_DATUM = 3;
            constexpr auto IPJ_NAME_ELLIPSOID = 4;
            constexpr auto IPJ_NAME_LDATUM = 5;
            constexpr auto IPJ_NAME_UNIT_ABBR = 6;
            constexpr auto IPJ_NAME_UNIT_FULL = 7;
            constexpr auto IPJ_NAME_TYPE = 8;
            constexpr auto IPJ_NAME_LLDATUM = 9;
            constexpr auto IPJ_NAME_METHOD_PARMS = 10;
            constexpr auto IPJ_NAME_METHOD_LABEL = 11;
            constexpr auto IPJ_NAME_DATUM_PARMS = 12;
            constexpr auto IPJ_NAME_LDATUM_PARMS = 13;
            constexpr auto IPJ_NAME_GEOID = 14;
            constexpr auto IPJ_NAME_LDATUMDESCRIPTION = 15;
            constexpr auto IPJ_NAME_METHOD_PARMS_NATIVE = 16;
            constexpr auto IPJ_NAME_ORIENTATION_PARMS = 17;
// IPJ_ORIENT
            constexpr auto IPJ_ORIENT_DEFAULT = 0;
            constexpr auto IPJ_ORIENT_PLAN = 1;
            constexpr auto IPJ_ORIENT_SECTION = 2;
            constexpr auto IPJ_ORIENT_SECTION_NORMAL = 5;
            constexpr auto IPJ_ORIENT_DEPTH_SECTION = 3;
            constexpr auto IPJ_ORIENT_3D = 4;
            constexpr auto IPJ_ORIENT_3D_MATRIX = 7;
            constexpr auto IPJ_ORIENT_SECTION_CROOKED = 6;
// IPJ_PARM_LST
            constexpr auto IPJ_PARM_LST_COORDINATESYSTEM = 0;
            constexpr auto IPJ_PARM_LST_DATUM = 1;
            constexpr auto IPJ_PARM_LST_PROJECTION = 2;
            constexpr auto IPJ_PARM_LST_UNITS = 3;
            constexpr auto IPJ_PARM_LST_LOCALDATUMDESCRIPTION = 4;
            constexpr auto IPJ_PARM_LST_LOCALDATUMNAME = 5;
            constexpr auto IPJ_PARM_LST_UNITSDESCRIPTION = 6;
// IPJ_TYPE
            constexpr auto IPJ_TYPE_PRJ = 0;
            constexpr auto IPJ_TYPE_PCS = 1;
            constexpr auto IPJ_TYPE_GCS = 2;
            constexpr auto IPJ_TYPE_ANY = 3;
            constexpr auto IPJ_TYPE_NONE = 4;
            constexpr auto IPJ_TYPE_WRP = 5;
            constexpr auto IPJ_TYPE_TEST = 6;
// IPJ_UNIT
            constexpr auto IPJ_UNIT_ABBREVIATION = 0;
            constexpr auto IPJ_UNIT_FULLNAME = 1;
// IPJ_WARP
            constexpr auto IPJ_WARP_MATRIX = -1;
            constexpr auto IPJ_WARP_NONE = 0;
            constexpr auto IPJ_WARP_TRANS1 = 1;
            constexpr auto IPJ_WARP_TRANS2 = 2;
            constexpr auto IPJ_WARP_TRANS3 = 3;
            constexpr auto IPJ_WARP_QUAD = 4;
            constexpr auto IPJ_WARP_MULTIPOINT = 5;
            constexpr auto IPJ_WARP_LOG = 6;
            constexpr auto IPJ_WARP_MULTIPOINT_Y = 7;
// ITR_COLOR_MODEL
            constexpr auto ITR_COLOR_MODEL_HSV = 1;
            constexpr auto ITR_COLOR_MODEL_RGB = 2;
            constexpr auto ITR_COLOR_MODEL_CMY = 3;
// ITR_POWER
            constexpr auto ITR_POWER_10 = 0;
            constexpr auto ITR_POWER_EXP = 1;
// ITR_ZONE
            constexpr auto ITR_ZONE_DEFAULT = 0;
            constexpr auto ITR_ZONE_LINEAR = 1;
            constexpr auto ITR_ZONE_NORMAL = 2;
            constexpr auto ITR_ZONE_EQUALAREA = 3;
            constexpr auto ITR_ZONE_SHADE = 4;
            constexpr auto ITR_ZONE_LOGLINEAR = 5;
// ITR_ZONE_MODEL
            constexpr auto ITR_ZONE_MODEL_NOZONE = -1;
            constexpr auto ITR_ZONE_MODEL_NONE = 0;
            constexpr auto ITR_ZONE_MODEL_LINEAR = 1;
            constexpr auto ITR_ZONE_MODEL_NORMAL = 2;
            constexpr auto ITR_ZONE_MODEL_EQUAL = 3;
            constexpr auto ITR_MODEL_LOGLIN = 4;
            constexpr auto ITR_ZONE_MODEL_LOGLIN = 4;
// KML_ALT
            constexpr auto KML_ALT_CLAMPTOGROUND = 0;
            constexpr auto KML_ALT_RELATIVETOGROUND = 1;
            constexpr auto KML_ALT_ABSOLUTE = 2;
// LAYOUT_CONSTR
            constexpr auto LAYOUT_CONSTR_LEFT = 0;
            constexpr auto LAYOUT_CONSTR_RIGHT = 1;
            constexpr auto LAYOUT_CONSTR_TOP = 2;
            constexpr auto LAYOUT_CONSTR_BOTTOM = 3;
            constexpr auto LAYOUT_CONSTR_WIDTH = 4;
            constexpr auto LAYOUT_CONSTR_HEIGHT = 5;
            constexpr auto LAYOUT_CONSTR_HCENTER = 6;
            constexpr auto LAYOUT_CONSTR_VCENTER = 7;
            constexpr auto LAYOUT_CONSTR_MOVEL = 8;
            constexpr auto LAYOUT_CONSTR_MOVER = 9;
            constexpr auto LAYOUT_CONSTR_MOVET = 10;
            constexpr auto LAYOUT_CONSTR_MOVEB = 11;
// LST_ITEM
            constexpr auto LST_ITEM_NAME = 0;
            constexpr auto LST_ITEM_VALUE = 1;
// LTB_CASE
            constexpr auto LTB_CASE_INSENSITIVE = 0;
            constexpr auto LTB_CASE_SENSITIVE = 1;
// LTB_CONLST
            constexpr auto LTB_CONLST_EXACT = 0;
            constexpr auto LTB_CONLST_ANY = 1;
// LTB_DELIM
            constexpr auto LTB_DELIM_SPACE = 0;
            constexpr auto LTB_DELIM_COMMA = 1;
            constexpr auto LTB_DELIM_SPACECOMMA = 2;
// LTB_TYPE
            constexpr auto LTB_TYPE_HEADER = 0;
            constexpr auto LTB_TYPE_NOHEADER = 1;
// DUPMAP
            constexpr auto DUPMAP_BLANK = 0;
            constexpr auto DUPMAP_COPY = 1;
            constexpr auto DUPMAP_COPY_PRE62 = 2;
// MAP_EXPORT_BITS
            constexpr auto MAP_EXPORT_BITS_32 = 32;
            constexpr auto MAP_EXPORT_BITS_24 = 24;
            constexpr auto MAP_EXPORT_BITS_GREY8 = 9;
            constexpr auto MAP_EXPORT_BITS_8 = 8;
            constexpr auto MAP_EXPORT_BITS_GREY4 = 5;
            constexpr auto MAP_EXPORT_BITS_4 = 4;
            constexpr auto MAP_EXPORT_BITS_GREY1 = 1;
            constexpr auto MAP_EXPORT_BITS_DEFAULT = 0;
// MAP_EXPORT_FORMAT
            constexpr auto MAP_EXPORT_FORMAT_PLT = gx_string_literal("PLT");
            constexpr auto MAP_EXPORT_FORMAT_SHP = gx_string_literal("SHP");
            constexpr auto MAP_EXPORT_FORMAT_DXF12 = gx_string_literal("DXF12");
            constexpr auto MAP_EXPORT_FORMAT_DXF13 = gx_string_literal("DXF13");
            constexpr auto MAP_EXPORT_FORMAT_GTIFF = gx_string_literal("GTIFF");
            constexpr auto MAP_EXPORT_FORMAT_CGTIFF = gx_string_literal("CGTIFF");
            constexpr auto MAP_EXPORT_FORMAT_MTIFF = gx_string_literal("MTIFF");
            constexpr auto MAP_EXPORT_FORMAT_ATIFF = gx_string_literal("ATIFF");
            constexpr auto MAP_EXPORT_FORMAT_GEO = gx_string_literal("GEO");
            constexpr auto MAP_EXPORT_FORMAT_ERM = gx_string_literal("ERM");
            constexpr auto MAP_EXPORT_FORMAT_KMZ = gx_string_literal("KMZ");
// MAP_EXPORT_METHOD
            constexpr auto MAP_EXPORT_METHOD_STANDARD = 0;
            constexpr auto MAP_EXPORT_METHOD_DIFFUSE = 1;
            constexpr auto MAP_EXPORT_METHOD_NONE = 2;
// MAP_EXPORT_RASTER_FORMAT
            constexpr auto MAP_EXPORT_RASTER_FORMAT_EMF = gx_string_literal("EMF");
            constexpr auto MAP_EXPORT_RASTER_FORMAT_BMP = gx_string_literal("BMP");
            constexpr auto MAP_EXPORT_RASTER_FORMAT_JPEGL = gx_string_literal("JPEGL");
            constexpr auto MAP_EXPORT_RASTER_FORMAT_JPEG = gx_string_literal("JPEG");
            constexpr auto MAP_EXPORT_RASTER_FORMAT_JPEGH = gx_string_literal("JPEGH");
            constexpr auto MAP_EXPORT_RASTER_FORMAT_GIF = gx_string_literal("GIF");
            constexpr auto MAP_EXPORT_RASTER_FORMAT_PCX = gx_string_literal("PCX");
            constexpr auto MAP_EXPORT_RASTER_FORMAT_PNG = gx_string_literal("PNG");
            constexpr auto MAP_EXPORT_RASTER_FORMAT_EPS = gx_string_literal("EPS");
            constexpr auto MAP_EXPORT_RASTER_FORMAT_TIFF = gx_string_literal("TIFF");
// MAP_LIST_MODE
            constexpr auto MAP_LIST_MODE_ALL = 0;
            constexpr auto MAP_LIST_MODE_3D = 1;
            constexpr auto MAP_LIST_MODE_NOT3D = 2;
// MAP_OPEN
            constexpr auto MAP_WRITENEW = 1;
            constexpr auto MAP_WRITEOLD = 2;
// MAPTEMPLATE_OPEN
            constexpr auto MAPTEMPLATE_WRITENEW = 0;
            constexpr auto MAPTEMPLATE_EXIST = 1;
// ATTRIBUTE_DATA_TYPE
            constexpr auto ATTRIBUTE_DOUBLE = 0;
            constexpr auto ATTRIBUTE_THEMATIC = 1;
            constexpr auto ATTRIBUTE_VECTOR = 2;
// ATTRIBUTE_TYPE
            constexpr auto ATTRIBUTE_SINGLE = 0;
            constexpr auto ATTRIBUTE_SURFACE_SIDES = 1;
            constexpr auto ATTRIBUTE_VERTICES = 2;
            constexpr auto ATTRIBUTE_FACES = 3;
// SURFACE_CLIP_MODE
            constexpr auto SURFACE_CLIP_ABOVE = 0;
            constexpr auto SURFACE_CLIP_BELOW = 1;
            constexpr auto SURFACE_CLIP_BOTH = 2;
// SURFACE_CLIP_STATUS
            constexpr auto SURFACE_CLIP_SUCCESS = 0;
            constexpr auto SURFACE_CLIP_SUCCESS_EMPTY = 1;
            constexpr auto SURFACE_CLIP_FAIL = 2;
// SURFACE_PROJECTION_METHOD
            constexpr auto SURFACE_PROJECTION_MAXIMUM = 0;
            constexpr auto SURFACE_PROJECTION_MINIMUM = 1;
            constexpr auto SURFACE_PROJECTION_AVERAGE = 2;
// SURFACE_TRANSFORMATION_METHOD
            constexpr auto SURFACE_TRANSFORMATION_METHOD_SHIFT = 0;
            constexpr auto SURFACE_TRANSFORMATION_METHOD_SCALE = 1;
// H_META_INVALID_TOKEN
            constexpr auto H_META_INVALID_TOKEN = -1;
// META_CORE_ATTRIB
            constexpr auto META_CORE_ATTRIB_Class_Description = -300;
            constexpr auto META_CORE_ATTRIB_Class_Application = -301;
            constexpr auto META_CORE_ATTRIB_Class_ReferenceURL = -302;
            constexpr auto META_CORE_ATTRIB_Class_Type = -303;
            constexpr auto META_CORE_ATTRIB_Type_Description = -304;
            constexpr auto META_CORE_ATTRIB_Type_ReferenceURL = -305;
            constexpr auto META_CORE_ATTRIB_Type_FixedSize = -306;
            constexpr auto META_CORE_ATTRIB_Type_ByteOrder = -307;
            constexpr auto META_CORE_ATTRIB_Type_MinValue = -308;
            constexpr auto META_CORE_ATTRIB_Type_MaxValue = -309;
            constexpr auto META_CORE_ATTRIB_Type_MaxSize = -310;
            constexpr auto META_CORE_ATTRIB_Type_ObjectClass = -311;
            constexpr auto META_CORE_ATTRIB_Type_hCreatS_Func = -312;
            constexpr auto META_CORE_ATTRIB_Type_sSerial_Func = -313;
            constexpr auto META_CORE_ATTRIB_Type_Enum_Value = -314;
            constexpr auto META_CORE_ATTRIB_Attrib_Visible = -315;
            constexpr auto META_CORE_ATTRIB_Attrib_Editable = -316;
            constexpr auto META_CORE_ATTRIB_Attrib_FlatName = -317;
// META_CORE_CLASS
            constexpr auto META_CORE_CLASS_Base = -100;
            constexpr auto META_CORE_CLASS_Predefined = -101;
            constexpr auto META_CORE_CLASS_Attributes = -102;
            constexpr auto META_CORE_CLASS_ClassAttributes = -103;
            constexpr auto META_CORE_CLASS_TypeAttributes = -104;
            constexpr auto META_CORE_CLASS_ObjectAttributes = -105;
            constexpr auto META_CORE_CLASS_EnumAttributes = -106;
            constexpr auto META_CORE_CLASS_AttributeAttributes = -107;
            constexpr auto META_CORE_CLASS_ItemAttributes = -108;
            constexpr auto META_CORE_CLASS_Types = -109;
            constexpr auto META_CORE_CLASS_Enums = -110;
            constexpr auto META_CORE_CLASS_Enum_Bool = -111;
            constexpr auto META_CORE_CLASS_Enum_ClassType = -112;
// META_CORE_TYPE
            constexpr auto META_CORE_TYPE_Bytes = -200;
            constexpr auto META_CORE_TYPE_Bool = -201;
            constexpr auto META_CORE_TYPE_I1 = -202;
            constexpr auto META_CORE_TYPE_U1 = -203;
            constexpr auto META_CORE_TYPE_I2 = -204;
            constexpr auto META_CORE_TYPE_U2 = -205;
            constexpr auto META_CORE_TYPE_I4 = -206;
            constexpr auto META_CORE_TYPE_U4 = -207;
            constexpr auto META_CORE_TYPE_I8 = -208;
            constexpr auto META_CORE_TYPE_U8 = -209;
            constexpr auto META_CORE_TYPE_R4 = -210;
            constexpr auto META_CORE_TYPE_R8 = -211;
            constexpr auto META_CORE_TYPE_String = -212;
            constexpr auto META_CORE_TYPE_Object = -213;
            constexpr auto META_CORE_TYPE_Enum = -214;
            constexpr auto META_CORE_TYPE_ClassType = -215;
// DIRECTION3D
            constexpr auto DIRECTION3D_XYZ = 0;
            constexpr auto DIRECTION3D_YXZ = 1;
            constexpr auto DIRECTION3D_XZY = 2;
            constexpr auto DIRECTION3D_YZX = 3;
            constexpr auto DIRECTION3D_ZXY = 4;
            constexpr auto DIRECTION3D_ZYX = 5;
// GOCAD_ORIENTATION
            constexpr auto GOCAD_ORIENTATIONS_NORMAL = 0;
            constexpr auto GOCAD_ORIENTATIONS_INVERTED = 1;
            constexpr auto GOCAD_ORIENTATIONS_NORMAL_ZFIRST = 2;
            constexpr auto GOCAD_ORIENTATIONS_INVERTED_ZFIRST = 3;
// VECTOR_IMPORT
            constexpr auto VECTOR_IMPORT_XYZ = 0;
            constexpr auto VECTOR_IMPORT_UVW = 1;
            constexpr auto VECTOR_IMPORT_AID = 2;
// FILTER3D
            constexpr auto FILTER3D_FILE = 0;
            constexpr auto FILTER3D_SMOOTHING = 1;
            constexpr auto FILTER3D_LAPLACE = 2;
            constexpr auto FILTER3D_X_GRADIENT = 3;
            constexpr auto FILTER3D_Y_GRADIENT = 4;
            constexpr auto FILTER3D_Z_GRADIENT = 5;
            constexpr auto FILTER3D_TOTAL_GRADIENT = 6;
// MULTIGRID3D_DIRECTGRID_METHOD
            constexpr auto MULTIGRID3D_DIRECTGRID_MINIMUM = 0;
            constexpr auto MULTIGRID3D_DIRECTGRID_MAXIMUM = 1;
            constexpr auto MULTIGRID3D_DIRECTGRID_MEAN = 2;
            constexpr auto MULTIGRID3D_DIRECTGRID_ITEMS = 3;
            constexpr auto MULTIGRID3D_DIRECTGRID_DUMMYITEMS = 4;
// RBFKERNEL
            constexpr auto RBFKERNEL_DISTANCE = 0;
            constexpr auto RBFKERNEL_MULTIQUADRATIC = 1;
// MVG_DRAW
            constexpr auto MVG_DRAW_POLYLINE = 0;
            constexpr auto MVG_DRAW_POLYGON = 1;
// MVG_GRID
            constexpr auto MVG_GRID_DOT = 0;
            constexpr auto MVG_GRID_LINE = 1;
            constexpr auto MVG_GRID_CROSS = 2;
// MVG_LABEL_BOUND
            constexpr auto MVG_LABEL_BOUND_NO = 0;
            constexpr auto MVG_LABEL_BOUND_YES = 1;
// MVG_LABEL_JUST
            constexpr auto MVG_LABEL_JUST_TOP = 0;
            constexpr auto MVG_LABEL_JUST_BOTTOM = 1;
            constexpr auto MVG_LABEL_JUST_LEFT = 2;
            constexpr auto MVG_LABEL_JUST_RIGHT = 3;
// MVG_LABEL_ORIENT
            constexpr auto MVG_LABEL_ORIENT_HORIZONTAL = 0;
            constexpr auto MVG_LABEL_ORIENT_TOP_RIGHT = 1;
            constexpr auto MVG_LABEL_ORIENT_TOP_LEFT = 2;
// MVG_SCALE
            constexpr auto MVG_SCALE_LINEAR = 0;
            constexpr auto MVG_SCALE_LOG = 1;
            constexpr auto MVG_SCALE_LOGLINEAR = 2;
// MVG_WRAP
            constexpr auto MVG_WRAP_NO = 0;
            constexpr auto MVG_WRAP_YES = 1;
// MAKER
            constexpr auto MAKER_GX = 0;
// MVIEW_CLIP
            constexpr auto CLIP_ON = 1;
            constexpr auto CLIP_OFF = 0;
// MVIEW_COLOR
            constexpr auto C_BLACK = 33554432;
            constexpr auto C_RED = 33554687;
            constexpr auto C_GREEN = 33619712;
            constexpr auto C_BLUE = 50266112;
            constexpr auto C_CYAN = 50331903;
            constexpr auto C_MAGENTA = 50396928;
            constexpr auto C_YELLOW = 67043328;
            constexpr auto C_GREY = 41975936;
            constexpr auto C_LT_RED = 54542336;
            constexpr auto C_LT_GREEN = 54526016;
            constexpr auto C_LT_BLUE = 50348096;
            constexpr auto C_LT_CYAN = 50331712;
            constexpr auto C_LT_MAGENTA = 50348032;
            constexpr auto C_LT_YELLOW = 54525952;
            constexpr auto C_LT_GREY = 54542400;
            constexpr auto C_GREY10 = 51910680;
            constexpr auto C_GREY25 = 54542400;
            constexpr auto C_GREY50 = 41975936;
            constexpr auto C_WHITE = 50331648;
            constexpr auto C_TRANSPARENT = 0;
// MVIEW_CYLINDER3D
            constexpr auto MVIEW_CYLINDER3D_OPEN = 0;
            constexpr auto MVIEW_CYLINDER3D_CLOSESTART = 1;
            constexpr auto MVIEW_CYLINDER3D_CLOSEEND = 2;
            constexpr auto MVIEW_CYLINDER3D_CLOSEALL = 3;
// MVIEW_DRAW
            constexpr auto MVIEW_DRAW_POLYLINE = 0;
            constexpr auto MVIEW_DRAW_POLYGON = 1;
// MVIEW_DRAWOBJ3D_ENTITY
            constexpr auto MVIEW_DRAWOBJ3D_ENTITY_POINTS = 0;
            constexpr auto MVIEW_DRAWOBJ3D_ENTITY_LINES = 1;
            constexpr auto MVIEW_DRAWOBJ3D_ENTITY_LINE_STRIPS = 2;
            constexpr auto MVIEW_DRAWOBJ3D_ENTITY_LINE_LOOPS = 3;
            constexpr auto MVIEW_DRAWOBJ3D_ENTITY_TRIANGLES = 4;
            constexpr auto MVIEW_DRAWOBJ3D_ENTITY_TRIANGLE_STRIPS = 5;
            constexpr auto MVIEW_DRAWOBJ3D_ENTITY_TRIANGLE_FANS = 6;
            constexpr auto MVIEW_DRAWOBJ3D_ENTITY_QUADS = 7;
            constexpr auto MVIEW_DRAWOBJ3D_ENTITY_QUADS_STRIPS = 8;
            constexpr auto MVIEW_DRAWOBJ3D_ENTITY_POLYGONS = 9;
// MVIEW_DRAWOBJ3D_MODE
            constexpr auto MVIEW_DRAWOBJ3D_MODE_FLAT = 0;
            constexpr auto MVIEW_DRAWOBJ3D_MODE_SMOOTH = 1;
// MVIEW_EXTENT
            constexpr auto MVIEW_EXTENT_ALL = 0;
            constexpr auto MVIEW_EXTENT_CLIP = 1;
            constexpr auto MVIEW_EXTENT_MAP = 2;
            constexpr auto MVIEW_EXTENT_VISIBLE = 3;
// MVIEW_FIT
            constexpr auto MVIEW_FIT_MAP = 0;
            constexpr auto MVIEW_FIT_VIEW = 1;
// MVIEW_FONT_WEIGHT
            constexpr auto MVIEW_FONT_WEIGHT_NORMAL = 0;
            constexpr auto MVIEW_FONT_WEIGHT_ULTRALIGHT = 1;
            constexpr auto MVIEW_FONT_WEIGHT_LIGHT = 2;
            constexpr auto MVIEW_FONT_WEIGHT_MEDIUM = 3;
            constexpr auto MVIEW_FONT_WEIGHT_BOLD = 4;
            constexpr auto MVIEW_FONT_WEIGHT_XBOLD = 5;
            constexpr auto MVIEW_FONT_WEIGHT_XXBOLD = 6;
// MVIEW_GRID
            constexpr auto MVIEW_GRID_DOT = 0;
            constexpr auto MVIEW_GRID_LINE = 1;
            constexpr auto MVIEW_GRID_CROSS = 2;
// MVIEW_GROUP
            constexpr auto MVIEW_GROUP_NEW = 1;
            constexpr auto MVIEW_GROUP_APPEND = 0;
// MVIEW_GROUP_LIST
            constexpr auto MVIEW_GROUP_LIST_ALL = 0;
            constexpr auto MVIEW_GROUP_LIST_MARKED = 1;
            constexpr auto MVIEW_GROUP_LIST_VISIBLE = 2;
// MVIEW_HIDE
            constexpr auto HIDE_ON = 1;
            constexpr auto HIDE_OFF = 0;
// MVIEW_IS
            constexpr auto MVIEW_IS_AGG = 0;
            constexpr auto MVIEW_IS_MOVABLE = 3;
            constexpr auto MVIEW_IS_CSYMB = 4;
            constexpr auto MVIEW_IS_LINKED = 5;
            constexpr auto MVIEW_IS_MADE = 6;
            constexpr auto MVIEW_IS_HIDDEN = 7;
            constexpr auto MVIEW_IS_CLIPPED = 8;
            constexpr auto MVIEW_IS_META = 9;
            constexpr auto MVIEW_IS_VOXD = 10;
            constexpr auto MVIEW_IS_SHADOW_2D_INTERPRETATION = 11;
            constexpr auto MVIEW_IS_VECTOR3D = 12;
            constexpr auto MVIEW_IS_GENSURF = 13;
            constexpr auto MVIEW_IS_VOXSURF = 14;
// MVIEW_LABEL_BOUND
            constexpr auto MVIEW_LABEL_BOUND_NO = 0;
            constexpr auto MVIEW_LABEL_BOUND_YES = 1;
// MVIEW_LABEL_JUST
            constexpr auto MVIEW_LABEL_JUST_TOP = 0;
            constexpr auto MVIEW_LABEL_JUST_BOTTOM = 1;
            constexpr auto MVIEW_LABEL_JUST_LEFT = 2;
            constexpr auto MVIEW_LABEL_JUST_RIGHT = 3;
// MVIEW_LABEL_ORIENT
            constexpr auto MVIEW_LABEL_ORIENT_HORIZONTAL = 0;
            constexpr auto MVIEW_LABEL_ORIENT_TOP_RIGHT = 1;
            constexpr auto MVIEW_LABEL_ORIENT_TOP_LEFT = 2;
// MVIEW_NAME_LENGTH
            constexpr auto MVIEW_NAME_LENGTH = 1040;
// MVIEW_OPEN
            constexpr auto MVIEW_READ = 0;
            constexpr auto MVIEW_WRITENEW = 1;
            constexpr auto MVIEW_WRITEOLD = 2;
// MVIEW_PJ
            constexpr auto MVIEW_PJ_OFF = 0;
            constexpr auto MVIEW_PJ_LOCATION = 1;
            constexpr auto MVIEW_PJ_ALL = 2;
            constexpr auto MVIEW_PJ_ON = 3;
// MVIEW_RELOCATE
            constexpr auto MVIEW_RELOCATE_FIT = 0;
            constexpr auto MVIEW_RELOCATE_ASPECT = 1;
            constexpr auto MVIEW_RELOCATE_ASPECT_CENTER = 2;
// MVIEW_SMOOTH
            constexpr auto MVIEW_SMOOTH_NEAREST = 0;
            constexpr auto MVIEW_SMOOTH_CUBIC = 1;
            constexpr auto MVIEW_SMOOTH_AKIMA = 2;
// MVIEW_TILE
            constexpr auto MVIEW_TILE_RECTANGULAR = 0;
            constexpr auto MVIEW_TILE_DIAGONAL = 1;
            constexpr auto MVIEW_TILE_TRIANGULAR = 2;
            constexpr auto MVIEW_TILE_RANDOM = 3;
// MVIEW_UNIT
            constexpr auto MVIEW_UNIT_VIEW = 0;
            constexpr auto MVIEW_UNIT_PLOT = 1;
            constexpr auto MVIEW_UNIT_MM = 2;
            constexpr auto MVIEW_UNIT_VIEW_UNWARPED = 3;
// MVIEW_EXTENT_UNIT
            constexpr auto MVIEW_EXTENT_UNIT_VIEW = MVIEW_UNIT_VIEW;
            constexpr auto MVIEW_EXTENT_UNIT_PLOT = MVIEW_UNIT_PLOT;
            constexpr auto MVIEW_EXTENT_UNIT_MM = MVIEW_UNIT_MM;
            constexpr auto MVIEW_EXTENT_UNIT_VIEW_UNWARPED = MVIEW_UNIT_VIEW_UNWARPED;
// TEXT_REF
            constexpr auto TEXT_REF_BOTTOM_LEFT = 0;
            constexpr auto TEXT_REF_BOTTOM_CENTER = 1;
            constexpr auto TEXT_REF_BOTTOM_RIGHT = 2;
            constexpr auto TEXT_REF_MIDDLE_LEFT = 3;
            constexpr auto TEXT_REF_MIDDLE_CENTER = 4;
            constexpr auto TEXT_REF_MIDDLE_RIGHT = 5;
            constexpr auto TEXT_REF_TOP_LEFT = 6;
            constexpr auto TEXT_REF_TOP_CENTER = 7;
            constexpr auto TEXT_REF_TOP_RIGHT = 8;
// MVIEW_3D_RENDER
            constexpr auto MVIEW_3D_RENDER_BACKFACES = 1;
            constexpr auto MVIEW_3D_DONT_SCALE_GEOMETRY = 2;
// EMLAY_GEOMETRY
            constexpr auto EMLAY_V_COPLANAR = 0;
            constexpr auto EMLAY_H_COPLANAR = 1;
            constexpr auto EMLAY_V_COAXIAL = 2;
// ARROW_ALIGNMENT
            constexpr auto ARROW_ALIGNMENT_HORIZONTAL = 0;
            constexpr auto ARROW_ALIGNMENT_VERTICAL = 1;
// BARCHART_LABEL
            constexpr auto BARCHART_LABEL_NO = 0;
            constexpr auto BARCHART_LABEL_BELOWX = 1;
            constexpr auto BARCHART_LABEL_ABOVEX = 2;
            constexpr auto BARCHART_LABEL_PEND = 3;
            constexpr auto BARCHART_LABEL_NEND = 4;
            constexpr auto BARCHART_LABEL_ALTERNAT1 = 5;
            constexpr auto BARCHART_LABEL_ALTERNAT2 = 6;
// COLORBAR_LABEL
            constexpr auto COLORBAR_LABEL_HORIZONTAL = 0;
            constexpr auto COLORBAR_LABEL_VERTICAL = 1;
// COLORBAR_STYLE
            constexpr auto COLORBAR_STYLE_NONE = 0;
            constexpr auto COLORBAR_STYLE_MAXMIN = 1;
// MVU_ORIENTATION
            constexpr auto MVU_ORIENTATION_VERTICAL = 0;
            constexpr auto MVU_ORIENTATION_HORIZONTAL = 1;
// MVU_DIVISION_STYLE
            constexpr auto MVU_DIVISION_STYLE_NONE = 0;
            constexpr auto MVU_DIVISION_STYLE_LINES = 1;
            constexpr auto MVU_DIVISION_STYLE_TICS = 2;
// MVU_ARROW
            constexpr auto MVU_ARROW_SOLID = 1;
            constexpr auto MVU_ARROW_FIXED = 2;
// MVU_FLIGHT_COMPASS
            constexpr auto MVU_FLIGHT_COMPASS_NONE = -1;
            constexpr auto MVU_FLIGHT_COMPASS_EAST = 0;
            constexpr auto MVU_FLIGHT_COMPASS_NORTH = 1;
            constexpr auto MVU_FLIGHT_COMPASS_WEST = 2;
            constexpr auto MVU_FLIGHT_COMPASS_SOUTH = 3;
// MVU_FLIGHT_DUMMIES
            constexpr auto MVU_FLIGHT_DUMMIES_NOTINCLUDED = 0;
            constexpr auto MVU_FLIGHT_DUMMIES_INCLUDED = 1;
// MVU_FLIGHT_LOCATE
            constexpr auto MVU_FLIGHT_LOCATE_NONE = 0;
            constexpr auto MVU_FLIGHT_LOCATE_END = 1;
            constexpr auto MVU_FLIGHT_LOCATE_ABOVE = 2;
            constexpr auto MVU_FLIGHT_LOCATE_BELOW = 3;
            constexpr auto MVU_FLIGHT_DIRECTION = 8;
// MVU_VOX_SURFACE_METHOD
            constexpr auto MVU_VOX_SURFACE_METHOD_MARCHING_CUBES = 0;
// MVU_VOX_SURFACE_OPTION
            constexpr auto MVU_VOX_SURFACE_OPTION_OPEN = 0;
            constexpr auto MVU_VOX_SURFACE_OPTION_CLOSED = 1;
// MVU_TEXTBOX
            constexpr auto MVU_TEXTBOX_LEFT = 0;
            constexpr auto MVU_TEXTBOX_CENTER = 1;
            constexpr auto MVU_TEXTBOX_RIGHT = 2;
// MVU_VPOINT
            constexpr auto MVU_VPOINT_SHARP = 0;
            constexpr auto MVU_VPOINT_MEDIUM = 1;
            constexpr auto MVU_VPOINT_BLUNT = 2;
// MVU_VPOS
            constexpr auto MVU_VPOS_HEAD = 0;
            constexpr auto MVU_VPOS_MIDDLE = 1;
            constexpr auto MVU_VPOS_TAIL = 2;
// MVU_VSIZE
            constexpr auto MVU_VSIZE_NOHEAD = 0;
            constexpr auto MVU_VSIZE_SMALLHEAD = 1;
            constexpr auto MVU_VSIZE_MEDIUMHEAD = 2;
            constexpr auto MVU_VSIZE_LARGEHEAD = 3;
            constexpr auto MVU_VSIZE_NOTAIL = 4;
// MVU_VSTYLE
            constexpr auto MVU_VSTYLE_LINES = 0;
            constexpr auto MVU_VSTYLE_BARB = 1;
            constexpr auto MVU_VSTYLE_TRIANGLE = 2;
// PG_3D_DIR
            constexpr auto PG_3D_DIR_XYZ = 0;
            constexpr auto PG_3D_DIR_YXZ = 1;
            constexpr auto PG_3D_DIR_XZY = 2;
            constexpr auto PG_3D_DIR_YZX = 3;
            constexpr auto PG_3D_DIR_ZXY = 4;
            constexpr auto PG_3D_DIR_ZYX = 5;
// PG_BF_CONV
            constexpr auto PG_BF_CONV_NONE = 0;
            constexpr auto PG_BF_CONV_SWAP = 1;
// BLAKEY_TEST
            constexpr auto BLAKEY_TEST_ONESIDE = 1;
            constexpr auto BLAKEY_TEST_TWOSIDE = 2;
            constexpr auto BLAKEY_TEST_THREESIDE = 3;
            constexpr auto BLAKEY_TEST_FOURSIDE = 4;
// PGU_CORR
            constexpr auto PGU_CORR_SIMPLE = 0;
            constexpr auto PGU_CORR_PEARSON = 1;
// PGU_DIRECTGRID
            constexpr auto PGU_DIRECTGRID_MINIMUM = 0;
            constexpr auto PGU_DIRECTGRID_MAXIMUM = 1;
            constexpr auto PGU_DIRECTGRID_MEAN = 2;
            constexpr auto PGU_DIRECTGRID_ITEMS = 3;
// PGU_DIRECTION
            constexpr auto PGU_FORWARD = 0;
            constexpr auto PGU_BACKWARD = 1;
// PGU_TRANS
            constexpr auto PGU_TRANS_NONE = 0;
            constexpr auto PGU_TRANS_LOG = 1;
// PGU_INTERP_ORDER
            constexpr auto PGU_INTERP_ORDER_XYZ = 0;
            constexpr auto PGU_INTERP_ORDER_XZY = 1;
            constexpr auto PGU_INTERP_ORDER_YXZ = 2;
            constexpr auto PGU_INTERP_ORDER_YZX = 3;
            constexpr auto PGU_INTERP_ORDER_ZXY = 4;
            constexpr auto PGU_INTERP_ORDER_ZYX = 5;
// PJ_ELEVATION
            constexpr auto PJ_ELEVATION_NONE = 0;
            constexpr auto PJ_ELEVATION_GEOCENTRIC = 1;
            constexpr auto PJ_ELEVATION_GEOID = 2;
// PJ_RECT
            constexpr auto PJ_RECT_XY2LL = 0;
            constexpr auto PJ_RECT_LL2XY = 1;
// PLY_CLIP
            constexpr auto PLY_CLIP_NO_INTERSECT = 0;
            constexpr auto PLY_CLIP_INTERSECT = 1;
            constexpr auto PLY_CLIP_A_IN_B = 2;
            constexpr auto PLY_CLIP_B_IN_A = 3;
// PLY_POINT_CLIP
            constexpr auto PLY_POINT_CLIP_INSIDE = 0;
            constexpr auto PLY_POINT_CLIP_OUTSIDE = 1;
            constexpr auto PLY_POINT_CLIP_ERROR = 2;
// PLY_LINE_CLIP
            constexpr auto PLY_LINE_CLIP_INSIDE = 0;
            constexpr auto PLY_LINE_CLIP_NO_INTERSECT = 0;
            constexpr auto PLY_LINE_CLIP_OUTSIDE = 1;
            constexpr auto PLY_LINE_CLIP_ERROR = 2;
// COMMAND_ENV
            constexpr auto COMMAND_ENV_NORMAL = 0;
            constexpr auto COMMAND_ENV_IN3DVIEWER = 1;
// TOOL_TYPE
            constexpr auto TOOL_TYPE_DEFAULT = 0;
            constexpr auto TOOL_TYPE_AUXILIARY = 1;
            constexpr auto TOOL_TYPE_ALL = 2;
// PROJ_DISPLAY
            constexpr auto PROJ_DISPLAY_NO = 0;
            constexpr auto PROJ_DISPLAY_YES = 1;
            constexpr auto PROJ_DISPLAY_ALWAYS = 2;
// PROJ_OMS
            constexpr auto PROJ_OMS_NAME_SIZE = 32;
            constexpr auto PROJ_OMS_DATETIME_SIZE = 24;
            constexpr auto PROJ_OMS_PROCESSID_SIZE = 16;
// REG_MERGE
            constexpr auto REG_MERGE_REPLACE = 0;
            constexpr auto REG_MERGE_ADD = 1;
// SBF_OPEN
            constexpr auto SBF_READ = 0;
            constexpr auto SBF_READWRITE_NEW = 1;
            constexpr auto SBF_READWRITE_OLD = 2;
// SBF_TYPE
            constexpr auto SBF_TYPE_DIRS = 1;
            constexpr auto SBF_TYPE_FILES = 2;
            constexpr auto SBF_TYPE_BOTH = 3;
// SEMPLOT_GROUP_CLASS
            constexpr auto SEMPLOT_GROUP_CLASS = gx_string_literal("Semplot");
// SEMPLOT_EXPORT
            constexpr auto SEMPLOT_EXPORT_NORMAL = 0;
            constexpr auto SEMPLOT_EXPORT_NOEXTRA = 1;
// SEMPLOT_EXT
            constexpr auto SEMPLOT_EXT_ALL = 0;
            constexpr auto SEMPLOT_EXT_SEMPLOT = 1;
            constexpr auto SEMPLOT_EXT_CHIMERA = 2;
// SEMPLOT_PLOT
            constexpr auto SEMPLOT_PLOT_ALL = 0;
            constexpr auto SEMPLOT_PLOT_XYPLOT = 1;
            constexpr auto SEMPLOT_PLOT_TRIPLOT = 2;
            constexpr auto SEMPLOT_PLOT_UNKNOWN = 3;
// SHD_FIX
            constexpr auto SHD_FIX_NONE = 0;
            constexpr auto SHD_FIX_INCLINATION = 1;
            constexpr auto SHD_FIX_DECLINATION = 2;
// SHP_GEOM_TYPE
            constexpr auto SHP_GEOM_TYPE_POINT = 1;
            constexpr auto SHP_GEOM_TYPE_ARC = 3;
            constexpr auto SHP_GEOM_TYPE_POLYGON = 5;
            constexpr auto SHP_GEOM_TYPE_POINTZ = 11;
            constexpr auto SHP_GEOM_TYPE_ARCZ = 13;
            constexpr auto SHP_GEOM_TYPE_POLYGONZ = 15;
// MFCSQL_DRIVER
            constexpr auto MFCSQL_DRIVER_NOPROMPT = 0;
            constexpr auto MFCSQL_DRIVER_COMPLETE = 1;
            constexpr auto MFCSQL_DRIVER_PROMPT = 2;
            constexpr auto MFCSQL_DRIVER_COMPLETE_REQUIRED = 3;
// ST_INFO
            constexpr auto ST_ITEMS = 0;
            constexpr auto ST_NPOS = 1;
            constexpr auto ST_NZERO = 22;
            constexpr auto ST_TOTAL = 24;
            constexpr auto ST_NEMPTYSTRINGS = 25;
            constexpr auto ST_DUMMIES = 2;
            constexpr auto ST_MIN = 3;
            constexpr auto ST_MAX = 4;
            constexpr auto ST_RANGE = 5;
            constexpr auto ST_MEAN = 6;
            constexpr auto ST_MEDIAN = 7;
            constexpr auto ST_MODE = 8;
            constexpr auto ST_SIMPLE_MODE = 23;
            constexpr auto ST_GEOMEAN = 9;
            constexpr auto ST_VARIANCE = 10;
            constexpr auto ST_STDDEV = 11;
            constexpr auto ST_STDERR = 12;
            constexpr auto ST_SKEW = 13;
            constexpr auto ST_KURTOSIS = 14;
            constexpr auto ST_BASE = 15;
            constexpr auto ST_SUM = 16;
            constexpr auto ST_SUM2 = 17;
            constexpr auto ST_SUM3 = 18;
            constexpr auto ST_SUM4 = 19;
            constexpr auto ST_MINPOS = 21;
            constexpr auto ST_HIST_MAXCOUNT = 100;
// ST2_CORRELATION
            constexpr auto ST2_CORR = 0;
            constexpr auto ST2_PCORR = 1;
// STK_AXIS
            constexpr auto STK_AXIS_X = 0;
            constexpr auto STK_AXIS_Y = 1;
// STK_AXIS_POS
            constexpr auto STK_AXIS_NONE = 0;
            constexpr auto STK_AXIS_LEFT = 1;
            constexpr auto STK_AXIS_RIGHT = 2;
            constexpr auto STK_AXIS_BOTH = 3;
            constexpr auto STK_AXIS_BOTTOM = 1;
            constexpr auto STK_AXIS_TOP = 2;
// STK_FLAG
            constexpr auto STK_FLAG_PROFILE = 0;
            constexpr auto STK_FLAG_FID = 1;
            constexpr auto STK_FLAG_SYMBOL = 2;
            constexpr auto STK_FLAG_XBAR = 3;
            constexpr auto STK_FLAG_XLABEL = 4;
            constexpr auto STK_FLAG_XTITLE = 5;
            constexpr auto STK_FLAG_YBAR = 6;
            constexpr auto STK_FLAG_YLABEL = 7;
            constexpr auto STK_FLAG_YTITLE = 8;
            constexpr auto STK_FLAG_GRID1 = 9;
            constexpr auto STK_FLAG_GRID2 = 10;
// STK_GRID
            constexpr auto STK_GRID_PRIMARY = 0;
            constexpr auto STK_GRID_SECONDARY = 1;
// FILE_EXT
            constexpr auto FILE_EXT_ADD_IF_NONE = 0;
            constexpr auto FILE_EXT_FORCE = 1;
// STR_CASE
            constexpr auto STR_CASE_TOLERANT = 0;
            constexpr auto STR_CASE_SENSITIVE = 1;
// STR_ESCAPE
            constexpr auto ESCAPE_CONVERT = 0;
            constexpr auto ESCAPE_REPLACE = 1;
// STR_FILE_PART
            constexpr auto STR_FILE_PART_NAME = 0;
            constexpr auto STR_FILE_PART_EXTENSION = 1;
            constexpr auto STR_FILE_PART_DIRECTORY = 2;
            constexpr auto STR_FILE_PART_VOLUME = 3;
            constexpr auto STR_FILE_PART_QUALIFIERS = 4;
            constexpr auto STR_FILE_PART_NAME_EXTENSION = 5;
            constexpr auto STR_FILE_PART_FULLPATH_NO_QUALIFIERS = 6;
// STR_JUSTIFY
            constexpr auto STR_JUSTIFY_LEFT = 0;
            constexpr auto STR_JUSTIFY_CENTER = 1;
            constexpr auto STR_JUSTIFY_RIGHT = 2;
// STR_TRIM
            constexpr auto STR_TRIMRIGHT = 1;
            constexpr auto STR_TRIMLEFT = 2;
            constexpr auto STR_TRIMBOTH = 3;
// SURFACE_OPEN
            constexpr auto SURFACE_OPEN_READ = 0;
            constexpr auto SURFACE_OPEN_READWRITE = 1;
// SURFACERENDER_MODE
            constexpr auto SURFACERENDER_SMOOTH = 0;
            constexpr auto SURFACERENDER_FILL = 1;
            constexpr auto SURFACERENDER_EDGES = 2;
// ARC_LICENSE
            constexpr auto ARC_LICENSE_ENGINENOTPRESENT = 0;
            constexpr auto ARC_LICENSE_DESKTOPENGINE = 1;
            constexpr auto ARC_LICENSE_ARCVIEW = 2;
            constexpr auto ARC_LICENSE_ARCEDITOR = 3;
            constexpr auto ARC_LICENSE_ARCINFO = 4;
            constexpr auto ARC_LICENSE_ARCSERVER = 5;
// GEO_DIRECTORY
            constexpr auto GEO_DIRECTORY_NONE = 0;
            constexpr auto GEO_DIRECTORY_GEOSOFT = 1;
            constexpr auto GEO_DIRECTORY_BIN = 2;
            constexpr auto GEO_DIRECTORY_GER = 3;
            constexpr auto GEO_DIRECTORY_OMN = 4;
            constexpr auto GEO_DIRECTORY_TBL = 5;
            constexpr auto GEO_DIRECTORY_FONTS = 6;
            constexpr auto GEO_DIRECTORY_GX = 7;
            constexpr auto GEO_DIRECTORY_GS = 8;
            constexpr auto GEO_DIRECTORY_APPS = 9;
            constexpr auto GEO_DIRECTORY_ETC = 10;
            constexpr auto GEO_DIRECTORY_HLP = 11;
            constexpr auto GEO_DIRECTORY_USER_CSV = 14;
            constexpr auto GEO_DIRECTORY_USER_LIC = 15;
            constexpr auto GEO_DIRECTORY_USER_INI = 16;
            constexpr auto GEO_DIRECTORY_USER_TEMP = 17;
            constexpr auto GEO_DIRECTORY_USER_ETC = 18;
            constexpr auto GEO_DIRECTORY_IMG = 19;
            constexpr auto GEO_DIRECTORY_BAR = 20;
            constexpr auto GEO_DIRECTORY_MAPTEMPLATE = 22;
            constexpr auto GEO_DIRECTORY_USER_MAPTEMPLATE = 23;
            constexpr auto GEO_DIRECTORY_PYGX = 24;
            constexpr auto GEO_DIRECTORY_USER_PYGX = 25;
            constexpr auto GEO_DIRECTORY_USER_GX = 26;
// REG_DOMAIN
            constexpr auto REG_DOMAIN_MACHINE = 0;
            constexpr auto REG_DOMAIN_USER = 1;
// SHELL_EXECUTE
            constexpr auto GEOSW_HIDE = 0;
            constexpr auto GEOSW_SHOWNORMAL = 1;
            constexpr auto GEOSW_SHOWMINIMIZED = 2;
            constexpr auto GEOSW_SHOWMAXIMIZED = 3;
            constexpr auto GEOSW_SHOWNOACTIVATE = 4;
            constexpr auto GEOSW_SHOW = 5;
            constexpr auto GEOSW_MINIMIZE = 6;
            constexpr auto GEOSW_SHOWMINNOACTIVE = 7;
            constexpr auto GEOSW_SHOWNA = 8;
            constexpr auto GEOSW_RESTORE = 9;
            constexpr auto GEOSW_SHOWDEFAULT = 10;
            constexpr auto GEOSW_FORCEMINIMIZE = 11;
// SYS_DIR
            constexpr auto SYS_DIR_LOCAL = 0;
            constexpr auto SYS_DIR_GEOSOFT = 1;
            constexpr auto SYS_DIR_USER = 2;
            constexpr auto SYS_DIR_GEOTEMP = 3;
            constexpr auto SYS_DIR_WINDOWS = 4;
            constexpr auto SYS_DIR_SYSTEM = 5;
            constexpr auto SYS_DIR_LICENSE = 6;
            constexpr auto SYS_DIR_RESOURCEFILES = 7;
            constexpr auto SYS_DIR_GEOSOFT_BAR = 100;
            constexpr auto SYS_DIR_GEOSOFT_BIN = 101;
            constexpr auto SYS_DIR_GEOSOFT_CSV = 102;
            constexpr auto SYS_DIR_GEOSOFT_CSV_ALIASES = 103;
            constexpr auto SYS_DIR_GEOSOFT_DATA = 104;
            constexpr auto SYS_DIR_GEOSOFT_DBG = 105;
            constexpr auto SYS_DIR_GEOSOFT_ENCRYPTEDFILES = 106;
            constexpr auto SYS_DIR_GEOSOFT_ETC = 107;
            constexpr auto SYS_DIR_GEOSOFT_FONTS = 108;
            constexpr auto SYS_DIR_GEOSOFT_GER = 109;
            constexpr auto SYS_DIR_GEOSOFT_GS = 110;
            constexpr auto SYS_DIR_GEOSOFT_GX = 111;
            constexpr auto SYS_DIR_GEOSOFT_HLP = 112;
            constexpr auto SYS_DIR_GEOSOFT_IMG = 113;
            constexpr auto SYS_DIR_GEOSOFT_INI = 114;
            constexpr auto SYS_DIR_GEOSOFT_MAPTEMPLATE = 115;
            constexpr auto SYS_DIR_GEOSOFT_OMN = 116;
            constexpr auto SYS_DIR_GEOSOFT_PAGE = 117;
            constexpr auto SYS_DIR_GEOSOFT_SCHEMA = 118;
            constexpr auto SYS_DIR_GEOSOFT_SPEC_INI = 119;
            constexpr auto SYS_DIR_GEOSOFT_STYLESHEETS = 120;
            constexpr auto SYS_DIR_GEOSOFT_TBL = 121;
            constexpr auto SYS_DIR_GEOSOFT_PYTHON = 127;
            constexpr auto SYS_DIR_USER_CSV = 200;
            constexpr auto SYS_DIR_USER_ETC = 201;
            constexpr auto SYS_DIR_USER_GS = 202;
            constexpr auto SYS_DIR_USER_HLP = 203;
            constexpr auto SYS_DIR_USER_INI = 204;
            constexpr auto SYS_DIR_USER_LIC = 205;
            constexpr auto SYS_DIR_USER_MAPTEMPLATE = 206;
            constexpr auto SYS_DIR_USER_OMN = 207;
            constexpr auto SYS_DIR_USER_BAR = 214;
            constexpr auto SYS_DIR_USER_IMG = 215;
            constexpr auto SYS_DIR_USER_STACKS = 209;
            constexpr auto SYS_DIR_USER_TEMP = 210;
            constexpr auto SYS_DIR_USER_SERVICES = 211;
            constexpr auto SYS_DIR_USER_STYLESHEETS = 212;
// SYS_FONT
            constexpr auto SYS_FONT_GFN = 1;
            constexpr auto SYS_FONT_TT = 0;
// SYS_INFO
            constexpr auto SYS_INFO_VERSION_MAJOR = 0;
            constexpr auto SYS_INFO_VERSION_MINOR = 1;
            constexpr auto SYS_INFO_VERSION_SP = 2;
            constexpr auto SYS_INFO_BUILD_NUMBER = 3;
            constexpr auto SYS_INFO_BUILD_LABEL = 4;
            constexpr auto SYS_INFO_VERSION_LABEL = 5;
            constexpr auto SYS_INFO_PRODUCTNAME = 6;
            constexpr auto SYS_INFO_SERVERNAME = 7;
            constexpr auto SYS_INFO_LEGALCOPYRIGHT = 8;
            constexpr auto SYS_INFO_REGISTRY = 9;
            constexpr auto SYS_INFO_REGISTRY_ENVIRONMENT = 10;
            constexpr auto SYS_INFO_REGISTRY_SUPPORT = 11;
            constexpr auto SYS_INFO_REGISTRY_INTERAPP = 12;
            constexpr auto SYS_INFO_OIS_REGISTRY = 13;
            constexpr auto SYS_INFO_TEST_REGISTRY = 14;
// SYS_LINEAGE_SOURCE
            constexpr auto SYS_LINEAGE_SOURCE_MAP = 0;
            constexpr auto SYS_LINEAGE_SOURCE_MXD = 1;
            constexpr auto SYS_LINEAGE_SOURCE_DB = 2;
            constexpr auto SYS_LINEAGE_SOURCE_MAPTEMPLATE = 3;
            constexpr auto SYS_LINEAGE_SOURCE_GRID = 4;
            constexpr auto SYS_LINEAGE_SOURCE_VOXEL = 5;
// SYS_MENU_CLEAR
            constexpr auto SYS_MENU_CLEAR_ALL = 0;
            constexpr auto SYS_MENU_CLEAR_DEFAULT = 1;
// SYS_PATH
            constexpr auto SYS_PATH_LOCAL = 0;
            constexpr auto SYS_PATH_GEOSOFT = 1;
            constexpr auto SYS_PATH_GEOSOFT_USER = 2;
            constexpr auto SYS_PATH_GEOTEMP = 3;
            constexpr auto SYS_PATH_WINDOWS = 4;
            constexpr auto SYS_PATH_SYSTEM = 5;
            constexpr auto SYS_PATH_LICENSE = 6;
            constexpr auto SYS_PATH_RESOURCEFILES = 7;
            constexpr auto SYS_PATH_GEOSOFT_BAR = 100;
            constexpr auto SYS_PATH_GEOSOFT_BIN = 101;
            constexpr auto SYS_PATH_GEOSOFT_CSV = 102;
            constexpr auto SYS_PATH_GEOSOFT_CSV_ALIASES = 103;
            constexpr auto SYS_PATH_GEOSOFT_DATA = 104;
            constexpr auto SYS_PATH_GEOSOFT_DBG = 105;
            constexpr auto SYS_PATH_GEOSOFT_ENCRYPTEDFILES = 106;
            constexpr auto SYS_PATH_GEOSOFT_ETC = 107;
            constexpr auto SYS_PATH_GEOSOFT_FONTS = 108;
            constexpr auto SYS_PATH_GEOSOFT_GER = 109;
            constexpr auto SYS_PATH_GEOSOFT_GS = 110;
            constexpr auto SYS_PATH_GEOSOFT_PYGX = 126;
            constexpr auto SYS_PATH_GEOSOFT_GX = 111;
            constexpr auto SYS_PATH_GEOSOFT_HLP = 112;
            constexpr auto SYS_PATH_GEOSOFT_IMG = 113;
            constexpr auto SYS_PATH_GEOSOFT_INI = 114;
            constexpr auto SYS_PATH_GEOSOFT_MAPTEMPLATE = 115;
            constexpr auto SYS_PATH_GEOSOFT_OMN = 116;
            constexpr auto SYS_PATH_GEOSOFT_PAGE = 117;
            constexpr auto SYS_PATH_GEOSOFT_SCHEMA = 118;
            constexpr auto SYS_PATH_GEOSOFT_SPEC_INI = 119;
            constexpr auto SYS_PATH_GEOSOFT_STYLESHEETS = 120;
            constexpr auto SYS_PATH_GEOSOFT_TBL = 121;
            constexpr auto SYS_PATH_GEOSOFT_USER_CSV = 200;
            constexpr auto SYS_PATH_GEOSOFT_USER_ETC = 201;
            constexpr auto SYS_PATH_GEOSOFT_USER_GS = 202;
            constexpr auto SYS_PATH_GEOSOFT_USER_GX = 217;
            constexpr auto SYS_PATH_GEOSOFT_USER_PYGX = 216;
            constexpr auto SYS_PATH_GEOSOFT_USER_HLP = 203;
            constexpr auto SYS_PATH_GEOSOFT_USER_INI = 204;
            constexpr auto SYS_PATH_GEOSOFT_USER_LIC = 205;
            constexpr auto SYS_PATH_GEOSOFT_USER_MAPTEMPLATE = 206;
            constexpr auto SYS_PATH_GEOSOFT_USER_OMN = 207;
            constexpr auto SYS_PATH_GEOSOFT_USER_STACKS = 209;
            constexpr auto SYS_PATH_GEOSOFT_USER_TEMP = 210;
            constexpr auto SYS_PATH_USER_SERVICES = 211;
            constexpr auto SYS_PATH_USER_STYLESHEETS = 212;
// SYS_RUN_DISPLAY
            constexpr auto SYS_RUN_DISPLAY_WINDOW = 0;
            constexpr auto SYS_RUN_DISPLAY_MINIMIZE = 8;
            constexpr auto SYS_RUN_DISPLAY_FULLSCREEN = 16;
// SYS_RUN_HOLD
            constexpr auto SYS_RUN_HOLD_NEVER = 0;
            constexpr auto SYS_RUN_HOLD_ONERROR = 512;
            constexpr auto SYS_RUN_HOLD_ALWAYS = 1024;
// SYS_RUN_TYPE
            constexpr auto SYS_RUN_TYPE_DOS = 1;
            constexpr auto SYS_RUN_TYPE_EXE = 0;
            constexpr auto SYS_RUN_TYPE_WINDOWS = 2;
// SYS_RUN_WIN
            constexpr auto SYS_RUN_WIN_NOWAIT = 0;
            constexpr auto SYS_RUN_WIN_WAIT = 2048;
// SYS_SEARCH_PATH
            constexpr auto FIND_LOCAL_GEOSOFT = 0;
            constexpr auto FIND_GEOSOFT = 1;
            constexpr auto FIND_LOCAL = 2;
            constexpr auto FIND_SHORT = 1024;
// SYS_ENCRYPTION_KEY
            constexpr auto SYS_ENCRYPTION_KEY_GEOSOFT_ID = 0;
            constexpr auto SYS_ENCRYPTION_KEY_GLOBAL_ID = 1;
// TD_ICON
            constexpr auto TD_ICON_NONE = 0;
            constexpr auto TD_ICON_WARNING = 1;
            constexpr auto TD_ICON_ERROR = 2;
            constexpr auto TD_ICON_INFORMATION = 3;
            constexpr auto TD_ICON_SUCCESS = 4;
            constexpr auto TD_ICON_CONFIRMATION = 5;
// TD_BUTTON
            constexpr auto TD_BUTTON_NONE = 0;
            constexpr auto TD_BUTTON_OK = 1;
            constexpr auto TD_BUTTON_YES = 2;
            constexpr auto TD_BUTTON_NO = 4;
            constexpr auto TD_BUTTON_CANCEL = 8;
            constexpr auto TD_BUTTON_RETRY = 16;
            constexpr auto TD_BUTTON_CLOSE = 32;
// TD_ID
            constexpr auto TD_ID_OK = 1;
            constexpr auto TD_ID_CANCEL = 2;
            constexpr auto TD_ID_RETRY = 4;
            constexpr auto TD_ID_YES = 6;
            constexpr auto TD_ID_NO = 7;
            constexpr auto TD_ID_CLOSE = 8;
// TB_SEARCH
            constexpr auto TB_SEARCH_BINARY = 0;
            constexpr auto TB_SEARCH_LINEAR = 1;
// TB_SORT
            constexpr auto TB_SORT_UNIQUE = 0;
            constexpr auto TB_SORT_ALLOW_DUPLICATES = 1;
// TC_OPT
            constexpr auto TC_OPT_NONE = 0;
            constexpr auto TC_OPT_MAX = 1;
// TC_SURVEYTYPE
            constexpr auto TC_SURVEYTYPE_GROUND = 0;
            constexpr auto TC_SURVEYTYPE_SHIPBORNE = 1;
            constexpr auto TC_SURVEYTYPE_AIRBORNE = 2;
// GG_ELEMENT
            constexpr auto GG_ELEMENT_XX = 0;
            constexpr auto GG_ELEMENT_YY = 1;
            constexpr auto GG_ELEMENT_XY = 2;
            constexpr auto GG_ELEMENT_XZ = 3;
            constexpr auto GG_ELEMENT_YZ = 4;
// TPAT_STRING_SIZE
            constexpr auto TPAT_CODE_SIZE = 21;
            constexpr auto TPAT_LABEL_SIZE = 32;
            constexpr auto TPAT_DESC_SIZE = 128;
            constexpr auto TPAT_SYMBFONT_SIZE = 32;
// TRND_NODE
            constexpr auto TRND_MIN = 0;
            constexpr auto TRND_MAX = 1;
// UTF8
            constexpr auto UTF8_MAX_CHAR = 5;
// USERMETA_FORMAT
            constexpr auto USERMETA_FORMAT_DEFAULT = -1;
            constexpr auto USERMETA_FORMAT_ISO = 0;
            constexpr auto USERMETA_FORMAT_FGDC = 1;
// VA_AVERAGE
            constexpr auto VA_AVERAGE_ROWS = 0;
            constexpr auto VA_AVERAGE_COLUMNS = 1;
// VA_OBJECT
            constexpr auto VA_ROW = 0;
            constexpr auto VA_COL = 1;
// VAU_PRUNE
            constexpr auto VAU_PRUNE_DUMMY = 0;
            constexpr auto VAU_PRUNE_VALID = 1;
// VOX_DIR
            constexpr auto VOX_DIR_XY = 0;
            constexpr auto VOX_DIR_XZ = 1;
            constexpr auto VOX_DIR_YZ = 2;
// VOX_DIRECTION
            constexpr auto VOX_3D_DIR_XYZ = 0;
            constexpr auto VOX_3D_DIR_YXZ = 1;
            constexpr auto VOX_3D_DIR_XZY = 2;
            constexpr auto VOX_3D_DIR_YZX = 3;
            constexpr auto VOX_3D_DIR_ZXY = 4;
            constexpr auto VOX_3D_DIR_ZYX = 5;
// VOX_FILTER3D
            constexpr auto VOX_FILTER3D_FILE = 0;
            constexpr auto VOX_FILTER3D_SMOOTHING = 1;
            constexpr auto VOX_FILTER3D_LAPLACE = 2;
            constexpr auto VOX_FILTER3D_X_GRADIENT = 3;
            constexpr auto VOX_FILTER3D_Y_GRADIENT = 4;
            constexpr auto VOX_FILTER3D_Z_GRADIENT = 5;
            constexpr auto VOX_FILTER3D_TOTAL_GRADIENT = 6;
// VOX_GOCAD_ORIENTATION
            constexpr auto VOX_GOCAD_ORIENTATIONS_NORMAL = 0;
            constexpr auto VOX_GOCAD_ORIENTATIONS_INVERTED = 1;
            constexpr auto VOX_GOCAD_ORIENTATIONS_NORMAL_ZFIRST = 2;
            constexpr auto VOX_GOCAD_ORIENTATIONS_INVERTED_ZFIRST = 3;
// VOX_GRID_LOGOPT
            constexpr auto VOX_GRID_LOGOPT_LINEAR = 0;
            constexpr auto VOX_GRID_LOGOPT_LOG_SAVELINEAR = -1;
            constexpr auto VOX_GRID_LOGOPT_LOGLINEAR_SAVELINEAR = -2;
            constexpr auto VOX_GRID_LOGOPT_LOG_SAVELOG = 1;
            constexpr auto VOX_GRID_LOGOPT_LOGLINEAR_SAVELOG = 2;
// VOX_ORIGIN
            constexpr auto VOX_ORIGIN_BOTTOM = 0;
            constexpr auto VOX_ORIGIN_TOP = 1;
// VOX_SLICE_MODE
            constexpr auto VOX_SLICE_MODE_LINEAR = 1;
            constexpr auto VOX_SLICE_MODE_NEAREST = 0;
// VOX_VECTORVOX_IMPORT
            constexpr auto VOX_VECTORVOX_XYZ = 0;
            constexpr auto VOX_VECTORVOX_UVW = 1;
            constexpr auto VOX_VECTORVOX_AID = 2;
// VOXELRENDER_MODE
            constexpr auto VOXELRENDER_FILL = 0;
            constexpr auto VOXELRENDER_EDGES = 1;
            constexpr auto VOXELRENDER_FILL_EDGES = 2;
            constexpr auto VOXELRENDER_SMOOTH = 3;
// VOXE_EVAL
            constexpr auto VOXE_EVAL_NEAR = 0;
            constexpr auto VOXE_EVAL_INTERP = 1;
            constexpr auto VOXE_EVAL_BEST = 2;
// BLOCK_MODEL_VARIABLE_TYPE
            constexpr auto BLOCK_MODEL_NUMERIC_VARIABLE = 1;
            constexpr auto BLOCK_MODEL_STRING_VARIABLE = 2;
// VV_DOUBLE_CRC_BITS
            constexpr auto VV_DOUBLE_CRC_BITS_EXACT = 0;
            constexpr auto VV_DOUBLE_CRC_BITS_DEFAULT = 10;
            constexpr auto VV_DOUBLE_CRC_BITS_MAX = 51;
// VV_FLOAT_CRC_BITS
            constexpr auto VV_FLOAT_CRC_BITS_EXACT = 0;
            constexpr auto VV_FLOAT_CRC_BITS_DEFAULT = 7;
            constexpr auto VV_FLOAT_CRC_BITS_MAX = 22;
// VV_LOG_BASE
            constexpr auto VV_LOG_BASE_10 = 0;
            constexpr auto VV_LOG_BASE_E = 1;
// VV_LOGMODE
            constexpr auto VV_LOGMODE_CLIPPED = 0;
            constexpr auto VV_LOGMODE_SCALED = 1;
            constexpr auto VV_LOGMODE_CLAMPED = 2;
            constexpr auto VV_LOGMODE_LINEAR = 3;
// VV_LOOKUP
            constexpr auto VV_LOOKUP_EXACT = 0;
            constexpr auto VV_LOOKUP_NEAREST = 1;
            constexpr auto VV_LOOKUP_INTERPOLATE = 2;
            constexpr auto VV_LOOKUP_NEARESTCLOSE = 3;
            constexpr auto VV_LOOKUP_INTERPCLOSE = 4;
// VV_MASK
            constexpr auto VV_MASK_INSIDE = 0;
            constexpr auto VV_MASK_OUTSIDE = 1;
// VV_ORDER
            constexpr auto VV_ORDER_NONE = 0;
            constexpr auto VV_ORDER_INCREASING = 1;
            constexpr auto VV_ORDER_DECREASING = 2;
// VV_SORT
            constexpr auto VV_SORT_ASCENDING = 0;
            constexpr auto VV_SORT_DESCENDING = 1;
// VV_WINDOW
            constexpr auto VV_WINDOW_DUMMY = 0;
            constexpr auto VV_WINDOW_LIMIT = 1;
// QC_CRITERION
            constexpr auto QC_CRITERION_1 = 0;
            constexpr auto QC_CRITERION_2 = 1;
            constexpr auto QC_CRITERION_12 = 2;
// TEM_ARRAY
            constexpr auto TEM_ARRAY_VERTICALSOUNDING = 0;
            constexpr auto TEM_ARRAY_PROFILING = 1;
            constexpr auto TEM_ARRAY_BOREHOLE = 2;
// VV_DUP
            constexpr auto VV_DUP_AVERAGE = 0;
            constexpr auto VV_DUP_1 = 1;
            constexpr auto VV_DUP_2 = 2;
            constexpr auto VV_DUP_DUMMY = 3;
            constexpr auto VV_DUP_SAMPLE = 4;
// VV_XYDUP
            constexpr auto VV_XYDUP_AVERAGE = 0;
            constexpr auto VV_XYDUP_SUM = 1;
// VVU_CASE
            constexpr auto VVU_CASE_TOLERANT = 0;
            constexpr auto VVU_CASE_SENSITIVE = 1;
// VVU_CLIP
            constexpr auto VVU_CLIP_DUMMY = 0;
            constexpr auto VVU_CLIP_LIMIT = 1;
// VVU_DUMMYREPEAT
            constexpr auto VVU_DUMMYREPEAT_FIRST = 0;
            constexpr auto VVU_DUMMYREPEAT_LAST = 1;
            constexpr auto VVU_DUMMYREPEAT_MIDDLE = 2;
// VVU_INTERP
            constexpr auto VVU_INTERP_NEAREST = 1;
            constexpr auto VVU_INTERP_LINEAR = 2;
            constexpr auto VVU_INTERP_CUBIC = 3;
            constexpr auto VVU_INTERP_AKIMA = 4;
            constexpr auto VVU_INTERP_PREDICT = 5;
// VVU_INTERP_EDGE
            constexpr auto VVU_INTERP_EDGE_NONE = 0;
            constexpr auto VVU_INTERP_EDGE_SAME = 1;
            constexpr auto VVU_INTERP_EDGE_NEAREST = 2;
            constexpr auto VVU_INTERP_EDGE_LINEAR = 3;
// VVU_LINE
            constexpr auto LINE_2_POINTS = 0;
            constexpr auto LINE_POINT_AZIMUTH = 1;
// VVU_MASK
            constexpr auto VVU_MASK_INSIDE = 0;
            constexpr auto VVU_MASK_OUTSIDE = 1;
// VVU_MATCH
            constexpr auto VVU_MATCH_FULL_STRINGS = 0;
            constexpr auto VVU_MATCH_INPUT_LENGTH = 1;
// VVU_MODE
            constexpr auto VVU_MODE_MEAN = 0;
            constexpr auto VVU_MODE_MEDIAN = 1;
            constexpr auto VVU_MODE_MAXIMUM = 2;
            constexpr auto VVU_MODE_MINIMUM = 3;
// VVU_OFFSET
            constexpr auto VVU_OFFSET_FORWARD = 0;
            constexpr auto VVU_OFFSET_BACKWARD = 1;
            constexpr auto VVU_OFFSET_RIGHT = 2;
            constexpr auto VVU_OFFSET_LEFT = 3;
// VVU_PRUNE
            constexpr auto VVU_PRUNE_DUMMY = 0;
            constexpr auto VVU_PRUNE_VALID = 1;
// VVU_SPL
            constexpr auto VVU_SPL_LINEAR = 0;
            constexpr auto VVU_SPL_CUBIC = 1;
            constexpr auto VVU_SPL_AKIMA = 2;
            constexpr auto VVU_SPL_NEAREST = 3;
// VVU_SRCHREPL_CASE
            constexpr auto VVU_SRCHREPL_CASE_TOLERANT = 0;
            constexpr auto VVU_SRCHREPL_CASE_SENSITIVE = 1;
// WA_ENCODE
            constexpr auto WA_ENCODE_ANSI = 0;
            constexpr auto WA_ENCODE_RAW = 1;
            constexpr auto WA_ENCODE_UTF8 = 2;
            constexpr auto WA_ENCODE_UTF8_NOHEADER = 3;
            constexpr auto WA_ENCODE_UTF16_NOHEADER = 4;
// WA_OPEN
            constexpr auto WA_NEW = 0;
            constexpr auto WA_APPEND = 1;

            template<typename T>
            struct gs_cpp_type
            {
            private:
                gs_cpp_type() {}

            public:
                static int32_t type()
                {
                    static_assert(false, "Type does not map to supported GS_TYPES");
                }
            };

            template<> struct gs_cpp_type<int8_t>
            {
                static int32_t type()
                {
                    return GS_BYTE;
                }
            };
            template<> struct gs_cpp_type<uint8_t>
            {
                static int32_t type()
                {
                    return GS_UBYTE;
                }
            };
            template<> struct gs_cpp_type<int16_t>
            {
                static int32_t type()
                {
                    return GS_SHORT;
                }
            };
            template<> struct gs_cpp_type<uint16_t>
            {
                static int32_t type()
                {
                    return GS_USHORT;
                }
            };
            template<> struct gs_cpp_type<int32_t>
            {
                static int32_t type()
                {
                    return GS_LONG;
                }
            };
            template<> struct gs_cpp_type<uint32_t>
            {
                static int32_t type()
                {
                    return GS_ULONG;
                }
            };
            template<> struct gs_cpp_type<int64_t>
            {
                static int32_t type()
                {
                    return GS_LONG64;
                }
            };
            template<> struct gs_cpp_type<uint64_t>
            {
                static int32_t type()
                {
                    return GS_ULONG64;
                }
            };
            template<> struct gs_cpp_type<float>
            {
                static int32_t type()
                {
                    return GS_FLOAT;
                }
            };
            template<> struct gs_cpp_type<double>
            {
                static int32_t type()
                {
                    return GS_DOUBLE;
                }
            };




            class GXCancel : virtual public std::exception
            {
            };

            class GXExit : virtual public std::exception
            {
            };

            class GXError : virtual public std::exception
            {
            public:
                explicit GXError(const gx_string_type& message)
                    : message_(message)
                {
                }

                explicit GXError(const gx_string_type& message, const gx_string_type& module, int32_t error_number)
                    : message_(message)
                    , module_(module)
                    , error_number_(error_number)
                {
                }

                const gx_string_type& message() const
                {
                    return message_;
                }
                const gx_string_type& module() const
                {
                    return module_;
                }
                int32_t error_number() const
                {
                    return error_number_;
                }

            private:
                gx_string_type message_;
                gx_string_type module_;
                int32_t error_number_;
            };

            class GXAPIError : virtual public std::exception
            {
            public:
                explicit GXAPIError(const gx_string_type& message)
                    : message_(message)
                {
                }

                gx_string_type message() const
                {
                    return message_;
                }
            private:
                gx_string_type message_;
            };

            class GX3DC;
            typedef std::shared_ptr<GX3DC> GX3DCPtr;
            class GX3DN;
            typedef std::shared_ptr<GX3DN> GX3DNPtr;
            class GX3DV;
            typedef std::shared_ptr<GX3DV> GX3DVPtr;
            class GXACQUIRE;
            typedef std::shared_ptr<GXACQUIRE> GXACQUIREPtr;
            class GXAGG;
            typedef std::shared_ptr<GXAGG> GXAGGPtr;
            class GXARCDB;
            typedef std::shared_ptr<GXARCDB> GXARCDBPtr;
            class GXARCDH;
            typedef std::shared_ptr<GXARCDH> GXARCDHPtr;
            class GXARCMAP;
            typedef std::shared_ptr<GXARCMAP> GXARCMAPPtr;
            class GXARCPY;
            typedef std::shared_ptr<GXARCPY> GXARCPYPtr;
            class GXARCSYS;
            typedef std::shared_ptr<GXARCSYS> GXARCSYSPtr;
            class GXBF;
            typedef std::shared_ptr<GXBF> GXBFPtr;
            class GXBIGRID;
            typedef std::shared_ptr<GXBIGRID> GXBIGRIDPtr;
            class GXCHIMERA;
            typedef std::shared_ptr<GXCHIMERA> GXCHIMERAPtr;
            class GXCOM;
            typedef std::shared_ptr<GXCOM> GXCOMPtr;
            class GXCSYMB;
            typedef std::shared_ptr<GXCSYMB> GXCSYMBPtr;
            class GXDAT;
            typedef std::shared_ptr<GXDAT> GXDATPtr;
            class GXDATALINKD;
            typedef std::shared_ptr<GXDATALINKD> GXDATALINKDPtr;
            class GXDATAMINE;
            typedef std::shared_ptr<GXDATAMINE> GXDATAMINEPtr;
            class GXDB;
            typedef std::shared_ptr<GXDB> GXDBPtr;
            class GXDBREAD;
            typedef std::shared_ptr<GXDBREAD> GXDBREADPtr;
            class GXDBWRITE;
            typedef std::shared_ptr<GXDBWRITE> GXDBWRITEPtr;
            class GXDCOL;
            typedef std::shared_ptr<GXDCOL> GXDCOLPtr;
            class GXDGW;
            typedef std::shared_ptr<GXDGW> GXDGWPtr;
            class GXDH;
            typedef std::shared_ptr<GXDH> GXDHPtr;
            class GXDMPPLY;
            typedef std::shared_ptr<GXDMPPLY> GXDMPPLYPtr;
            class GXDOCU;
            typedef std::shared_ptr<GXDOCU> GXDOCUPtr;
            class GXDSEL;
            typedef std::shared_ptr<GXDSEL> GXDSELPtr;
            class GXDU;
            typedef std::shared_ptr<GXDU> GXDUPtr;
            class GXDXFI;
            typedef std::shared_ptr<GXDXFI> GXDXFIPtr;
            class GXE3DV;
            typedef std::shared_ptr<GXE3DV> GXE3DVPtr;
            class GXEDB;
            typedef std::shared_ptr<GXEDB> GXEDBPtr;
            class GXEDOC;
            typedef std::shared_ptr<GXEDOC> GXEDOCPtr;
            class GXEMAP;
            typedef std::shared_ptr<GXEMAP> GXEMAPPtr;
            class GXEMAPTEMPLATE;
            typedef std::shared_ptr<GXEMAPTEMPLATE> GXEMAPTEMPLATEPtr;
            class GXEUL3;
            typedef std::shared_ptr<GXEUL3> GXEUL3Ptr;
            class GXEXP;
            typedef std::shared_ptr<GXEXP> GXEXPPtr;
            class GXEXT;
            typedef std::shared_ptr<GXEXT> GXEXTPtr;
            class GXFFT;
            typedef std::shared_ptr<GXFFT> GXFFTPtr;
            class GXFFT2;
            typedef std::shared_ptr<GXFFT2> GXFFT2Ptr;
            class GXFLT;
            typedef std::shared_ptr<GXFLT> GXFLTPtr;
            class GXGD;
            typedef std::shared_ptr<GXGD> GXGDPtr;
            class GXGEO;
            typedef std::shared_ptr<GXGEO> GXGEOPtr;
            class GXGEOSTRING;
            typedef std::shared_ptr<GXGEOSTRING> GXGEOSTRINGPtr;
            class GXGER;
            typedef std::shared_ptr<GXGER> GXGERPtr;
            class GXGIS;
            typedef std::shared_ptr<GXGIS> GXGISPtr;
            class GXGMSYS;
            typedef std::shared_ptr<GXGMSYS> GXGMSYSPtr;
            class GXGRID3D;
            typedef std::shared_ptr<GXGRID3D> GXGRID3DPtr;
            class GXGU;
            typedef std::shared_ptr<GXGU> GXGUPtr;
            class GXGUI;
            typedef std::shared_ptr<GXGUI> GXGUIPtr;
            class GXHGD;
            typedef std::shared_ptr<GXHGD> GXHGDPtr;
            class GXHTTP;
            typedef std::shared_ptr<GXHTTP> GXHTTPPtr;
            class GXHXYZ;
            typedef std::shared_ptr<GXHXYZ> GXHXYZPtr;
            class GXIEXP;
            typedef std::shared_ptr<GXIEXP> GXIEXPPtr;
            class GXIGRF;
            typedef std::shared_ptr<GXIGRF> GXIGRFPtr;
            class GXIMG;
            typedef std::shared_ptr<GXIMG> GXIMGPtr;
            class GXIMU;
            typedef std::shared_ptr<GXIMU> GXIMUPtr;
            class GXINTERNET;
            typedef std::shared_ptr<GXINTERNET> GXINTERNETPtr;
            class GXIP;
            typedef std::shared_ptr<GXIP> GXIPPtr;
            class GXIPGUI;
            typedef std::shared_ptr<GXIPGUI> GXIPGUIPtr;
            class GXIPJ;
            typedef std::shared_ptr<GXIPJ> GXIPJPtr;
            class GXITR;
            typedef std::shared_ptr<GXITR> GXITRPtr;
            class GXKGRD;
            typedef std::shared_ptr<GXKGRD> GXKGRDPtr;
            class GXKML;
            typedef std::shared_ptr<GXKML> GXKMLPtr;
            class GXLAYOUT;
            typedef std::shared_ptr<GXLAYOUT> GXLAYOUTPtr;
            class GXLL2;
            typedef std::shared_ptr<GXLL2> GXLL2Ptr;
            class GXLMSG;
            typedef std::shared_ptr<GXLMSG> GXLMSGPtr;
            class GXLPT;
            typedef std::shared_ptr<GXLPT> GXLPTPtr;
            class GXLST;
            typedef std::shared_ptr<GXLST> GXLSTPtr;
            class GXLTB;
            typedef std::shared_ptr<GXLTB> GXLTBPtr;
            class GXMAP;
            typedef std::shared_ptr<GXMAP> GXMAPPtr;
            class GXMAPL;
            typedef std::shared_ptr<GXMAPL> GXMAPLPtr;
            class GXMAPTEMPLATE;
            typedef std::shared_ptr<GXMAPTEMPLATE> GXMAPTEMPLATEPtr;
            class GXMATH;
            typedef std::shared_ptr<GXMATH> GXMATHPtr;
            class GXMESH;
            typedef std::shared_ptr<GXMESH> GXMESHPtr;
            class GXMESHUTIL;
            typedef std::shared_ptr<GXMESHUTIL> GXMESHUTILPtr;
            class GXMETA;
            typedef std::shared_ptr<GXMETA> GXMETAPtr;
            class GXMISC;
            typedef std::shared_ptr<GXMISC> GXMISCPtr;
            class GXMPLY;
            typedef std::shared_ptr<GXMPLY> GXMPLYPtr;
            class GXMSTK;
            typedef std::shared_ptr<GXMSTK> GXMSTKPtr;
            class GXMULTIGRID3D;
            typedef std::shared_ptr<GXMULTIGRID3D> GXMULTIGRID3DPtr;
            class GXMULTIGRID3DUTIL;
            typedef std::shared_ptr<GXMULTIGRID3DUTIL> GXMULTIGRID3DUTILPtr;
            class GXMVG;
            typedef std::shared_ptr<GXMVG> GXMVGPtr;
            class GXMVIEW;
            typedef std::shared_ptr<GXMVIEW> GXMVIEWPtr;
            class GXMVU;
            typedef std::shared_ptr<GXMVU> GXMVUPtr;
            class GXMXD;
            typedef std::shared_ptr<GXMXD> GXMXDPtr;
            class GXPAT;
            typedef std::shared_ptr<GXPAT> GXPATPtr;
            class GXPDF3D;
            typedef std::shared_ptr<GXPDF3D> GXPDF3DPtr;
            class GXPG;
            typedef std::shared_ptr<GXPG> GXPGPtr;
            class GXPGEXP;
            typedef std::shared_ptr<GXPGEXP> GXPGEXPPtr;
            class GXPGU;
            typedef std::shared_ptr<GXPGU> GXPGUPtr;
            class GXPJ;
            typedef std::shared_ptr<GXPJ> GXPJPtr;
            class GXPLY;
            typedef std::shared_ptr<GXPLY> GXPLYPtr;
            class GXPRAGA3;
            typedef std::shared_ptr<GXPRAGA3> GXPRAGA3Ptr;
            class GXPROJ;
            typedef std::shared_ptr<GXPROJ> GXPROJPtr;
            class GXRA;
            typedef std::shared_ptr<GXRA> GXRAPtr;
            class GXREG;
            typedef std::shared_ptr<GXREG> GXREGPtr;
            class GXRGRD;
            typedef std::shared_ptr<GXRGRD> GXRGRDPtr;
            class GXSBF;
            typedef std::shared_ptr<GXSBF> GXSBFPtr;
            class GXSEGYREADER;
            typedef std::shared_ptr<GXSEGYREADER> GXSEGYREADERPtr;
            class GXSEMPLOT;
            typedef std::shared_ptr<GXSEMPLOT> GXSEMPLOTPtr;
            class GXSHD;
            typedef std::shared_ptr<GXSHD> GXSHDPtr;
            class GXSHP;
            typedef std::shared_ptr<GXSHP> GXSHPPtr;
            class GXSQLSRV;
            typedef std::shared_ptr<GXSQLSRV> GXSQLSRVPtr;
            class GXST;
            typedef std::shared_ptr<GXST> GXSTPtr;
            class GXST2;
            typedef std::shared_ptr<GXST2> GXST2Ptr;
            class GXSTK;
            typedef std::shared_ptr<GXSTK> GXSTKPtr;
            class GXSTORAGEPROJECT;
            typedef std::shared_ptr<GXSTORAGEPROJECT> GXSTORAGEPROJECTPtr;
            class GXSTR;
            typedef std::shared_ptr<GXSTR> GXSTRPtr;
            class GXSTRINGS;
            typedef std::shared_ptr<GXSTRINGS> GXSTRINGSPtr;
            class GXSURFACE;
            typedef std::shared_ptr<GXSURFACE> GXSURFACEPtr;
            class GXSURFACEITEM;
            typedef std::shared_ptr<GXSURFACEITEM> GXSURFACEITEMPtr;
            class GXSYS;
            typedef std::shared_ptr<GXSYS> GXSYSPtr;
            class GXTB;
            typedef std::shared_ptr<GXTB> GXTBPtr;
            class GXTC;
            typedef std::shared_ptr<GXTC> GXTCPtr;
            class GXTEST;
            typedef std::shared_ptr<GXTEST> GXTESTPtr;
            class GXTIN;
            typedef std::shared_ptr<GXTIN> GXTINPtr;
            class GXTPAT;
            typedef std::shared_ptr<GXTPAT> GXTPATPtr;
            class GXTR;
            typedef std::shared_ptr<GXTR> GXTRPtr;
            class GXTRANSFORMLAYER;
            typedef std::shared_ptr<GXTRANSFORMLAYER> GXTRANSFORMLAYERPtr;
            class GXTRND;
            typedef std::shared_ptr<GXTRND> GXTRNDPtr;
            class GXUNC;
            typedef std::shared_ptr<GXUNC> GXUNCPtr;
            class GXUSERMETA;
            typedef std::shared_ptr<GXUSERMETA> GXUSERMETAPtr;
            class GXVA;
            typedef std::shared_ptr<GXVA> GXVAPtr;
            class GXVAU;
            typedef std::shared_ptr<GXVAU> GXVAUPtr;
            class GXVECTOR3D;
            typedef std::shared_ptr<GXVECTOR3D> GXVECTOR3DPtr;
            class GXVM;
            typedef std::shared_ptr<GXVM> GXVMPtr;
            class GXVOX;
            typedef std::shared_ptr<GXVOX> GXVOXPtr;
            class GXVOXD;
            typedef std::shared_ptr<GXVOXD> GXVOXDPtr;
            class GXVOXE;
            typedef std::shared_ptr<GXVOXE> GXVOXEPtr;
            class GXVULCAN;
            typedef std::shared_ptr<GXVULCAN> GXVULCANPtr;
            class GXVV;
            typedef std::shared_ptr<GXVV> GXVVPtr;
            class GXVVEXP;
            typedef std::shared_ptr<GXVVEXP> GXVVEXPPtr;
            class GXVVU;
            typedef std::shared_ptr<GXVVU> GXVVUPtr;
            class GXWA;
            typedef std::shared_ptr<GXWA> GXWAPtr;

            class GXContext;
            typedef std::shared_ptr<GXContext> GXContextPtr;
            class GXContext : public std::enable_shared_from_this<GXContext>
            {
            private:


                friend class GX3DC;
                friend class GX3DN;
                friend class GX3DV;
                friend class GXACQUIRE;
                friend class GXAGG;
                friend class GXARCDB;
                friend class GXARCDH;
                friend class GXARCMAP;
                friend class GXARCPY;
                friend class GXARCSYS;
                friend class GXBF;
                friend class GXBIGRID;
                friend class GXCHIMERA;
                friend class GXCOM;
                friend class GXCSYMB;
                friend class GXDAT;
                friend class GXDATALINKD;
                friend class GXDATAMINE;
                friend class GXDB;
                friend class GXDBREAD;
                friend class GXDBWRITE;
                friend class GXDCOL;
                friend class GXDGW;
                friend class GXDH;
                friend class GXDMPPLY;
                friend class GXDOCU;
                friend class GXDSEL;
                friend class GXDU;
                friend class GXDXFI;
                friend class GXE3DV;
                friend class GXEDB;
                friend class GXEDOC;
                friend class GXEMAP;
                friend class GXEMAPTEMPLATE;
                friend class GXEUL3;
                friend class GXEXP;
                friend class GXEXT;
                friend class GXFFT;
                friend class GXFFT2;
                friend class GXFLT;
                friend class GXGD;
                friend class GXGEO;
                friend class GXGEOSTRING;
                friend class GXGER;
                friend class GXGIS;
                friend class GXGMSYS;
                friend class GXGRID3D;
                friend class GXGU;
                friend class GXGUI;
                friend class GXHGD;
                friend class GXHTTP;
                friend class GXHXYZ;
                friend class GXIEXP;
                friend class GXIGRF;
                friend class GXIMG;
                friend class GXIMU;
                friend class GXINTERNET;
                friend class GXIP;
                friend class GXIPGUI;
                friend class GXIPJ;
                friend class GXITR;
                friend class GXKGRD;
                friend class GXKML;
                friend class GXLAYOUT;
                friend class GXLL2;
                friend class GXLMSG;
                friend class GXLPT;
                friend class GXLST;
                friend class GXLTB;
                friend class GXMAP;
                friend class GXMAPL;
                friend class GXMAPTEMPLATE;
                friend class GXMATH;
                friend class GXMESH;
                friend class GXMESHUTIL;
                friend class GXMETA;
                friend class GXMISC;
                friend class GXMPLY;
                friend class GXMSTK;
                friend class GXMULTIGRID3D;
                friend class GXMULTIGRID3DUTIL;
                friend class GXMVG;
                friend class GXMVIEW;
                friend class GXMVU;
                friend class GXMXD;
                friend class GXPAT;
                friend class GXPDF3D;
                friend class GXPG;
                friend class GXPGEXP;
                friend class GXPGU;
                friend class GXPJ;
                friend class GXPLY;
                friend class GXPRAGA3;
                friend class GXPROJ;
                friend class GXRA;
                friend class GXREG;
                friend class GXRGRD;
                friend class GXSBF;
                friend class GXSEGYREADER;
                friend class GXSEMPLOT;
                friend class GXSHD;
                friend class GXSHP;
                friend class GXSQLSRV;
                friend class GXST;
                friend class GXST2;
                friend class GXSTK;
                friend class GXSTORAGEPROJECT;
                friend class GXSTR;
                friend class GXSTRINGS;
                friend class GXSURFACE;
                friend class GXSURFACEITEM;
                friend class GXSYS;
                friend class GXTB;
                friend class GXTC;
                friend class GXTEST;
                friend class GXTIN;
                friend class GXTPAT;
                friend class GXTR;
                friend class GXTRANSFORMLAYER;
                friend class GXTRND;
                friend class GXUNC;
                friend class GXUSERMETA;
                friend class GXVA;
                friend class GXVAU;
                friend class GXVECTOR3D;
                friend class GXVM;
                friend class GXVOX;
                friend class GXVOXD;
                friend class GXVOXE;
                friend class GXVULCAN;
                friend class GXVV;
                friend class GXVVEXP;
                friend class GXVVU;
                friend class GXWA;


                void *pGeo;
                bool destroyGeo;
                static thread_local std::weak_ptr<GXContext> currentContext;

                GXContext(void *_pGeo)
                    : pGeo(_pGeo)
                    , destroyGeo(false)
                {
                }

                GXContext(const gx_string_type& application, const gx_string_type& version, HWND hParentWnd, long flags = 0)
                    : pGeo(nullptr)
                    , destroyGeo(true)
                {
                    gx_string_char_type geoError[4096];
                    pGeo = pCreate_GEO(application.c_str(), version.c_str(), 0, hParentWnd, flags, geoError, _countof(geoError));
                    if (pGeo == nullptr)
                    {
                        gx_string_type error = gx_string_literal("Unable to initialize Geosoft libraries: ");
                        error += geoError;
                        throw GXAPIError(error);
                    }
                }

                void throw_on_error()
                {
                    long lTerminateReason = 0;
                    if (iCheckTerminate_SYS(pGeo, &lTerminateReason))
                    {
                        auto iErr = iCheckError_SYS(pGeo);
                        assert(iErr != 0);

                        if (lTerminateReason == 0)
                            throw GXExit();
                        else if (lTerminateReason == -1)
                            throw GXCancel();
                        else
                        {
                            int32_t error_number;
                            gx_string_type error_message, error_module;
                            int32_t moduleSize = STR_DEFAULT * STRING_CHAR_SIZE;
                            int32_t messageSize = STR_ERROR * STRING_CHAR_SIZE;
                            error_module.resize(STR_DEFAULT);
                            error_message.resize(STR_ERROR);
                            short ret = sGetError_GEO(pGeo, (gx_string_char_type*)error_module.data(), moduleSize, (gx_string_char_type*)error_message.data(), messageSize, reinterpret_cast<long*>(&error_number));

                            // Ensure no other errors are left on stack otherwise they could be thrown for subsequent API calls
                            while (ret != 0)
                            {
                                int32_t other_error_number;
                                gx_string_type other_error_message, other_error_module;
                                other_error_module.resize(STR_DEFAULT);
                                other_error_message.resize(STR_ERROR);
                                ret = sGetError_GEO(pGeo, (gx_string_char_type*)other_error_module.data(), moduleSize, (gx_string_char_type*)other_error_message.data(), messageSize, reinterpret_cast<long*>(&other_error_number));
                            }

                            error_module.resize(gx_string_len(error_module.c_str()));
                            error_message.resize(gx_string_len(error_message.c_str()));
                            if (error_number == 21023 || error_number == 21031 || // These two due to GXX asserts, Abort_SYS etc
                                    error_number == 31009 || error_number == 31011) // wrapper bind errors
                                throw GXAPIError(error_message);
                            else
                                throw GXError(error_message, error_module, error_number);
                        }
                    }
                }




                template<class GXClass>
                std::shared_ptr<GXClass> createPtr(int32_t handle)
                {
                    return std::shared_ptr<GXClass>(new GXClass(handle));
                }

                template<class GXClass>
                std::shared_ptr<GXClass> createNullHandlePtr()
                {
                    return std::shared_ptr<GXClass>(new GXClass(0));
                }

                static const int32_t null_handle = 0;
                template<class GXClass>
                const int32_t& handle(std::shared_ptr<GXClass> obj)
                {
                    if (!obj)
                        return null_handle;
                    return obj->handle_;
                }

            public:
                void * _internal_p()
                {
                    return pGeo;
                }
                static GXContextPtr create_internal(void *pGeo)
                {
                    if (auto cur_ctx = currentContext.lock())
                        return cur_ctx;

                    auto ctx = GXContextPtr(new GXContext(pGeo));
                    currentContext = ctx;
                    return ctx;
                }
                static GXContextPtr create(const gx_string_type& application, const gx_string_type& version, HWND hParentWnd = nullptr, long flags = 0)
                {
                    if (auto cur_ctx = currentContext.lock())
                        return cur_ctx;

                    auto ctx = GXContextPtr(new GXContext(application, version, hParentWnd, flags));
                    currentContext = ctx;
                    return ctx;
                }
                static GXContextPtr current()
                {
                    if (auto cur_ctx = currentContext.lock())
                        return cur_ctx;
                    else
                        throw GXAPIError(gx_string_literal("A GXContext has not been created on this thread, or has been destroyed."));
                }

                HWND get_main_wnd()
                {
                    return hGetMainWnd_GEO();
                }

                HWND get_active_wnd()
                {
                    return hGetActiveMainWnd_GEO();
                }

                void enable_application_windows(bool enable)
                {
                    EnableApplicationWindows_GEO(enable);
                }

                ~GXContext()
                {
                    if (destroyGeo && pGeo)
                        Destroy_GEO(pGeo);
                }

            };

            class GX3DC
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GX3DC(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GX3DCPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GX3DC>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GX3DCPtr create(HWND param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_3DC(
                                      gx_->pGeo, param1);
                    gx_->throw_on_error();
                    return gx_->createPtr<GX3DC>(ret);
                }
                int64_t get_geo_view()
                {
                    int64_t ret = GetGeoView_3DC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void destroy_internal()
                {
                    DestroyInternal_3DC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

            };
            class GX3DN
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GX3DN(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GX3DNPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GX3DN>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void copy(GX3DNPtr param1)
                {
                    Copy_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GX3DNPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_3DN(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GX3DN>(ret);
                }
                ~GX3DN()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_point_of_view(double& param1, double& param2, double& param3)
                {
                    GetPointOfView_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                void get_scale(double& param1, double& param2, double& param3)
                {
                    GetScale_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                int32_t get_axis_color()
                {
                    int32_t ret = iGetAxisColor_3DN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_axis_font(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetAxisFont_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                int32_t get_background_color()
                {
                    int32_t ret = iGetBackgroundColor_3DN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_render_controls(int32_t& param1, int32_t& param2, gx_string_type& param3, gx_string_type& param4, gx_string_type& param5)
                {
                    int32_t paramSize4 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize8 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_DEFAULT_LONG);
                    param4.resize(STR_DEFAULT_LONG);
                    param5.resize(STR_DEFAULT_LONG);
                    IGetRenderControls_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize6 ), (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize8 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param5.resize(gx_string_len(param5.c_str()));
                }
                int32_t get_shading()
                {
                    int32_t ret = iGetShading_3DN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_axis_color(int32_t param1)
                {
                    SetAxisColor_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_axis_font(const gx_string_type& param1)
                {
                    SetAxisFont_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_background_color(int32_t param1)
                {
                    SetBackgroundColor_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_point_of_view(double param1, double param2, double param3)
                {
                    SetPointOfView_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                void set_render_controls(int32_t param1, int32_t param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    SetRenderControls_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                }
                void set_scale(double param1, double param2, double param3)
                {
                    SetScale_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                void set_shading(int32_t param1)
                {
                    SetShading_3DN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

            };
            class GX3DV
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GX3DV(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GX3DVPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GX3DV>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                GXMVIEWPtr open_mview(int32_t param1)
                {
                    int32_t ret = OpenMVIEW_3DV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMVIEW>(ret);
                }
                void copy_to_map(GXMAPPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, int32_t param7, gx_string_type& param8, gx_string_type& param9)
                {
                    int32_t paramSize9 = MVIEW_NAME_LENGTH * STRING_CHAR_SIZE;
                    int32_t paramSize11 = STR_MULTI_FILE * STRING_CHAR_SIZE;
                    param8.resize(MVIEW_NAME_LENGTH);
                    param9.resize(STR_MULTI_FILE);
                    ICopyToMAP_3DV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&param7), (gx_string_char_type*)param8.data(), reinterpret_cast<const long*>(&paramSize9 ), (gx_string_char_type*)param9.data(), reinterpret_cast<const long*>(&paramSize11 ));
                    gx_->throw_on_error();
                    param8.resize(gx_string_len(param8.c_str()));
                    param9.resize(gx_string_len(param9.c_str()));
                }
                static GX3DVPtr create_new(const gx_string_type& param1, GXMVIEWPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateNew_3DV(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GX3DV>(ret);
                }
                static GX3DVPtr open(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Open_3DV(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GX3DV>(ret);
                }
                static GX3DVPtr from_map(GXMAPPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = FromMap_3DV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GX3DV>(ret);
                }
                void crc_3dv(int32_t& param1, const gx_string_type& param2)
                {
                    CRC3DV_3DV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXACQUIRE
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXACQUIRE(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXACQUIREPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXACQUIRE>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXACQUIREPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_ACQUIRE(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXACQUIRE>(ret);
                }
                void delete_empty_chan(GXDBPtr param1)
                {
                    DeleteEmptyChan_ACQUIRE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                ~GXACQUIRE()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_ACQUIRE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t import_hole(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, int32_t param5, int32_t param6)
                {
                    int32_t ret = iImportHole_ACQUIRE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t import_point(GXDBPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    int32_t ret = iImportPoint_ACQUIRE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t selection_tool(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = iSelectionTool_ACQUIRE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t selection_tool_force_grid_selection(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = iSelectionToolForceGridSelection_ACQUIRE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_selection_info(const gx_string_type& param1, int32_t& param2, int32_t& param3)
                {
                    GetSelectionInfo_ACQUIRE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }

            };
            class GXAGG
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXAGG(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXAGGPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXAGG>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void set_model(int32_t param1)
                {
                    _SetModel_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void change_brightness(double param1)
                {
                    ChangeBrightness_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                static GXAGGPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_AGG(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXAGG>(ret);
                }
                static GXAGGPtr create_map(GXMAPPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateMap_AGG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXAGG>(ret);
                }
                ~GXAGG()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_layer_itr(int32_t param1, GXITRPtr param2)
                {
                    GetLayerITR_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                GXSTPtr get_layer_st(int32_t param1)
                {
                    int32_t ret = GetLayerST_AGG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXST>(ret);
                }
                int32_t list_img(GXVVPtr param1)
                {
                    int32_t ret = iListImg_AGG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t num_layers()
                {
                    int32_t ret = iNumLayers_AGG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void layer_img(const gx_string_type& param1, int32_t param2, const gx_string_type& param3, double param4)
                {
                    LayerIMG_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), param3.c_str(), &param4);
                    gx_->throw_on_error();
                }
                void layer_img_ex(const gx_string_type& param1, int32_t param2, const gx_string_type& param3, double param4, double param5, double param6)
                {
                    LayerIMGEx_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), param3.c_str(), &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void layer_shade_img(const gx_string_type& param1, const gx_string_type& param2, double param3, double param4, double& param5)
                {
                    LayerShadeIMG_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                double get_brightness()
                {
                    double ret = rGetBrightness_AGG(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_layer_itr(int32_t param1, GXITRPtr param2)
                {
                    SetLayerITR_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void set_render_method(int32_t param1)
                {
                    SetRenderMethod_AGG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

            };
            class GXARCDB
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXARCDB(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXARCDBPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXARCDB>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                GXDATPtr create_dat(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    int32_t ret = CreateDAT_ARCDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDAT>(ret);
                }
                GXDATPtr create_dat_3d(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    int32_t ret = CreateDAT3D_ARCDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDAT>(ret);
                }
                static GXARCDBPtr current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Current_ARCDB(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXARCDB>(ret);
                }
                void export_to_db(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    ExportToDB_ARCDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                void field_lst(GXLSTPtr param1)
                {
                    FieldLST_ARCDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXARCDBPtr from_i_unknown(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = FromIUnknown_ARCDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXARCDB>(ret);
                }
                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_ARCDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                int32_t exist_field(const gx_string_type& param1)
                {
                    int32_t ret = iExistField_ARCDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_i_unknown()
                {
                    int32_t ret = iGetIUnknown_ARCDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t import_chem_database_wizard(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = iImportChemDatabaseWizard_ARCDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static GXARCDBPtr sel_tbl_ex_gui(int32_t& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = SelTblExGUI_ARCDB(
                                      gx_->pGeo, reinterpret_cast<long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXARCDB>(ret);
                }
                static GXARCDBPtr sel_tbl_gui()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = SelTblGUI_ARCDB(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXARCDB>(ret);
                }

            };
            class GXARCDH
            {
            private:
                GXARCDH();
                ~GXARCDH();
            public:


                static void close_project()
                {
                    GXContextPtr gx_ = GXContext::current();
                    CloseProject_ARCDH(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static void set_project(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetProject_ARCDH(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void set_string_file_gdb(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetStringFileGDB_ARCDH(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void stop_editing_string_file_gdb()
                {
                    GXContextPtr gx_ = GXContext::current();
                    StopEditingStringFileGDB_ARCDH(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static int32_t has_string_file_gdb_edits()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iHasStringFileGDBEdits_ARCDH(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t geostrings_extension_available()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGeostringsExtensionAvailable_ARCDH(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_current_string_file_gdb(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    GetCurrentStringFileGDB_ARCDH(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static int32_t is_valid_fgdb_file_name(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsValidFGDBFileName_ARCDH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t is_valid_feature_class_name(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsValidFeatureClassName_ARCDH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void s_prompt_for_esri_symbol(HWND param1, const gx_string_type& param2, int32_t param3, gx_string_type& param4, int32_t& param5, int32_t& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param4.resize(STR_VERY_LONG);
                    sPromptForESRISymbol_ARCDH(
                        gx_->pGeo, param1, param2.c_str(), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }

            };
            class GXARCMAP
            {
            private:
                GXARCMAP();
                ~GXARCMAP();
            public:


                static void change_size(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ChangeSize_ARCMAP(
                        gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                }
                static void display_in_3d_view(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DisplayIn3DView_ARCMAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void export_feature_layer_by_name_to_3d_file(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportFeatureLayerByNameTo3DFile_ARCMAP(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                static void export_selected_feature_layer_to_3d_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportSelectedFeatureLayerTo3DFile_ARCMAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void get_current_document_info(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    GetCurrentDocumentInfo_ARCMAP(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), (gx_string_char_type*)param2.data(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }
                static void get_selected_layer_info(int32_t param1, gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    GetSelectedLayerInfo_ARCMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }
                static int32_t get_number_of_selected_layers()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetNumberOfSelectedLayers_ARCMAP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t load_map(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iLoadMAP_ARCMAP(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t load_map_ex(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iLoadMAPEx_ARCMAP(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t load_shape(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iLoadShape_ARCMAP(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t load_spf(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iLoadSPF_ARCMAP(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static void load_lyr(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadLYR_ARCMAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void load_map(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadMap_ARCMAP(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void load_map_view(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadMapView_ARCMAP(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void load_raster(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadRaster_ARCMAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void load_raster_ex(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadRasterEx_ARCMAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void load_shape(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadShape_ARCMAP(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void map_view_to_shape(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, GXLSTPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MapViewToShape_ARCMAP(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void query_size(double& param1, double& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    QuerySize_ARCMAP(
                        gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                }
                static void show_layer_by_name_in_3d(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ShowLayerByNameIn3D_ARCMAP(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void show_selected_layers_in_3d()
                {
                    GXContextPtr gx_ = GXContext::current();
                    ShowSelectedLayersIn3D_ARCMAP(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static void get_ipj_for_predefined_esri_gcs(GXIPJPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetIPJForPredefinedEsriGCS_ARCMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void get_ipj_for_predefined_esri_pcs(GXIPJPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetIPJForPredefinedEsriPCS_ARCMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

            };
            class GXARCPY
            {
            private:
                GXARCPY();
                ~GXARCPY();
            public:


                static void add_message(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AddMessage_ARCPY(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void add_warning(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AddWarning_ARCPY(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void add_error(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AddError_ARCPY(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXARCSYS
            {
            private:
                GXARCSYS();
                ~GXARCSYS();
            public:


                static void get_browse_loc(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetBrowseLoc_ARCSYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void get_current_doc(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetCurrentDoc_ARCSYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void set_browse_loc(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetBrowseLoc_ARCSYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXBF
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXBF(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXBFPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXBF>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void ch_size(int32_t param1)
                {
                    _ChSize_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void seek(int32_t param1, int32_t param2)
                {
                    _Seek_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void copy(GXBFPtr param1)
                {
                    Copy_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                int32_t crc(int32_t param1, int32_t param2)
                {
                    int32_t ret = CRC_BF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static GXBFPtr create(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_BF(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXBF>(ret);
                }
                static GXBFPtr create_sbf(GXSBFPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateSBF_BF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXBF>(ret);
                }
                ~GXBF()
                {
                    if (handle_ == 0)
                        return;
                    DestroyEx_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t eof()
                {
                    int32_t ret = iEOF_BF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t query_write()
                {
                    int32_t ret = iQueryWrite_BF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void read_binary_string(int32_t param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    IReadBinaryString_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                int32_t size()
                {
                    int32_t ret = iSize_BF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t tell()
                {
                    int32_t ret = iTell_BF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void read_int(int32_t param1, int32_t& param2)
                {
                    ReadInt_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }
                void read_double(int32_t param1, double& param2)
                {
                    ReadReal_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                void read_vv(int32_t param1, GXVVPtr param2)
                {
                    ReadVV_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void set_destroy_status(int32_t param1)
                {
                    SetDestroyStatus_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void write_binary_string(int32_t param1, const gx_string_type& param2)
                {
                    WriteBinaryString_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void write_data_null()
                {
                    WriteDataNull_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void write_int(int32_t param1, int32_t param2)
                {
                    WriteInt_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void write_double(int32_t param1, double param2)
                {
                    WriteReal_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                void write_vv(int32_t param1, GXVVPtr param2)
                {
                    WriteVV_BF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

            };
            class GXBIGRID
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXBIGRID(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXBIGRIDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXBIGRID>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void clear()
                {
                    _Clear_BIGRID(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static GXBIGRIDPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_BIGRID(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXBIGRID>(ret);
                }
                ~GXBIGRID()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_BIGRID(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t load_parms(const gx_string_type& param1)
                {
                    int32_t ret = iLoadParms_BIGRID(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t load_warp(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    int32_t ret = iLoadWarp_BIGRID(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void run(const gx_string_type& param1, GXDATPtr param2, GXDATPtr param3)
                {
                    Run_BIGRID(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void run2(const gx_string_type& param1, GXDATPtr param2, GXDATPtr param3, GXIPJPtr param4)
                {
                    Run2_BIGRID(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void save_parms(const gx_string_type& param1)
                {
                    SaveParms_BIGRID(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                static int32_t get_defaults(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, double param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GetDefaults_BIGRID(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_default_cell_size(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GetDefaultCellSize_BIGRID(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), &param5);
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXCHIMERA
            {
            private:
                GXCHIMERA();
                ~GXCHIMERA();
            public:


                static void bar_plot(GXMVIEWPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, int32_t param8, int32_t param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BarPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11);
                    gx_->throw_on_error();
                }
                static void categorize_by_value(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CategorizeByValue_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void categorize_by_value_det_limit(GXVVPtr param1, GXVVPtr param2, double param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CategorizeByValueDetLimit_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void clip_to_detect_limit(GXVVPtr param1, double param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClipToDetectLimit_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void draw_circle_offset_markers(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DrawCircleOffsetMarkers_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), &param6);
                    gx_->throw_on_error();
                }
                static void draw_rectangle_offset_markers(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, double param6, double param7, double param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DrawRectangleOffsetMarkers_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), &param6, &param7, &param8);
                    gx_->throw_on_error();
                }
                static void duplicate_chem(GXMVIEWPtr param1, GXVVPtr param2, int32_t param3, double param4, int32_t param5, GXVVPtr param6, const gx_string_type& param7, const gx_string_type& param8, double param9, double param10, double param11, double param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DuplicateChem_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), param7.c_str(), param8.c_str(), &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                }
                static void duplicate_chem_view(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXIPJPtr param4, GXVVPtr param5, int32_t param6, double param7, int32_t param8, GXVVPtr param9, const gx_string_type& param10, const gx_string_type& param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14, GXDBPtr param15, double& param16, double& param17)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DuplicateChemView_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&gx_->handle(param9)), param10.c_str(), param11.c_str(), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)), &param16, &param17);
                    gx_->throw_on_error();
                }
                static void get_expression_data_vv(GXDBPtr param1, int32_t param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetExpressionDataVV_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static void get_lithogeochem_data(GXDBPtr param1, GXLSTPtr param2, int32_t param3, GXVVPtr param4, int32_t param5, GXVVPtr param6, int32_t param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10, GXVVPtr param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetLithogeochemData_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)));
                    gx_->throw_on_error();
                }
                static void get_transform(GXDBPtr param1, const gx_string_type& param2, int32_t param3, int32_t& param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetTransform_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<long*>(&param4), &param5);
                    gx_->throw_on_error();
                }
                static int32_t is_acquire_chan(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, double& param4, int32_t& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    param3.resize(STR_DEFAULT_SHORT);
                    int32_t ret = iIsAcquireChan_CHIMERA(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ), &param4, reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t is_element(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsElement_CHIMERA(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static void launch_histogram(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchHistogram_CHIMERA(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void launch_probability(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchProbability_CHIMERA(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void launch_scatter(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchScatter_CHIMERA(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void launch_triplot(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchTriplot_CHIMERA(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void mask_chan_lst(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MaskChanLST_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void ordered_channel_lst(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OrderedChannelLST_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void pie_plot(GXMVIEWPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, int32_t param8, int32_t param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PiePlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11);
                    gx_->throw_on_error();
                }
                static void pie_plot2(GXMVIEWPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, int32_t param8, int32_t param9, double param10, double param11, double param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PiePlot2_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11, &param12);
                    gx_->throw_on_error();
                }
                static void plot_string_classified_symbols_legend_from_class_file(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, const gx_string_type& param6, GXVVPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PlotStringClassifiedSymbolsLegendFromClassFile_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, param6.c_str(), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                static double atomic_weight(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rAtomicWeight_CHIMERA(
                                     gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void rose_plot(GXMVIEWPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, int32_t param8, int32_t param9, double param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RosePlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10);
                    gx_->throw_on_error();
                }
                static void rose_plot2(GXMVIEWPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, int32_t param8, int32_t param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RosePlot2_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11);
                    gx_->throw_on_error();
                }
                static void scatter2(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, const gx_string_type& param9, GXVVPtr param10, GXVVPtr param11, GXVVPtr param12, int32_t param13, const gx_string_type& param14, const gx_string_type& param15, const gx_string_type& param16, const gx_string_type& param17, double param18, double param19, double param20, double param21, double param22, double param23, double param24, double param25, int32_t param26, int32_t param27, int32_t param28, int32_t param29, int32_t param30, int32_t param31)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Scatter2_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), param9.c_str(), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&param13), param14.c_str(), param15.c_str(), param16.c_str(), param17.c_str(), &param18, &param19, &param20, &param21, &param22, &param23, &param24, &param25, reinterpret_cast<const long*>(&param26), reinterpret_cast<const long*>(&param27), reinterpret_cast<const long*>(&param28), reinterpret_cast<const long*>(&param29), reinterpret_cast<const long*>(&param30), reinterpret_cast<const long*>(&param31));
                    gx_->throw_on_error();
                }
                static void fixed_symbol_scatter_plot(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, int32_t param10, const gx_string_type& param11, int32_t param12, double param13, double param14, int32_t param15, int32_t param16, GXDBPtr param17, GXVVPtr param18, GXVVPtr param19, int32_t param20, const gx_string_type& param21, const gx_string_type& param22, const gx_string_type& param23, const gx_string_type& param24, double param25, double param26, double param27, double param28, int32_t param29, int32_t param30, const gx_string_type& param31)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FixedSymbolScatterPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), param11.c_str(), reinterpret_cast<const long*>(&param12), &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&gx_->handle(param18)), reinterpret_cast<const long*>(&gx_->handle(param19)), reinterpret_cast<const long*>(&param20), param21.c_str(), param22.c_str(), param23.c_str(), param24.c_str(), &param25, &param26, &param27, &param28, reinterpret_cast<const long*>(&param29), reinterpret_cast<const long*>(&param30), param31.c_str());
                    gx_->throw_on_error();
                }
                static void zone_coloured_scatter_plot(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, int32_t param10, GXVVPtr param11, const gx_string_type& param12, const gx_string_type& param13, int32_t param14, double param15, double param16, int32_t param17, int32_t param18, int32_t param19, GXDBPtr param20, GXVVPtr param21, GXVVPtr param22, int32_t param23, const gx_string_type& param24, const gx_string_type& param25, const gx_string_type& param26, const gx_string_type& param27, double param28, double param29, double param30, double param31, int32_t param32, int32_t param33, const gx_string_type& param34)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ZoneColouredScatterPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&gx_->handle(param11)), param12.c_str(), param13.c_str(), reinterpret_cast<const long*>(&param14), &param15, &param16, reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&gx_->handle(param20)), reinterpret_cast<const long*>(&gx_->handle(param21)), reinterpret_cast<const long*>(&gx_->handle(param22)), reinterpret_cast<const long*>(&param23), param24.c_str(), param25.c_str(), param26.c_str(), param27.c_str(), &param28, &param29, &param30, &param31, reinterpret_cast<const long*>(&param32), reinterpret_cast<const long*>(&param33), param34.c_str());
                    gx_->throw_on_error();
                }
                static void string_classified_scatter_plot(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, int32_t param10, GXVVPtr param11, const gx_string_type& param12, double param13, GXDBPtr param14, GXVVPtr param15, GXVVPtr param16, int32_t param17, const gx_string_type& param18, const gx_string_type& param19, const gx_string_type& param20, const gx_string_type& param21, double param22, double param23, double param24, double param25, int32_t param26, int32_t param27, const gx_string_type& param28)
                {
                    GXContextPtr gx_ = GXContext::current();
                    StringClassifiedScatterPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&gx_->handle(param11)), param12.c_str(), &param13, reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)), reinterpret_cast<const long*>(&gx_->handle(param16)), reinterpret_cast<const long*>(&param17), param18.c_str(), param19.c_str(), param20.c_str(), param21.c_str(), &param22, &param23, &param24, &param25, reinterpret_cast<const long*>(&param26), reinterpret_cast<const long*>(&param27), param28.c_str());
                    gx_->throw_on_error();
                }
                static void set_lithogeochem_data(GXDBPtr param1, GXLSTPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetLithogeochemData_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)));
                    gx_->throw_on_error();
                }
                static void stacked_bar_plot(GXMVIEWPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, int32_t param8, int32_t param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    StackedBarPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11);
                    gx_->throw_on_error();
                }
                static void standard(GXMVIEWPtr param1, GXVVPtr param2, int32_t param3, double param4, double param5, double param6, const gx_string_type& param7, const gx_string_type& param8, double param9, double param10, double param11, double param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Standard_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, param7.c_str(), param8.c_str(), &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                }
                static void standard_view(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXIPJPtr param4, GXVVPtr param5, int32_t param6, double param7, double param8, double param9, const gx_string_type& param10, const gx_string_type& param11, double param12, GXVVPtr param13, GXVVPtr param14, GXVVPtr param15, GXDBPtr param16, double& param17, double& param18)
                {
                    GXContextPtr gx_ = GXContext::current();
                    StandardView_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), &param7, &param8, &param9, param10.c_str(), param11.c_str(), &param12, reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)), reinterpret_cast<const long*>(&gx_->handle(param16)), &param17, &param18);
                    gx_->throw_on_error();
                }
                static void tri_plot2(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10, const gx_string_type& param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14, const gx_string_type& param15, const gx_string_type& param16, const gx_string_type& param17, double param18, double param19, double param20, double param21, double param22, double param23, int32_t param24, int32_t param25, int32_t param26, int32_t param27, int32_t param28, int32_t param29, int32_t param30, double param31, double param32)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TriPlot2_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), param11.c_str(), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), param15.c_str(), param16.c_str(), param17.c_str(), &param18, &param19, &param20, &param21, &param22, &param23, reinterpret_cast<const long*>(&param24), reinterpret_cast<const long*>(&param25), reinterpret_cast<const long*>(&param26), reinterpret_cast<const long*>(&param27), reinterpret_cast<const long*>(&param28), reinterpret_cast<const long*>(&param29), reinterpret_cast<const long*>(&param30), &param31, &param32);
                    gx_->throw_on_error();
                }
                static void fixed_symbol_tri_plot(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, int32_t param10, const gx_string_type& param11, int32_t param12, double param13, double param14, int32_t param15, int32_t param16, GXDBPtr param17, GXVVPtr param18, GXVVPtr param19, const gx_string_type& param20, const gx_string_type& param21, const gx_string_type& param22, int32_t param23, double param24, double param25, const gx_string_type& param26)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FixedSymbolTriPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), param11.c_str(), reinterpret_cast<const long*>(&param12), &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&gx_->handle(param18)), reinterpret_cast<const long*>(&gx_->handle(param19)), param20.c_str(), param21.c_str(), param22.c_str(), reinterpret_cast<const long*>(&param23), &param24, &param25, param26.c_str());
                    gx_->throw_on_error();
                }
                static void zone_coloured_tri_plot(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, int32_t param10, GXVVPtr param11, const gx_string_type& param12, const gx_string_type& param13, int32_t param14, double param15, double param16, int32_t param17, int32_t param18, int32_t param19, GXDBPtr param20, GXVVPtr param21, GXVVPtr param22, const gx_string_type& param23, const gx_string_type& param24, const gx_string_type& param25, int32_t param26, double param27, double param28, const gx_string_type& param29)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ZoneColouredTriPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&gx_->handle(param11)), param12.c_str(), param13.c_str(), reinterpret_cast<const long*>(&param14), &param15, &param16, reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&gx_->handle(param20)), reinterpret_cast<const long*>(&gx_->handle(param21)), reinterpret_cast<const long*>(&gx_->handle(param22)), param23.c_str(), param24.c_str(), param25.c_str(), reinterpret_cast<const long*>(&param26), &param27, &param28, param29.c_str());
                    gx_->throw_on_error();
                }
                static void string_classified_tri_plot(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, int32_t param10, GXVVPtr param11, const gx_string_type& param12, double param13, GXDBPtr param14, GXVVPtr param15, GXVVPtr param16, const gx_string_type& param17, const gx_string_type& param18, const gx_string_type& param19, int32_t param20, double param21, double param22, const gx_string_type& param23)
                {
                    GXContextPtr gx_ = GXContext::current();
                    StringClassifiedTriPlot_CHIMERA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&gx_->handle(param11)), param12.c_str(), &param13, reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)), reinterpret_cast<const long*>(&gx_->handle(param16)), param17.c_str(), param18.c_str(), param19.c_str(), reinterpret_cast<const long*>(&param20), &param21, &param22, param23.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXCOM
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXCOM(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXCOMPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXCOM>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXCOMPtr create(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_COM(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXCOM>(ret);
                }
                static GXCOMPtr create_no_terminate(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateNoTerminate_COM(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXCOM>(ret);
                }
                ~GXCOM()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t read_line_no_terminate(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    int32_t ret = IiReadLineNoTerminate_COM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }
                int32_t read_chars_no_terminate(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    int32_t ret = iReadCharsNoTerminate_COM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }
                void read_line(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IReadLine_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                int32_t write_chars_no_terminate(const gx_string_type& param1)
                {
                    int32_t ret = iWriteCharsNoTerminate_COM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void purge_comm()
                {
                    PurgeComm_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void read_chars(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    ReadChars_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void read_em61_lines_wa(int32_t param1, GXWAPtr param2)
                {
                    ReadEM61LinesWA_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void read_file2_wa(GXWAPtr param1)
                {
                    ReadFile2WA_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void read_lines_wa(int32_t param1, GXWAPtr param2)
                {
                    ReadLinesWA_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void set_time_out(int32_t param1)
                {
                    SetTimeOut_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void write_chars(const gx_string_type& param1)
                {
                    WriteChars_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void write_line(const gx_string_type& param1)
                {
                    WriteLine_COM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXCSYMB
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXCSYMB(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXCSYMBPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXCSYMB>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void set_angle(double param1)
                {
                    _SetAngle_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_base(double param1)
                {
                    _SetBase_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_dynamic_col(int32_t param1)
                {
                    _SetDynamicCol_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_fixed(int32_t param1)
                {
                    _SetFixed_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_number(int32_t param1)
                {
                    _SetNumber_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_scale(double param1)
                {
                    _SetScale_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void add_data(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    AddData_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static GXCSYMBPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_CSYMB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXCSYMB>(ret);
                }
                ~GXCSYMB()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_itr(GXITRPtr param1)
                {
                    GetITR_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_font(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    SetFont_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void set_static_col(int32_t param1, int32_t param2)
                {
                    SetStaticCol_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void get_stat(GXSTPtr param1)
                {
                    GetStat_CSYMB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

            };
            class GXDAT
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDAT(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDATPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDAT>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXDATPtr create_db(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateDB_DAT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDAT>(ret);
                }
                static GXDATPtr create_xgd(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateXGD_DAT(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDAT>(ret);
                }
                ~GXDAT()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                static void get_lst(GXLSTPtr param1, const gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetLST_DAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void range_xyz(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, int32_t& param7)
                {
                    RangeXYZ_DAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, reinterpret_cast<long*>(&param7));
                    gx_->throw_on_error();
                }

            };
            class GXDATALINKD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDATALINKD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDATALINKDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDATALINKD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXDATALINKDPtr create_arc_lyr(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateArcLYR_DATALINKD(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDATALINKD>(ret);
                }
                static GXDATALINKDPtr create_arc_lyr_ex(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateArcLYREx_DATALINKD(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDATALINKD>(ret);
                }
                static GXDATALINKDPtr create_arc_lyr_from_tmp(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateArcLYRFromTMP_DATALINKD(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDATALINKD>(ret);
                }
                static GXDATALINKDPtr create_arc_lyr_from_tmp_ex(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateArcLYRFromTMPEx_DATALINKD(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDATALINKD>(ret);
                }
                static GXDATALINKDPtr create_bing(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateBING_DATALINKD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDATALINKD>(ret);
                }
                ~GXDATALINKD()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DATALINKD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_extents(double& param1, double& param2, double& param3, double& param4)
                {
                    GetExtents_DATALINKD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_DATALINKD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

            };
            class GXDATAMINE
            {
            private:
                GXDATAMINE();
                ~GXDATAMINE();
            public:


                static void create_voxel(const gx_string_type& param1, const gx_string_type& param2, GXIPJPtr param3, GXMETAPtr param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateVoxel_DATAMINE(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str());
                    gx_->throw_on_error();
                }
                static void numeric_field_lst(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NumericFieldLST_DATAMINE(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

            };
            class GXDB
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDB(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDBPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDB>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void create_dup(const gx_string_type& param1)
                {
                    CreateDup_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void create_dup_comp(const gx_string_type& param1, int32_t param2)
                {
                    CreateDupComp_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                int32_t dup_symb_across(GXDBPtr param1, int32_t param2)
                {
                    int32_t ret = DupSymbAcross_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void easy_maker_symb(int32_t param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    EasyMakerSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                void get_chan_str(int32_t param1, int32_t param2, int32_t param3, gx_string_type& param4)
                {
                    int32_t paramSize5 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param4.resize(STR_DEFAULT_LONG);
                    GetChanStr_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }
                void get_chan_vv(int32_t param1, int32_t param2, GXVVPtr param3)
                {
                    GetChanVV_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void get_chan_vv_expanded(int32_t param1, int32_t param2, GXVVPtr param3)
                {
                    GetChanVVExpanded_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void get_ipj(int32_t param1, GXIPJPtr param2)
                {
                    GetIPJ_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void get_itr(int32_t param1, GXITRPtr param2)
                {
                    GetITR_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void get_reg_symb(int32_t param1, GXREGPtr param2)
                {
                    GetRegSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void get_reg_symb_setting(int32_t param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_DEFAULT_LONG);
                    GetRegSymbSetting_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                void get_va_chan_vv(int32_t param1, int32_t param2, GXVVPtr param3, int32_t param4, int32_t param5)
                {
                    GetVaChanVV_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                int32_t blobs_max()
                {
                    int32_t ret = iBlobsMax_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t chans_max()
                {
                    int32_t ret = iChansMax_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void format_chan(int32_t param1, double param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param3.resize(STR_DEFAULT);
                    IFormatChan_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                int32_t get_chan_array_size(int32_t param1)
                {
                    int32_t ret = iGetChanArraySize_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_chan_class(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = DB_GROUP_CLASS_SIZE * STRING_CHAR_SIZE;
                    param2.resize(DB_GROUP_CLASS_SIZE);
                    IGetChanClass_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t get_chan_decimal(int32_t param1)
                {
                    int32_t ret = iGetChanDecimal_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_chan_format(int32_t param1)
                {
                    int32_t ret = iGetChanFormat_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_chan_int(int32_t param1, int32_t param2, int32_t param3)
                {
                    int32_t ret = iGetChanInt_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_chan_label(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IGetChanLabel_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void get_chan_name(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    IGetChanName_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t get_chan_protect(int32_t param1)
                {
                    int32_t ret = iGetChanProtect_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_chan_type(int32_t param1)
                {
                    int32_t ret = iGetChanType_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_chan_unit(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IGetChanUnit_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t get_chan_width(int32_t param1)
                {
                    int32_t ret = iGetChanWidth_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_name(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetName_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t get_modification_count()
                {
                    int32_t ret = iGetModificationCount_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_reg_symb_setting_int(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = iGetRegSymbSetting_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void get_symb_name(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    IGetSymbName_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t have_itr(int32_t param1)
                {
                    int32_t ret = iHaveITR_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t coord_pair(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    int32_t ret = IiCoordPair_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }
                int32_t lines_max()
                {
                    int32_t ret = iLinesMax_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t users_max()
                {
                    int32_t ret = iUsersMax_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void maker_symb(int32_t param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    MakerSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                void put_chan_vv(int32_t param1, int32_t param2, GXVVPtr param3)
                {
                    PutChanVV_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void put_va_chan_vv(int32_t param1, int32_t param2, GXVVPtr param3, int32_t param4, int32_t param5)
                {
                    PutVaChanVV_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                void read_blob_bf(int32_t param1, GXBFPtr param2)
                {
                    ReadBlobBF_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                double get_chan_double(int32_t param1, int32_t param2, int32_t param3)
                {
                    double ret = rGetChanReal_DB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_reg_symb_setting_double(int32_t param1, const gx_string_type& param2)
                {
                    double ret = rGetRegSymbSetting_DB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void set_all_chan_protect(int32_t param1)
                {
                    SetAllChanProtect_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_chan_class(int32_t param1, const gx_string_type& param2)
                {
                    SetChanClass_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_chan_decimal(int32_t param1, int32_t param2)
                {
                    SetChanDecimal_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_chan_format(int32_t param1, int32_t param2)
                {
                    SetChanFormat_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_chan_int(int32_t param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    SetChanInt_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void set_chan_label(int32_t param1, const gx_string_type& param2)
                {
                    SetChanLabel_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_chan_name(int32_t param1, const gx_string_type& param2)
                {
                    SetChanName_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_chan_protect(int32_t param1, int32_t param2)
                {
                    SetChanProtect_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_chan_double(int32_t param1, int32_t param2, int32_t param3, double param4)
                {
                    SetChanReal_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }
                void set_chan_str(int32_t param1, int32_t param2, int32_t param3, const gx_string_type& param4)
                {
                    SetChanStr_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }
                void set_chan_unit(int32_t param1, const gx_string_type& param2)
                {
                    SetChanUnit_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_chan_width(int32_t param1, int32_t param2)
                {
                    SetChanWidth_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_ipj(int32_t param1, int32_t param2, GXIPJPtr param3)
                {
                    SetIPJ_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void set_itr(int32_t param1, GXITRPtr param2)
                {
                    SetITR_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void set_reg_symb(int32_t param1, GXREGPtr param2)
                {
                    SetRegSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void set_reg_symb_setting(int32_t param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    SetRegSymbSetting_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                void write_blob_bf(int32_t param1, GXBFPtr param2)
                {
                    WriteBlobBF_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void commit()
                {
                    Commit_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void compact()
                {
                    Compact_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static void create(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, const gx_string_type& param7, const gx_string_type& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Create_DB(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), param7.c_str(), param8.c_str());
                    gx_->throw_on_error();
                }
                static void create_comp(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, const gx_string_type& param7, const gx_string_type& param8, int32_t param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateComp_DB(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), param7.c_str(), param8.c_str(), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }
                static void create_ex(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, const gx_string_type& param7, const gx_string_type& param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateEx_DB(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), param7.c_str(), param8.c_str(), reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                void del_line0()
                {
                    DelLine0_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                ~GXDB()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void discard()
                {
                    Discard_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static void grow(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Grow_DB(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static int32_t can_open(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCanOpen_DB(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t can_open_read_only(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCanOpenReadOnly_DB(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t check()
                {
                    int32_t ret = iCheck_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_empty()
                {
                    int32_t ret = iIsEmpty_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_line_empty(int32_t param1)
                {
                    int32_t ret = iIsLineEmpty_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                static GXDBPtr open(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Open_DB(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }
                static GXDBPtr open_read_only(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = OpenReadOnly_DB(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }
                static void repair(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Repair_DB(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                void sync()
                {
                    Sync_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void copy_data(int32_t param1, int32_t param2, int32_t param3)
                {
                    CopyData_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                int32_t get_col_va(int32_t param1)
                {
                    int32_t ret = iGetColVA_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_channel_length(int32_t param1, int32_t param2)
                {
                    int32_t ret = iGetChannelLength_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_fid_incr(int32_t param1, int32_t param2)
                {
                    double ret = rGetFidIncr_DB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_fid_start(int32_t param1, int32_t param2)
                {
                    double ret = rGetFidStart_DB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_fid(int32_t param1, int32_t param2, double param3, double param4)
                {
                    SetFid_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, &param4);
                    gx_->throw_on_error();
                }
                void window_va_ch(int32_t param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    WindowVACh_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                void window_va_ch2(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    WindowVACh2_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void set_line_selection(int32_t param1, int32_t param2)
                {
                    SetLineSelection_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                int32_t get_line_selection(int32_t param1)
                {
                    int32_t ret = iGetLineSelection_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t first_sel_line()
                {
                    int32_t ret = FirstSelLine_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_line_map_fid(int32_t param1, double& param2, double& param3)
                {
                    GetLineMapFid_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                }
                int32_t get_select()
                {
                    int32_t ret = GetSelect_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t count_sel_lines()
                {
                    int32_t ret = iCountSelLines_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t is_chan_name(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsChanName_DB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_chan_valid(int32_t param1)
                {
                    int32_t ret = iIsChanValid_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t is_line_name(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsLineName_DB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_line_valid(int32_t param1)
                {
                    int32_t ret = iIsLineValid_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t line_category(int32_t param1)
                {
                    int32_t ret = iLineCategory_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t line_flight(int32_t param1)
                {
                    int32_t ret = iLineFlight_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void line_label(int32_t param1, gx_string_type& param2, int32_t param3)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    ILineLabel_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t line_number(int32_t param1)
                {
                    int32_t ret = iLineNumber_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void line_number2(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    ILineNumber2_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t line_type(int32_t param1)
                {
                    int32_t ret = iLineType_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t line_version(int32_t param1)
                {
                    int32_t ret = iLineVersion_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                static void set_line_name(int32_t param1, int32_t param2, int32_t param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param4.resize(STR_DB_SYMBOL);
                    ISetLineName_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }
                static void set_line_name2(const gx_string_type& param1, int32_t param2, int32_t param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param4.resize(STR_DB_SYMBOL);
                    ISetLineName2_DB(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }
                void rename_line(int32_t param1, const gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    RenameLine_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void load_select(const gx_string_type& param1)
                {
                    LoadSelect_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                int32_t next_sel_line(int32_t param1)
                {
                    int32_t ret = NextSelLine_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                double line_bearing(int32_t param1)
                {
                    double ret = rLineBearing_DB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                double line_date(int32_t param1)
                {
                    double ret = rLineDate_DB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void save_select(const gx_string_type& param1)
                {
                    SaveSelect_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void select(const gx_string_type& param1, int32_t param2)
                {
                    Select_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_line_bearing(int32_t param1, double param2)
                {
                    SetLineBearing_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                void set_line_date(int32_t param1, double param2)
                {
                    SetLineDate_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                void set_line_flight(int32_t param1, int32_t param2)
                {
                    SetLineFlight_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_line_map_fid(int32_t param1, double param2, double param3)
                {
                    SetLineMapFid_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                }
                void set_line_num(int32_t param1, int32_t param2)
                {
                    SetLineNum_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_line_type(int32_t param1, int32_t param2)
                {
                    SetLineType_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_line_ver(int32_t param1, int32_t param2)
                {
                    SetLineVer_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_select(int32_t param1)
                {
                    SetSelect_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void get_meta(GXMETAPtr param1)
                {
                    GetMETA_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXLSTPtr create_symb_lst()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateSymbLST_DB(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLST>(ret);
                }
                void array_lst(GXLSTPtr param1)
                {
                    ArrayLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void array_size_lst(int32_t param1, GXLSTPtr param2)
                {
                    ArraySizeLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void chan_lst(GXLSTPtr param1)
                {
                    ChanLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void normal_chan_lst(GXLSTPtr param1)
                {
                    NormalChanLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void non_string_and_non_array_chan_lst(GXLSTPtr param1)
                {
                    NonStringAndNonArrayChanLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void class_chan_lst(GXLSTPtr param1, const gx_string_type& param2)
                {
                    ClassChanLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void class_group_lst(GXLSTPtr param1, const gx_string_type& param2)
                {
                    ClassGroupLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                int32_t create_symb(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    int32_t ret = CreateSymb_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t create_symb_ex(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    int32_t ret = CreateSymbEx_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }
                void csv_chan_lst(GXLSTPtr param1, const gx_string_type& param2)
                {
                    CSVChanLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void delete_symb(int32_t param1)
                {
                    DeleteSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                int32_t dup_line_symb(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = DupLineSymb_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t dup_symb(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = DupSymb_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t dup_symb_no_lock(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = DupSymbNoLock_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t find_chan(const gx_string_type& param1)
                {
                    int32_t ret = FindChan_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t find_symb(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = FindSymb_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_chan_order_lst(GXLSTPtr param1)
                {
                    GetChanOrderLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                int32_t get_xyz_chan_symb(int32_t param1)
                {
                    int32_t ret = GetXYZChanSymb_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t class_chan_list(GXVVPtr param1, const gx_string_type& param2)
                {
                    int32_t ret = iClassChanList_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t exist_chan(const gx_string_type& param1)
                {
                    int32_t ret = iExistChan_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t exist_symb(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = iExistSymb_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t valid_symb(int32_t param1, int32_t param2)
                {
                    int32_t ret = iValidSymb_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_symb_lock(int32_t param1)
                {
                    int32_t ret = iGetSymbLock_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_xyz_chan(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    IGetXYZChan_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t symb_list(GXVVPtr param1, int32_t param2)
                {
                    int32_t ret = iSymbList_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void line_lst(GXLSTPtr param1)
                {
                    LineLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void lock_symb(int32_t param1, int32_t param2, int32_t param3)
                {
                    LockSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void mask_chan_lst(GXLSTPtr param1)
                {
                    MaskChanLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void selected_line_lst(GXLSTPtr param1)
                {
                    SelectedLineLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_chan_order_lst(GXLSTPtr param1)
                {
                    SetChanOrderLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_xyz_chan(int32_t param1, const gx_string_type& param2)
                {
                    SetXYZChan_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void string_chan_lst(GXLSTPtr param1)
                {
                    StringChanLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void symb_lst(GXLSTPtr param1, int32_t param2)
                {
                    SymbLST_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void un_lock_all_symb()
                {
                    UnLockAllSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void un_lock_symb(int32_t param1)
                {
                    UnLockSymb_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void add_associated_load(int32_t param1, int32_t param2)
                {
                    AddAssociatedLoad_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void add_comment(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    AddComment_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void add_int_comment(const gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    AddIntComment_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void add_double_comment(const gx_string_type& param1, double param2, int32_t param3)
                {
                    AddRealComment_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void add_time_comment(const gx_string_type& param1, int32_t param2)
                {
                    AddTimeComment_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void associate(int32_t param1, int32_t param2)
                {
                    Associate_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void associate_all(int32_t param1)
                {
                    AssociateAll_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void associate_class(int32_t param1, const gx_string_type& param2)
                {
                    AssociateClass_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                static void gen_valid_chan_symb(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    GenValidChanSymb_DB(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void gen_valid_line_symb(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    GenValidLineSymb_DB(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void get_chan_va(int32_t param1, int32_t param2, GXVAPtr param3)
                {
                    GetChanVA_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void get_va_scaling(int32_t param1, double& param2, double& param3)
                {
                    GetVAScaling_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                }
                void get_va_windows(int32_t param1, int32_t& param2, int32_t& param3)
                {
                    GetVAWindows_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }
                void set_va_base_coordinate_info(int32_t param1, int32_t param2, double param3, GXVVPtr param4, const gx_string_type& param5, int32_t param6)
                {
                    SetVABaseCoordinateInfo_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                void get_va_base_coordinate_info(int32_t param1, int32_t& param2, double& param3, GXVVPtr param4, gx_string_type& param5)
                {
                    int32_t paramSize6 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param5.resize(STR_DEFAULT);
                    GetVABaseCoordinateInfo_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2), &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize6 ));
                    gx_->throw_on_error();
                    param5.resize(gx_string_len(param5.c_str()));
                }
                void get_group_class(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = DB_GROUP_CLASS_SIZE * STRING_CHAR_SIZE;
                    param2.resize(DB_GROUP_CLASS_SIZE);
                    IGetGroupClass_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t get_info(int32_t param1)
                {
                    int32_t ret = iGetInfo_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_va_prof_color_file(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetVAProfColorFile_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void get_va_prof_sect_option(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IGetVAProfSectOption_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void get_va_sect_color_file(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetVASectColorFile_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t is_associated(int32_t param1, int32_t param2)
                {
                    int32_t ret = iIsAssociated_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_wholeplot()
                {
                    int32_t ret = iIsWholeplot_DB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void put_chan_va(int32_t param1, int32_t param2, GXVAPtr param3)
                {
                    PutChanVA_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void set_group_class(int32_t param1, const gx_string_type& param2)
                {
                    SetGroupClass_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_va_prof_color_file(int32_t param1, const gx_string_type& param2)
                {
                    SetVAProfColorFile_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_va_prof_sect_option(int32_t param1, const gx_string_type& param2)
                {
                    SetVAProfSectOption_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_va_scaling(int32_t param1, double param2, double param3)
                {
                    SetVAScaling_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                }
                void set_va_sect_color_file(int32_t param1, const gx_string_type& param2)
                {
                    SetVASectColorFile_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_va_windows(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetVAWindows_DB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

            };
            class GXDBREAD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDBREAD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDBREADPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDBREAD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXDBREADPtr create(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDBREAD>(ret);
                }
                static GXDBREADPtr create_xy(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateXY_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDBREAD>(ret);
                }
                static GXDBREADPtr create_xyz(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateXYZ_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDBREAD>(ret);
                }
                ~GXDBREAD()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DBREAD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t add_channel(int32_t param1)
                {
                    int32_t ret = iAddChannel_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                GXVVPtr get_vv(int32_t param1)
                {
                    int32_t ret = GetVV_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                GXVAPtr get_va(int32_t param1)
                {
                    int32_t ret = GetVA_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVA>(ret);
                }
                GXVVPtr get_v_vx()
                {
                    int32_t ret = GetVVx_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                GXVVPtr get_v_vy()
                {
                    int32_t ret = GetVVy_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                GXVVPtr get_v_vz()
                {
                    int32_t ret = GetVVz_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                int32_t get_chan_array_size(int32_t param1)
                {
                    int32_t ret = iGetChanArraySize_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_number_of_blocks_to_process()
                {
                    int32_t ret = iGetNumberOfBlocksToProcess_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_next_block(int32_t& param1, int32_t& param2, int32_t& param3)
                {
                    int32_t ret = iGetNextBlock_DBREAD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXDBWRITE
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDBWRITE(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDBWRITEPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDBWRITE>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXDBWRITEPtr create(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDBWRITE>(ret);
                }
                static GXDBWRITEPtr create_xy(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateXY_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDBWRITE>(ret);
                }
                static GXDBWRITEPtr create_xyz(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateXYZ_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDBWRITE>(ret);
                }
                ~GXDBWRITE()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DBWRITE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t add_channel(int32_t param1)
                {
                    int32_t ret = iAddChannel_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                GXDBPtr get_db()
                {
                    int32_t ret = GetDB_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }
                GXVVPtr get_vv(int32_t param1)
                {
                    int32_t ret = GetVV_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                GXVAPtr get_va(int32_t param1)
                {
                    int32_t ret = GetVA_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVA>(ret);
                }
                GXVVPtr get_v_vx()
                {
                    int32_t ret = GetVVx_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                GXVVPtr get_v_vy()
                {
                    int32_t ret = GetVVy_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                GXVVPtr get_v_vz()
                {
                    int32_t ret = GetVVz_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                int32_t get_chan_array_size(int32_t param1)
                {
                    int32_t ret = iGetChanArraySize_DBWRITE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void add_block(int32_t param1)
                {
                    AddBlock_DBWRITE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void commit()
                {
                    Commit_DBWRITE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void test_func(GXRAPtr param1)
                {
                    TestFunc_DBWRITE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

            };
            class GXDCOL
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDCOL(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDCOLPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDCOL>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                int32_t number_of_layers()
                {
                    int32_t ret = App_iNumberOfLayers_DCOL(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_type()
                {
                    int32_t ret = App_iGetType_DCOL(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_layer_info(int32_t param1, GXITRPtr param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    App_GetLayerInfo_DCOL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                void get_layer_itr(int32_t param1, GXITRPtr param2)
                {
                    App_GetLayerITR_DCOL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void set_layer_itr(int32_t param1, GXITRPtr param2, int32_t param3)
                {
                    App_SetLayerITR_DCOL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                int32_t set_itr_transform_from_layer(int32_t param1, GXITRPtr param2, int32_t param3)
                {
                    int32_t ret = App_iSetITRTransformFromLayer_DCOL(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t update_zone_transform_type(int32_t param1, int32_t param2)
                {
                    int32_t ret = App_iUpdateZoneTransformType_DCOL(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t update_zone_transform_parameters(int32_t param1)
                {
                    int32_t ret = App_iUpdateZoneTransformParameters_DCOL(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                GXSTPtr get_layer_statistics(int32_t param1)
                {
                    int32_t ret = App_GetLayerStatistics_DCOL(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXST>(ret);
                }
                GXVVPtr get_layer_histogram(int32_t param1, double& param2, double& param3)
                {
                    int32_t ret = App_GetLayerHistogram_DCOL(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                void save_layer_itr(int32_t param1)
                {
                    App_SaveLayerITR_DCOL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                int32_t get_brightness_type()
                {
                    int32_t ret = App_iGetBrightnessType_DCOL(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_brightness(double param1, int32_t param2, int32_t param3)
                {
                    App_SetBrightness_DCOL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                double get_brightness(int32_t param1, int32_t param2)
                {
                    double ret = App_rGetBrightness_DCOL(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_transparency(double param1)
                {
                    App_SetTransparency_DCOL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                double get_transparency()
                {
                    double ret = App_rGetTransparency_DCOL(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void reset()
                {
                    App_Reset_DCOL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void end(int32_t param1)
                {
                    App_End_DCOL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

            };
            class GXDGW
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDGW(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDGWPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDGW>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXDGWPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Create_DGW(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDGW>(ret);
                }
                ~GXDGW()
                {
                    if (handle_ == 0)
                        return;
                    App_Destroy_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_info_meta(int32_t param1, int32_t param2, GXMETAPtr param3, int32_t param4, int32_t param5)
                {
                    App_GetInfoMETA_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                void get_info_sys(int32_t param1, int32_t param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    App_GetInfoSYS_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                GXLSTPtr get_list(int32_t param1)
                {
                    int32_t ret = App_GetList_DGW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLST>(ret);
                }
                void gt_info(int32_t param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    App_GtInfo_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                int32_t run_dialogue()
                {
                    int32_t ret = App_iRunDialogue_DGW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_info(int32_t param1, int32_t param2, const gx_string_type& param3)
                {
                    App_SetInfo_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                void set_info_meta(int32_t param1, int32_t param2, GXMETAPtr param3, int32_t param4, int32_t param5)
                {
                    App_SetInfoMETA_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                void set_info_sys(int32_t param1, int32_t param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    App_SetInfoSYS_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                void set_title(const gx_string_type& param1)
                {
                    App_SetTitle_DGW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXDH
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDH(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDHPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDH>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static int32_t is_esri()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsESRI_DH(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                void creat_chan_lst(GXLSTPtr param1)
                {
                    CreatChanLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void depth_data_lst(GXLSTPtr param1)
                {
                    DepthDataLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void from_to_data_lst(const gx_string_type& param1, GXLSTPtr param2)
                {
                    FromToDataLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void get_geology_contacts(GXLSTPtr param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8)
                {
                    GetGeologyContacts_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                }
                void get_oriented_core_dip_dir(GXLSTPtr param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GetOrientedCoreDipDir_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }
                void get_unique_channel_items(const gx_string_type& param1, int32_t param2, GXVVPtr param3)
                {
                    GetUniqueChannelItems_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void get_unique_channel_items_from_collar(const gx_string_type& param1, int32_t param2, GXVVPtr param3)
                {
                    GetUniqueChannelItemsFromCollar_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                int32_t chan_type(const gx_string_type& param1)
                {
                    int32_t ret = iChanType_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t find_hole_intersection(int32_t param1, GXIMGPtr param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = iFindHoleIntersection_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }
                void get_chan_code_info(const gx_string_type& param1, int32_t& param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param3.resize(STR_DB_SYMBOL);
                    IGetChanCodeInfo_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                int32_t grid_intersection(double param1, double param2, double param3, double param4, double param5, const gx_string_type& param6, double& param7, double& param8, double& param9)
                {
                    int32_t ret = iGridIntersection_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, param6.c_str(), &param7, &param8, &param9);
                    gx_->throw_on_error();
                    return ret;
                }
                void litho_grid_3d(const gx_string_type& param1, GXTPATPtr param2, const gx_string_type& param3, double param4, double param5, double param6, int32_t param7, GXREGPtr param8, int32_t param9)
                {
                    LithoGrid3D_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), &param4, &param5, &param6, reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                void numeric_chan_lst(GXLSTPtr param1)
                {
                    NumericChanLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void numeric_from_to_data_lst(const gx_string_type& param1, GXLSTPtr param2)
                {
                    NumericFromToDataLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void punch_grid_holes(GXIMGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5)
                {
                    PunchGridHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5);
                    gx_->throw_on_error();
                }
                void string_chan_lst(GXLSTPtr param1)
                {
                    StringChanLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void string_from_to_data_lst(const gx_string_type& param1, GXLSTPtr param2)
                {
                    StringFromToDataLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                GXDBPtr h_assay_db(int32_t param1)
                {
                    int32_t ret = _hAssayDB_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }
                int32_t h_assay_symb(int32_t param1, int32_t param2)
                {
                    int32_t ret = _hAssaySymb_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                GXDBPtr h_collar_db()
                {
                    int32_t ret = _hCollarDB_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }
                int32_t h_collar_symb()
                {
                    int32_t ret = _hCollarSymb_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                GXDBPtr h_dip_az_survey_db()
                {
                    int32_t ret = _hDipAzSurveyDB_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }
                int32_t h_dip_az_survey_symb(int32_t param1)
                {
                    int32_t ret = _hDipAzSurveySymb_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                GXDBPtr h_en_survey_db()
                {
                    int32_t ret = _hENSurveyDB_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }
                int32_t h_en_survey_symb(int32_t param1)
                {
                    int32_t ret = _hENSurveySymb_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void add_survey_table(int32_t param1)
                {
                    AddSurveyTable_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void assay_hole_lst(int32_t param1, GXLSTPtr param2)
                {
                    AssayHoleLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void assay_lst(GXLSTPtr param1)
                {
                    AssayLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void auto_select_holes(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AutoSelectHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void clean()
                {
                    Clean_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void composite_db(GXDBPtr param1, GXDBPtr param2, int32_t param3, int32_t param4, double param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, double param9, double param10, double param11, int32_t param12, const gx_string_type& param13)
                {
                    CompositeDB_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, param6.c_str(), param7.c_str(), param8.c_str(), &param9, &param10, &param11, reinterpret_cast<const long*>(&param12), param13.c_str());
                    gx_->throw_on_error();
                }
                void compute_hole_xyz(int32_t param1)
                {
                    ComputeHoleXYZ_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void compute_sel_extent(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    ComputeSelExtent_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void compute_xyz()
                {
                    ComputeXYZ_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static void convert_old_line_names(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertOldLineNames_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static GXDHPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_DH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDH>(ret);
                }
                void create_default_job(const gx_string_type& param1, int32_t param2)
                {
                    CreateDefaultJob_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static GXDHPtr create_external(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateExternal_DH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDH>(ret);
                }
                static GXDHPtr current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Current_DH(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDH>(ret);
                }
                static void datamine_to_csv(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DatamineToCSV_DH(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void delete_holes(GXLSTPtr param1)
                {
                    DeleteHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                ~GXDH()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void export_file(const gx_string_type& param1, int32_t param2)
                {
                    Export_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void export_geodatabase_lst(GXLSTPtr param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4, int32_t param5)
                {
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param4.resize(STR_FILE);
                    ExportGeodatabaseLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }
                void export_las(int32_t param1, int32_t param2, double param3, const gx_string_type& param4)
                {
                    ExportLAS_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, param4.c_str());
                    gx_->throw_on_error();
                }
                void export_lst(GXLSTPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    ExportLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void flush_select()
                {
                    FlushSelect_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void get_databases_vv(GXVVPtr param1)
                {
                    GetDatabasesVV_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_databases_sorted_vv(GXVVPtr param1)
                {
                    GetDatabasesSortedVV_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_data_type(GXDBPtr param1, int32_t& param2)
                {
                    GetDataType_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }
                void get_default_section(double& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    GetDefaultSection_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                int32_t get_hole_group(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = GetHoleGroup_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void get_hole_survey(int32_t param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5)
                {
                    GetHoleSurvey_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                void get_hole_survey_ex(int32_t param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, int32_t param6)
                {
                    GetHoleSurveyEx_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                void get_hole_survey_from_to(GXDBPtr param1, int32_t param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, int32_t param8)
                {
                    GetHoleSurveyFromTo_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void desurvey(int32_t param1, int32_t param2, int32_t param3, double param4, int32_t param5, int32_t param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, double param10, double param11, double param12, double param13, double param14, GXVVPtr param15, GXVVPtr param16, GXVVPtr param17, GXVVPtr param18)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Desurvey_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), &param10, &param11, &param12, &param13, &param14, reinterpret_cast<const long*>(&gx_->handle(param15)), reinterpret_cast<const long*>(&gx_->handle(param16)), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&gx_->handle(param18)));
                    gx_->throw_on_error();
                }
                static void convert_oriented_core_dip_dir_for_hole_survey(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertOrientedCoreDipDirForHoleSurvey_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void desurvey_from_to(int32_t param1, int32_t param2, int32_t param3, double param4, int32_t param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10, double param11, double param12, double param13, double param14, double param15, GXVVPtr param16, GXVVPtr param17, GXVVPtr param18, GXVVPtr param19, GXVVPtr param20)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DesurveyFromTo_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), &param11, &param12, &param13, &param14, &param15, reinterpret_cast<const long*>(&gx_->handle(param16)), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&gx_->handle(param18)), reinterpret_cast<const long*>(&gx_->handle(param19)), reinterpret_cast<const long*>(&gx_->handle(param20)));
                    gx_->throw_on_error();
                }
                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_map_names_vv(GXVVPtr param1)
                {
                    GetMapNamesVV_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                GXMAPPtr get_map(int32_t param1)
                {
                    int32_t ret = GetMap_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAP>(ret);
                }
                int32_t get_num_maps()
                {
                    int32_t ret = GetNumMaps_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                GXREGPtr get_reg()
                {
                    int32_t ret = GetREG_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXREG>(ret);
                }
                void get_selected_holes_vv(GXVVPtr param1)
                {
                    GetSelectedHolesVV_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void get_table_default_chan_lst(GXLSTPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetTableDefaultChanLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void hole_lst(GXLSTPtr param1)
                {
                    HoleLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void hole_lst2(GXLSTPtr param1)
                {
                    HoleLST2_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                int32_t add_hole(const gx_string_type& param1)
                {
                    int32_t ret = iAddHole_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t clean_will_delete_db()
                {
                    int32_t ret = iCleanWillDeleteDB_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t compositing_tool_gui(GXMAPPtr param1, double param2, double param3, double param4)
                {
                    int32_t ret = iCompositingToolGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4);
                    gx_->throw_on_error();
                    return ret;
                }
                static void create_collar_table(const gx_string_type& param1, int32_t param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    ICreateCollarTable_DH(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                static void create_collar_table_dir(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param4.resize(STR_FILE);
                    ICreateCollarTableDir_DH(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }
                int32_t delete_will_delete_db(GXLSTPtr param1)
                {
                    int32_t ret = iDeleteWillDeleteDB_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t find_hole(const gx_string_type& param1)
                {
                    int32_t ret = iFindHole_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void get_collar_table_db(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetCollarTableDB_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_info(int32_t param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_DEFAULT_LONG);
                    IGetInfo_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                void get_project_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetProjectName_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void get_section_id(double param1, double param2, double param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param4.resize(STR_FILE);
                    IGetSectionID_DH(
                        gx_->pGeo, &param1, &param2, &param3, (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }
                static int32_t get_template_blob(GXDBPtr param1, const gx_string_type& param2, int32_t& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetTemplateBlob_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_template_blob_no_source_resolve(GXDBPtr param1, const gx_string_type& param2, int32_t& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetTemplateBlobNoSourceResolve_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_template_info(const gx_string_type& param1, int32_t& param2, gx_string_type& param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    param4.resize(STR_FILE);
                    IGetTemplateInfo_DH(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                }
                static void get_template_info_ex(const gx_string_type& param1, int32_t& param2, gx_string_type& param3, gx_string_type& param4, GXLSTPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    param4.resize(STR_FILE);
                    IGetTemplateInfoEx_DH(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                }
                void get_units(gx_string_type& param1, double& param2)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    IGetUnits_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), &param2);
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static int32_t have_current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iHaveCurrent_DH(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t have_current2(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    int32_t ret = IiHaveCurrent2_DH(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }
                int32_t holes()
                {
                    int32_t ret = iHoles_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t hole_select_from_list_gui(GXLSTPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iHoleSelectFromListGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t hole_selection_tool_gui()
                {
                    int32_t ret = iHoleSelectionToolGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t modify3d_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModify3dGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t edit_classification_table_file_gui(const gx_string_type& param1, gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    int32_t ret = iEditClassificationTableFileGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }
                int32_t modify_crooked_section_holes_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifyCrookedSectionHolesGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t modify_fence_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifyFenceGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t modify_hole_traces_3d_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifyHoleTraces3DGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t modify_hole_traces_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifyHoleTracesGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t modify_hole_traces_gui2(const gx_string_type& param1, int32_t param2, int32_t& param3)
                {
                    int32_t ret = iModifyHoleTracesGUI2_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t modify_plan_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifyPlanGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t modify_plan_holes_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifyPlanHolesGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t modify_rock_codes_gui(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iModifyRockCodesGUI_DH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t modify_rock_codes_gui2(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iModifyRockCodesGUI2_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t modify_section_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifySectionGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t modify_section_holes_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifySectionHolesGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t modify_stacked_section_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifyStackedSectionGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t modify_strip_log_gui(const gx_string_type& param1, int32_t& param2)
                {
                    int32_t ret = iModifyStripLogGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t modify_structure_codes_gui(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iModifyStructureCodesGUI_DH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t modify_structure_codes_gui2(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iModifyStructureCodesGUI2_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void import2(const gx_string_type& param1, GXDBPtr param2, int32_t param3, int32_t param4, const gx_string_type& param5, int32_t param6, const gx_string_type& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Import2_DH(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), reinterpret_cast<const long*>(&param6), param7.c_str());
                    gx_->throw_on_error();
                }
                void import_las(const gx_string_type& param1, const gx_string_type& param2, double param3, int32_t param4, GXWAPtr param5)
                {
                    ImportLAS_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                int32_t num_assays()
                {
                    int32_t ret = iNumAssays_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t num_selected_holes()
                {
                    int32_t ret = iNumSelectedHoles_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t qa_dip_az_curvature_lst(GXLSTPtr param1, double param2, GXWAPtr param3)
                {
                    int32_t ret = iQADipAzCurvatureLST_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t qa_dip_az_survey_lst(GXLSTPtr param1, GXWAPtr param2)
                {
                    int32_t ret = iQADipAzSurveyLST_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t qa_east_north_curvature_lst(GXLSTPtr param1, double param2, GXWAPtr param3)
                {
                    int32_t ret = iQAEastNorthCurvatureLST_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t qa_east_north_survey_lst(GXLSTPtr param1, GXWAPtr param2)
                {
                    int32_t ret = iQAEastNorthSurveyLST_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t slice_selection_tool_gui(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double& param9, double& param10, double& param11, double& param12)
                {
                    int32_t ret = iSliceSelectionToolGUI_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t update_survey_from_collar(int32_t param1)
                {
                    int32_t ret = iUpdateSurveyFromCollar_DH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void load_data_parameters_ini(GXDBPtr param1, const gx_string_type& param2)
                {
                    LoadDataParametersINI_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void load_plot_parameters(const gx_string_type& param1, int32_t param2)
                {
                    LoadPlotParameters_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void load_select(const gx_string_type& param1)
                {
                    LoadSelect_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void mask_ply(GXPLYPtr param1, GXIPJPtr param2, double param3, const gx_string_type& param4, int32_t param5, int32_t param6)
                {
                    MaskPLY_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static GXDHPtr open(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Open_DH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDH>(ret);
                }
                void open_job(const gx_string_type& param1, int32_t param2)
                {
                    OpenJob_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void plot_hole_traces(GXMAPPtr param1, const gx_string_type& param2)
                {
                    PlotHoleTraces_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void plot_hole_traces_3d(GXMVIEWPtr param1, const gx_string_type& param2)
                {
                    PlotHoleTraces3D_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void plot_symbols_3d(GXMVIEWPtr param1, const gx_string_type& param2)
                {
                    PlotSymbols3D_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void qa_collar(GXWAPtr param1)
                {
                    QACollar_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void qa_collar_lst(GXLSTPtr param1, GXWAPtr param2)
                {
                    QACollarLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void qa_dip_az_curvature(GXWAPtr param1, double param2)
                {
                    QADipAzCurvature_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }
                void qa_dip_az_curvature2(GXWAPtr param1, double param2, const gx_string_type& param3)
                {
                    QADipAzCurvature2_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, param3.c_str());
                    gx_->throw_on_error();
                }
                void qa_dip_az_survey(GXDBPtr param1, GXWAPtr param2, int32_t param3, const gx_string_type& param4)
                {
                    QADipAzSurvey_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }
                void qa_east_north_curvature(GXWAPtr param1, double param2)
                {
                    QAEastNorthCurvature_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }
                void qa_east_north_curvature2(GXWAPtr param1, double param2, const gx_string_type& param3)
                {
                    QAEastNorthCurvature2_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, param3.c_str());
                    gx_->throw_on_error();
                }
                void qa_east_north_survey(GXDBPtr param1, GXWAPtr param2, int32_t param3, const gx_string_type& param4)
                {
                    QAEastNorthSurvey_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }
                void qa_from_to_data(GXDBPtr param1, GXWAPtr param2, int32_t param3, const gx_string_type& param4)
                {
                    QAFromToData_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }
                void qa_point_data(GXDBPtr param1, GXWAPtr param2, int32_t param3, const gx_string_type& param4)
                {
                    QAPointData_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }
                void qa_write_unregistered_holes(GXDBPtr param1, GXWAPtr param2)
                {
                    QAWriteUnregisteredHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void replot_holes(const gx_string_type& param1, int32_t param2)
                {
                    ReplotHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void plot_holes_on_section(const gx_string_type& param1, int32_t param2, const gx_string_type& param3)
                {
                    PlotHolesOnSection_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                void re_survey_east_north(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, double param6, double param7, double param8, double param9, double& param10)
                {
                    ReSurveyEastNorth_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                }
                void re_survey_pol_fit(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7, double param8, double param9, double param10, int32_t param11, int32_t param12, GXVVPtr param13, GXVVPtr param14, GXVVPtr param15, GXVVPtr param16)
                {
                    ReSurveyPolFit_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7, &param8, &param9, &param10, reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)), reinterpret_cast<const long*>(&gx_->handle(param16)));
                    gx_->throw_on_error();
                }
                void re_survey_rad_curve(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7, double param8, double param9, double param10, int32_t param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14, GXVVPtr param15)
                {
                    ReSurveyRadCurve_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7, &param8, &param9, &param10, reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)));
                    gx_->throw_on_error();
                }
                void re_survey_straight(const gx_string_type& param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, int32_t param10, GXVVPtr param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14)
                {
                    ReSurveyStraight_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)));
                    gx_->throw_on_error();
                }
                void re_survey_straight_seg(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7, double param8, double param9, double param10, int32_t param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14, GXVVPtr param15)
                {
                    ReSurveyStraightSeg_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7, &param8, &param9, &param10, reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)));
                    gx_->throw_on_error();
                }
                void save_data_parameters_ini(GXDBPtr param1, const gx_string_type& param2)
                {
                    SaveDataParametersINI_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void save_job(const gx_string_type& param1, int32_t param2)
                {
                    SaveJob_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void save_select(const gx_string_type& param1)
                {
                    SaveSelect_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void section_window_size_mm(double& param1, double& param2)
                {
                    SectionWindowSizeMM_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void select_all_holes()
                {
                    SelectAllHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void select_holes(GXVVPtr param1, int32_t param2)
                {
                    SelectHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void select_name(const gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    SelectName_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void select_ply(GXPLYPtr param1)
                {
                    SelectPLY_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void select_ply2(GXPLYPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    SelectPLY2_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void set_crooked_section_ipj(GXIPJPtr param1)
                {
                    SetCrookedSectionIPJ_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_current_view_name(const gx_string_type& param1)
                {
                    SetCurrentViewName_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_info(int32_t param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    SetInfo_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_map(GXMAPPtr param1)
                {
                    SetMAP_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_new_ipj(const gx_string_type& param1)
                {
                    SetNewIPJ_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_selected_holes_vv(GXVVPtr param1, int32_t param2)
                {
                    SetSelectedHolesVV_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void set_template_blob(GXDBPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetTemplateBlob_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void update_template_blob(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    UpdateTemplateBlob_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void significant_intersections_db(GXDBPtr param1, GXDBPtr param2, int32_t param3, const gx_string_type& param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11)
                {
                    SignificantIntersectionsDB_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str(), &param5, &param6, &param7, &param8, &param9, &param10, &param11);
                    gx_->throw_on_error();
                }
                void test_import_las(const gx_string_type& param1, const gx_string_type& param2, double param3, GXWAPtr param4, int32_t& param5)
                {
                    TestImportLAS_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                }
                void un_select_all_holes()
                {
                    UnSelectAllHoles_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void un_selected_hole_lst(GXLSTPtr param1)
                {
                    UnSelectedHoleLST_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void update_collar_table()
                {
                    UpdateCollarTable_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void update_hole_extent(int32_t param1)
                {
                    UpdateHoleExtent_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void wholeplot(const gx_string_type& param1, int32_t param2)
                {
                    Wholeplot_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void surface_intersections(GXDBPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    SurfaceIntersections_DH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void get_mx_deposit_rights_info(int32_t& param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4, gx_string_type& param5, gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize6 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    param3.resize(STR_DEFAULT_LONG);
                    param4.resize(STR_DEFAULT_LONG);
                    param5.resize(STR_DEFAULT_LONG);
                    param6.resize(STR_DEFAULT_LONG);
                    GetMXDepositRightsInfo_DH(
                        gx_->pGeo, reinterpret_cast<long*>(&param1), (gx_string_char_type*)param2.data(), (gx_string_char_type*)param3.data(), (gx_string_char_type*)param4.data(), (gx_string_char_type*)param5.data(), (gx_string_char_type*)param6.data(), reinterpret_cast<const long*>(&paramSize6 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param5.resize(gx_string_len(param5.c_str()));
                    param6.resize(gx_string_len(param6.c_str()));
                }
                static void navigate_to_mx_deposit(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NavigateToMXDeposit_DH(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXDMPPLY
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDMPPLY(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDMPPLYPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDMPPLY>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void clear()
                {
                    _Clear_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void copy(GXDMPPLYPtr param1)
                {
                    Copy_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXDMPPLYPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_DMPPLY(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDMPPLY>(ret);
                }
                ~GXDMPPLY()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_azimuth(int32_t param1, double& param2)
                {
                    GetAzimuth_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                void get_extents(int32_t param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetExtents_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void get_joins(int32_t param1, GXVVPtr param2)
                {
                    GetJoins_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void get_normal_vectors(int32_t param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10)
                {
                    GetNormalVectors_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                }
                void get_poly(int32_t param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GetPoly_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void get_swing(int32_t param1, double& param2)
                {
                    GetSwing_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                void get_vertex(int32_t param1, int32_t param2, double& param3, double& param4, double& param5)
                {
                    GetVertex_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                int32_t num_joins()
                {
                    int32_t ret = iNumJoins_DMPPLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t num_polys()
                {
                    int32_t ret = iNumPolys_DMPPLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t num_vertices(int32_t param1)
                {
                    int32_t ret = iNumVertices_DMPPLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void load(const gx_string_type& param1)
                {
                    Load_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void move_vertex(int32_t param1, int32_t param2, double param3, double param4, double param5)
                {
                    MoveVertex_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                void project_poly(int32_t param1, double param2, double param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9)
                {
                    ProjectPoly_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }
                void re_project_poly(int32_t param1, double param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10)
                {
                    ReProjectPoly_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)));
                    gx_->throw_on_error();
                }
                void save(const gx_string_type& param1)
                {
                    Save_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_poly(int32_t param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    SetPoly_DMPPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

            };
            class GXDOCU
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDOCU(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDOCUPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDOCU>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void copy(GXDOCUPtr param1)
                {
                    Copy_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXDOCUPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_DOCU(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDOCU>(ret);
                }
                static GXDOCUPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_DOCU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDOCU>(ret);
                }
                ~GXDOCU()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_file(const gx_string_type& param1)
                {
                    GetFile_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void get_file_meta(const gx_string_type& param1)
                {
                    GetFileMeta_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void get_meta(GXMETAPtr param1)
                {
                    GetMETA_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void doc_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IDocName_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void file_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IFileName_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                int32_t have_meta()
                {
                    int32_t ret = iHaveMETA_DOCU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_reference()
                {
                    int32_t ret = iIsReference_DOCU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void open(int32_t param1)
                {
                    Open_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void serial(GXBFPtr param1)
                {
                    Serial_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_file(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    SetFile_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                void set_file_meta(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    SetFileMeta_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_DOCU(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

            };
            class GXDSEL
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDSEL(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDSELPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDSEL>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXDSELPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_DSEL(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDSEL>(ret);
                }
                void data_significant_figures(double param1)
                {
                    DataSignificantFigures_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                ~GXDSEL()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void meta_query(const gx_string_type& param1)
                {
                    MetaQuery_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void picture_quality(int32_t param1)
                {
                    PictureQuality_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void request_all_info(int32_t param1)
                {
                    RequestAllInfo_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void select_area(GXPLYPtr param1)
                {
                    SelectArea_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void select_rect(double param1, double param2, double param3, double param4)
                {
                    SelectRect_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void select_resolution(double param1, int32_t param2)
                {
                    SelectResolution_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void select_size(int32_t param1, int32_t param2)
                {
                    SelectSize_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_extract_as_document(int32_t param1)
                {
                    SetExtractAsDocument_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_ipj(GXIPJPtr param1, int32_t param2)
                {
                    SetIPJ_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void spatial_accuracy(double param1)
                {
                    SpatialAccuracy_DSEL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

            };
            class GXDU
            {
            private:
                GXDU();
                ~GXDU();
            public:


                static void table_look1(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6, int32_t param7, double param8, GXTBPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    _TableLook1_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str(), reinterpret_cast<const long*>(&param7), &param8, reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }
                static void table_look2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, int32_t param9, double param10, GXTBPtr param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    _TableLook2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str(), param7.c_str(), param8.c_str(), reinterpret_cast<const long*>(&param9), &param10, reinterpret_cast<const long*>(&gx_->handle(param11)));
                    gx_->throw_on_error();
                }
                static void table_look_i2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, int32_t param9, double param10, GXTBPtr param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    _TableLookI2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str(), param7.c_str(), param8.c_str(), reinterpret_cast<const long*>(&param9), &param10, reinterpret_cast<const long*>(&gx_->handle(param11)));
                    gx_->throw_on_error();
                }
                static void table_look_r2(GXDBPtr param1, int32_t param2, double param3, int32_t param4, int32_t param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, int32_t param9, double param10, GXTBPtr param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    _TableLookR2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str(), param7.c_str(), param8.c_str(), reinterpret_cast<const long*>(&param9), &param10, reinterpret_cast<const long*>(&gx_->handle(param11)));
                    gx_->throw_on_error();
                }
                static void ado_table_names(const gx_string_type& param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ADOTableNames_DU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void an_sig(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AnSig_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void append(GXDBPtr param1, GXDBPtr param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Append_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void avg_azimuth(GXDBPtr param1, double param2, double& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AvgAzimuth_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3);
                    gx_->throw_on_error();
                }
                static void avg_azimuth2(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, double param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AvgAzimuth2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), &param4, &param5);
                    gx_->throw_on_error();
                }
                static double average_spacing(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rAverageSpacing_DU(
                                     gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }
                static void base_data(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, GXTBPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BaseData_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static void base_data_ex(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, GXTBPtr param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BaseDataEx_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void bound_line(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXPLYPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BoundLine_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void bp_filt(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, double param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BPFilt_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6, reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void break_line(GXDBPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BreakLine_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void break_line2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BreakLine2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void break_line_to_groups(GXDBPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BreakLineToGroups_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }
                static void break_line_to_groups2(GXDBPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BreakLineToGroups2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void b_spline(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BSpline_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7);
                    gx_->throw_on_error();
                }
                static void closest_point(GXDBPtr param1, double param2, double param3, double& param4, double& param5, int32_t& param6, double& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClosestPoint_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, reinterpret_cast<long*>(&param6), &param7);
                    gx_->throw_on_error();
                }
                static void copy_line(GXDBPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CopyLine_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void copy_line_across(GXDBPtr param1, int32_t param2, GXDBPtr param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CopyLineAcross_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void copy_line_chan_across(GXDBPtr param1, int32_t param2, GXVVPtr param3, GXDBPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CopyLineChanAcross_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void copy_line_masked(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CopyLineMasked_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void dao_table_names(const gx_string_type& param1, const gx_string_type& param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DAOTableNames_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void decimate(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Decimate_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void diff(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Diff_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void distance(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Distance_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void distance_3d(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Distance3D_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void distline(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Distline_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5);
                    gx_->throw_on_error();
                }
                static void dup_chan_locks(GXDBPtr param1, GXDBPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DupChanLocks_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void dup_chans(GXDBPtr param1, GXDBPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DupChans_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void edit_duplicates(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EditDuplicates_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7);
                    gx_->throw_on_error();
                }
                static void export1(GXDBPtr param1, int32_t param2, const gx_string_type& param3, GXVVPtr param4, int32_t param5, const gx_string_type& param6, int32_t param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Export_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), param6.c_str(), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void export2(GXDBPtr param1, int32_t param2, const gx_string_type& param3, GXVVPtr param4, int32_t param5, const gx_string_type& param6, int32_t param7, int32_t param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Export2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), param6.c_str(), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                static void export_amira(GXDBPtr param1, GXWAPtr param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, const gx_string_type& param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportAMIRA_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), param11.c_str());
                    gx_->throw_on_error();
                }
                static void export_aseg(GXDBPtr param1, const gx_string_type& param2, GXVVPtr param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportAseg_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }
                static void export_aseg_proj(GXDBPtr param1, const gx_string_type& param2, GXVVPtr param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, GXIPJPtr param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportAsegProj_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str(), param7.c_str(), reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                }
                static void export_chan_crc(GXDBPtr param1, int32_t param2, int32_t& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportChanCRC_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }
                static void export_csv(GXDBPtr param1, const gx_string_type& param2, GXVVPtr param3, int32_t param4, const gx_string_type& param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportCSV_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), param5.c_str(), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void export_database_crc(GXDBPtr param1, int32_t& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportDatabaseCRC_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                static void export_gbn(GXDBPtr param1, GXVVPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportGBN_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }
                static void export_mdb(GXDBPtr param1, const gx_string_type& param2, GXVVPtr param3, int32_t param4, int32_t param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportMDB_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str());
                    gx_->throw_on_error();
                }
                static void export_geodatabase(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXVVPtr param4, int32_t param5, int32_t param6, int32_t param7, const gx_string_type& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportGeodatabase_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), param8.c_str());
                    gx_->throw_on_error();
                }
                static int32_t get_existing_feature_classes_in_geodatabase(GXDBPtr param1, const gx_string_type& param2, GXLSTPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GetExistingFeatureClassesInGeodatabase_DU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }
                static void export_shp(GXDBPtr param1, const gx_string_type& param2, GXVVPtr param3, int32_t param4, int32_t param5, const gx_string_type& param6, GXLSTPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportSHP_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str(), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                static void export_xyz(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportXYZ_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void export_xyz2(GXDBPtr param1, GXWAPtr param2, GXRAPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportXYZ2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void fft(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FFT_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void filter(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXFLTPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Filter_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void gen_lev(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, double param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenLev_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void gen_lev_db(GXDBPtr param1, const gx_string_type& param2, double param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenLevDB_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void gen_xyz_temp(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenXYZTemp_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void get_xyz_num_fields(const gx_string_type& param1, int32_t& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetXYZNumFields_DU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }
                static void get_chan_data_lst(GXDBPtr param1, int32_t param2, int32_t param3, GXLSTPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetChanDataLST_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void get_chan_data_vv(GXDBPtr param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetChanDataVV_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static double get_gridding_azimuth_to_minimize_padding(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rGetGriddingAzimuthToMinimizePadding_DU(
                                     gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_angled_bounding_rectangle(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetAngledBoundingRectangle_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13);
                    gx_->throw_on_error();
                }
                static void gradient(GXDBPtr param1, GXDBPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, int32_t param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Gradient_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11);
                    gx_->throw_on_error();
                }
                static void grav_drift(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GravDrift_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void grav_drift2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GravDrift2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void grav_tide(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GravTide_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void grid_load(GXDBPtr param1, GXIMGPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridLoad_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void grid_load_xyz(GXDBPtr param1, GXIMGPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, int32_t param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridLoadXYZ_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }
                static void head(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXTBPtr param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Head_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), &param6);
                    gx_->throw_on_error();
                }
                static void import_bin3(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4, int32_t param5, double param6, GXWAPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param4.resize(STR_VERY_LONG);
                    IImportBIN3_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ), reinterpret_cast<const long*>(&param5), &param6, reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }
                static void imp_cb_ply(GXDBPtr param1, GXPJPtr param2, const gx_string_type& param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImpCBPly_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void import_ado(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportADO_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                }
                static void import_all_ado(GXDBPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportAllADO_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void import_all_dao(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportAllDAO_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void import_amira(GXDBPtr param1, GXRAPtr param2, GXWAPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportAMIRA_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void import_aseg(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportAseg_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void import_aseg_proj(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportAsegProj_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6), param7.c_str(), param8.c_str(), param9.c_str());
                    gx_->throw_on_error();
                }
                static void import_bin(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportBIN_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), &param6);
                    gx_->throw_on_error();
                }
                static void import_bin2(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, double param6, GXWAPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportBIN2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                static void import_bin4(GXDBPtr param1, int32_t param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6, double param7, GXWAPtr param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportBIN4_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                }
                static void import_daarc500_serial(GXDBPtr param1, int32_t param2, const gx_string_type& param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportDAARC500Serial_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void import_daarc500_serial_gps(GXDBPtr param1, int32_t param2, const gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportDAARC500SerialGPS_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void import_dao(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportDAO_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }
                static void import_esri(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportESRI_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                static void import_gbn(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportGBN_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void import_oddf(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportODDF_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void import_pico(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportPico_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void import_ubc_mod_msh(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportUBCModMsh_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), &param5);
                    gx_->throw_on_error();
                }
                static void import_usgs_post(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportUSGSPost_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void import_xyz(GXDBPtr param1, int32_t param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportXYZ_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                static void import_xyz2(GXDBPtr param1, int32_t param2, const gx_string_type& param3, const gx_string_type& param4, GXWAPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportXYZ2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void import_io_gas(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportIoGAS_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void index_order(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IndexOrder_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void interp(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Interp_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void interp_gap(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    InterpGap_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void interp_gap_and_fill(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    InterpGapAndFill_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), &param9);
                    gx_->throw_on_error();
                }
                static void intersect(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Intersect_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, param6.c_str());
                    gx_->throw_on_error();
                }
                static void intersect_all(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IntersectAll_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, param6.c_str());
                    gx_->throw_on_error();
                }
                static void intersect_gd_bto_tbl(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IntersectGDBtoTBL_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void intersect_old(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IntersectOld_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }
                static void intersect_tb_lto_gdb(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IntersectTBLtoGDB_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void lab_template(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, const gx_string_type& param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LabTemplate_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                static void load_gravity(GXDBPtr param1, GXREGPtr param2, int32_t param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadGravity_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }
                static void load_gravity_cg6(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadGravityCG6_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void load_gravity_cg6_to_line(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadGravityCG6ToLine_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void load_gravity_cg6_ex(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadGravityCG6Ex_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void load_ltb(GXDBPtr param1, int32_t param2, GXLTBPtr param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadLTB_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void make_fid(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MakeFid_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void mask(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Mask_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void math(GXDBPtr param1, int32_t param2, GXEXPPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Math_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void merge_line(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MergeLine_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void mod_fid_range(GXDBPtr param1, int32_t param2, double param3, double param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ModFidRange_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void move(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Move_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void nl_filt(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NLFilt_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6);
                    gx_->throw_on_error();
                }
                static void normal(GXDBPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Normal_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void poly_fill(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, GXPLYPtr param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PolyFill_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void poly_mask(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, GXPLYPtr param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PolyMask_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void project_data(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, GXPJPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProjectData_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                static void project_xyz(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, GXPJPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProjectXYZ_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }
                static void proj_points(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, int32_t param9, int32_t param10, int32_t param11, int32_t param12, int32_t param13, int32_t param14, int32_t param15, int32_t param16, int32_t param17, int32_t param18, int32_t param19, int32_t param20)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProjPoints_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13), reinterpret_cast<const long*>(&param14), reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&param20));
                    gx_->throw_on_error();
                }
                static void qc_init_separation(GXDBPtr param1, double param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    QCInitSeparation_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3);
                    gx_->throw_on_error();
                }
                static int32_t qc_survey_plan(GXDBPtr param1, GXWAPtr param2, GXPLYPtr param3, double param4, double param5, double param6, double param7, int32_t param8, int32_t param9, double param10, double param11, double param12, double param13, int32_t param14, int32_t param15, int32_t param16, double param17, double param18)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = QCSurveyPlan_DU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11, &param12, &param13, reinterpret_cast<const long*>(&param14), reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), &param17, &param18);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t qc_survey_plan2(GXDBPtr param1, GXWAPtr param2, GXPLYPtr param3, double param4, double param5, double param6, double param7, int32_t param8, int32_t param9, double param10, double param11, double param12, double param13, int32_t param14, int32_t param15, int32_t param16, double param17, double param18)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = QCSurveyPlan2_DU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11, &param12, &param13, reinterpret_cast<const long*>(&param14), reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), &param17, &param18);
                    gx_->throw_on_error();
                    return ret;
                }
                static double direction(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rDirection_DU(
                                     gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }
                static void re_fid(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7, double param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReFid_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8, &param9);
                    gx_->throw_on_error();
                }
                static void re_fid_all_ch(GXDBPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReFidAllCh_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void re_fid_ch(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReFidCh_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void rotate(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7, double param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Rotate_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8, &param9);
                    gx_->throw_on_error();
                }
                static void sample_gd(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, GXGDPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SampleGD_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static void sample_img(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, GXIMGPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SampleIMG_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static void sample_img_line_lst(GXDBPtr param1, GXLSTPtr param2, int32_t param3, int32_t param4, int32_t param5, GXIMGPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SampleIMGLineLST_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static void scan_ado(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ScanADO_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void scan_aseg(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ScanAseg_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                static void scan_dao(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ScanDAO_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                static void scan_pico(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ScanPico_DU(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void sort(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Sort_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void sort_index(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SortIndex_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void sort_index2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SortIndex2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void sort_index_n(GXDBPtr param1, int32_t param2, GXVVPtr param3, GXVVPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SortIndexN_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void split_line(GXDBPtr param1, int32_t param2, int32_t param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SplitLine_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }
                static void split_line2(GXDBPtr param1, int32_t param2, int32_t param3, double param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SplitLine2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void split_line_xy(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6, double param7, int32_t param8, int32_t& param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SplitLineXY_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<long*>(&param9), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }
                static void split_line_xy2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6, double param7, int32_t param8, int32_t& param9, int32_t param10, int32_t param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SplitLineXY2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                }
                static void split_line_xy3(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6, double param7, int32_t param8, int32_t& param9, int32_t param10, int32_t param11, int32_t param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SplitLineXY3_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                }
                static void split_line_by_direction(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, double param6, double param7, double param8, int32_t param9, int32_t param10, int32_t& param11, int32_t param12, int32_t param13)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SplitLineByDirection_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13));
                    gx_->throw_on_error();
                }
                static void split_line_by_direction2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, double param6, double param7, double param8, int32_t param9, int32_t param10, int32_t& param11, int32_t param12, int32_t param13, int32_t param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SplitLineByDirection2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13), reinterpret_cast<const long*>(&param14));
                    gx_->throw_on_error();
                }
                static void stat(GXDBPtr param1, int32_t param2, int32_t param3, GXSTPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Stat_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void table_line_fid(GXDBPtr param1, int32_t param2, int32_t param3, GXTBPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TableLineFid_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void table_selected_lines_fid(GXDBPtr param1, int32_t param2, int32_t param3, GXTBPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TableSelectedLinesFid_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void time_constant(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TimeConstant_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void trend(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Trend_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void update_intersect_db(GXDBPtr param1, int32_t param2, int32_t param3, GXDBPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    UpdateIntersectDB_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void voxel_section(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXVOXPtr param5, const gx_string_type& param6, double param7, double param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    VoxelSection_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), param6.c_str(), &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                static void write_wa(GXDBPtr param1, int32_t param2, GXLSTPtr param3, GXWAPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    WriteWA_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void xyz_line(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    XyzLine_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6);
                    gx_->throw_on_error();
                }
                static void xyz_line2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    XyzLine2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7);
                    gx_->throw_on_error();
                }
                static void xyz_line3(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6, double param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    XyzLine3_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void z_mask(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ZMask_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6);
                    gx_->throw_on_error();
                }
                static void range_xy(GXDBPtr param1, double& param2, double& param3, double& param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RangeXY_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                static void range_xyz(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, int32_t& param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RangeXYZ_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, &param9, &param10, reinterpret_cast<long*>(&param11));
                    gx_->throw_on_error();
                }
                static void range_xyz_data(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13, int32_t& param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RangeXYZData_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, reinterpret_cast<long*>(&param14));
                    gx_->throw_on_error();
                }
                static void create_drillhole_parameter_weight_constraint_database(GXDBPtr param1, int32_t param2, GXREGPtr param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateDrillholeParameterWeightConstraintDatabase_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str());
                    gx_->throw_on_error();
                }
                static void calculate_draped_survey_altitude(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXIMGPtr param5, int32_t param6, double param7, double param8, double param9, int32_t param10, double param11, double param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CalculateDrapedSurveyAltitude_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), &param11, &param12);
                    gx_->throw_on_error();
                }
                static void calculate_draped_survey_altitude2(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXIMGPtr param5, int32_t param6, int32_t param7, double param8, double param9, double param10, double param11, int32_t param12, double param13, double param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CalculateDrapedSurveyAltitude2_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), &param8, &param9, &param10, &param11, reinterpret_cast<const long*>(&param12), &param13, &param14);
                    gx_->throw_on_error();
                }
                static void direct_grid_data_to_voxel(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, const gx_string_type& param6, double param7, double param8, double param9, int32_t param10, int32_t param11, int32_t param12, double param13, double param14, double param15, int32_t param16)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DirectGridDataToVoxel_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str(), &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), &param13, &param14, &param15, reinterpret_cast<const long*>(&param16));
                    gx_->throw_on_error();
                }
                static void direct_grid_item_counts_to_voxel(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, const gx_string_type& param6, double param7, double param8, double param9, int32_t param10, int32_t param11, int32_t param12, double param13, double param14, double param15, int32_t param16)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DirectGridItemCountsToVoxel_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str(), &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), &param13, &param14, &param15, reinterpret_cast<const long*>(&param16));
                    gx_->throw_on_error();
                }
                static int32_t em_tau_automatic(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4, double param5, double param6, double param7, int32_t param8, int32_t& param9, double& param10, double& param11, double& param12, int32_t& param13, GXVVPtr param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iEMTauAutomatic_DU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<long*>(&param9), &param10, &param11, &param12, reinterpret_cast<long*>(&param13), reinterpret_cast<const long*>(&gx_->handle(param14)));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t em_tau_calc(GXVVPtr param1, GXVVPtr param2, double param3, double param4, double param5, int32_t param6, int32_t& param7, double& param8, double& param9, double& param10, int32_t& param11, GXVVPtr param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iEMTauCalc_DU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, reinterpret_cast<const long*>(&param6), reinterpret_cast<long*>(&param7), &param8, &param9, &param10, reinterpret_cast<long*>(&param11), reinterpret_cast<const long*>(&gx_->handle(param12)));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t em_tau_late_time(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4, int32_t param5, double param6, double param7, double param8, double param9, int32_t param10, int32_t& param11, double& param12, double& param13, double& param14, int32_t& param15, GXVVPtr param16)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iEMTauLateTime_DU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<long*>(&param11), &param12, &param13, &param14, reinterpret_cast<long*>(&param15), reinterpret_cast<const long*>(&gx_->handle(param16)));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t em_tau_manual(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, double param6, double param7, double param8, int32_t param9, int32_t& param10, double& param11, double& param12, double& param13, int32_t& param14, GXVVPtr param15)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iEMTauManual_DU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<long*>(&param10), &param11, &param12, &param13, reinterpret_cast<long*>(&param14), reinterpret_cast<const long*>(&gx_->handle(param15)));
                    gx_->throw_on_error();
                    return ret;
                }
                static void em_tau_trend_window(GXVVPtr param1, GXVVPtr param2, int32_t param3, GXVVPtr param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EMTauTrendWindow_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void footprint_coverage_static(GXDATPtr param1, GXPLYPtr param2, double param3, int32_t param4, double param5, double& param6, double& param7, GXMPLYPtr param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FootprintCoverageStatic_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                }
                static void footprint_coverage_dynamic(GXDATPtr param1, GXPLYPtr param2, const gx_string_type& param3, int32_t param4, double param5, double& param6, double& param7, GXMPLYPtr param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FootprintCoverageDynamic_DU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                }

            };
            class GXDXFI
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXDXFI(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXDXFIPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXDXFI>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXDXFIPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_DXFI(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDXFI>(ret);
                }
                ~GXDXFI()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_DXFI(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                static void dxf2_ply(GXPLYPtr param1, GXDXFIPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DXF2PLY_DXFI(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void dxf2_view_ex(GXMVIEWPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, int32_t param5, int32_t param6)
                {
                    DXF2ViewEx_DXFI(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                void dxf2_view_no_surfaces(GXMVIEWPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, int32_t param5, int32_t param6)
                {
                    DXF2ViewNoSurfaces_DXFI(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                void get_range(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetRange_DXFI(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

            };
            class GXE3DV
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXE3DV(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXE3DVPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXE3DV>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                GXMVIEWPtr get_data_view()
                {
                    int32_t ret = GetDataView_E3DV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMVIEW>(ret);
                }
                GXMVIEWPtr get_base_view()
                {
                    int32_t ret = GetBaseView_E3DV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMVIEW>(ret);
                }

            };
            class GXEDB
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXEDB(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXEDBPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXEDB>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void apply_formula_internal(const gx_string_type& param1)
                {
                    App_ApplyFormulaInternal_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                static GXEDBPtr current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Current_EDB(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }
                static GXEDBPtr current_no_activate()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentNoActivate_EDB(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }
                static GXEDBPtr current_if_exists()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentIfExists_EDB(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }
                void del_line0()
                {
                    App_DelLine0_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                ~GXEDB()
                {
                    if (handle_ == 0)
                        return;
                    App_Destroy_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void destroy_view(int32_t param1)
                {
                    App_DestroyView_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                int32_t get_cur_chan_symb()
                {
                    int32_t ret = App_GetCurChanSymb_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_cur_line_symb()
                {
                    int32_t ret = App_GetCurLineSymb_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_displ_fid_range(int32_t& param1, int32_t& param2)
                {
                    App_GetDisplFidRange_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }
                void get_cur_point(double& param1, double& param2, double& param3)
                {
                    App_GetCurPoint_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                void get_fid_range(double& param1, double& param2, int32_t& param3)
                {
                    App_GetFidRange_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }
                int32_t get_next_line_symb()
                {
                    int32_t ret = App_GetNextLineSymb_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_prev_line_symb()
                {
                    int32_t ret = App_GetPrevLineSymb_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_profile_x_axis_options(int32_t& param1, int32_t& param2, double& param3)
                {
                    App_GetProfileXAxisOptions_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), &param3);
                    gx_->throw_on_error();
                }
                void set_profile_x_axis_options(int32_t param1, int32_t param2, double param3)
                {
                    App_SetProfileXAxisOptions_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }
                void get_profile_range_x(double& param1, double& param2, int32_t& param3)
                {
                    App_GetProfileRangeX_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }
                void get_profile_range_y(int32_t param1, int32_t param2, double& param3, double& param4, int32_t& param5)
                {
                    App_GetProfileRangeY_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, &param4, reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                }
                void get_profile_split(double& param1, double& param2)
                {
                    App_GetProfileSplit_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void get_profile_split5(double& param1, double& param2, double& param3, double& param4)
                {
                    App_GetProfileSplit5_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void get_profile_split_vv(GXVVPtr param1)
                {
                    App_GetProfileSplitVV_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_profile_vertical_grid_lines(int32_t& param1, double& param2)
                {
                    App_GetProfileVerticalGridLines_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                void get_profile_window(int32_t param1, int32_t& param2, int32_t& param3)
                {
                    App_GetProfileWindow_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }
                void goto_column(int32_t param1)
                {
                    App_GotoColumn_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void goto_elem(int32_t param1)
                {
                    App_GotoElem_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void goto_line(int32_t param1)
                {
                    App_GotoLine_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void histogram(GXSTPtr param1, double param2, double param3, int32_t param4)
                {
                    App_Histogram_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                int32_t all_chan_list(GXVVPtr param1)
                {
                    int32_t ret = App_iAllChanList_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t channels()
                {
                    int32_t ret = App_iChannels_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t disp_chan_list(GXVVPtr param1)
                {
                    int32_t ret = App_iDispChanList_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t disp_chan_lst(GXLSTPtr param1)
                {
                    int32_t ret = App_iDispChanLST_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t disp_class_chan_lst(GXLSTPtr param1, const gx_string_type& param2)
                {
                    int32_t ret = App_iDispClassChanLST_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t find_channel_column(const gx_string_type& param1)
                {
                    int32_t ret = App_iFindChannelColumn_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t find_nearest(double& param1, double& param2, double& param3, GXIPJPtr param4)
                {
                    int32_t ret = App_iFindNearest_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_cur_chan(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param1.resize(STR_DB_SYMBOL);
                    App_IGetCurChan_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_cur_fid_string(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param1.resize(STR_DB_SYMBOL);
                    App_IGetCurFidString_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_cur_line(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param1.resize(STR_DB_SYMBOL);
                    App_IGetCurLine_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                int32_t get_cur_mark(double& param1, double& param2, double& param3)
                {
                    int32_t ret = App_iGetCurMark_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }
                void get_current_selection(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    int32_t paramSize8 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    param2.resize(STR_DB_SYMBOL);
                    param3.resize(STR_DB_SYMBOL);
                    param4.resize(STR_DB_SYMBOL);
                    App_IGetCurrentSelection_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize6 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize8 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                }
                static int32_t get_databases_lst(GXLSTPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iGetDatabasesLST_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_mark_chan_vv(GXVVPtr param1, int32_t param2)
                {
                    int32_t ret = App_iGetMarkChanVV_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_mark_chan_va(GXVAPtr param1, int32_t param2)
                {
                    int32_t ret = App_iGetMarkChanVA_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    App_IGetName_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                int32_t get_profile_parm_int(int32_t param1, int32_t param2, int32_t param3)
                {
                    int32_t ret = App_iGetProfileParm_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_window_state()
                {
                    int32_t ret = App_iGetWindowState_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t have_current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iHaveCurrent_EDB(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_locked()
                {
                    int32_t ret = App_iIsLocked_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t loaded(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iLoaded_EDB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t profile_open(int32_t param1)
                {
                    int32_t ret = App_iProfileOpen_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t read_only()
                {
                    int32_t ret = App_iReadOnly_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_window_position(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5, int32_t& param6)
                {
                    App_GetWindowPosition_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                }
                void set_window_position(int32_t param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    App_SetWindowPosition_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                int32_t show_profile_name(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = App_iShowProfileName_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t profile_shown(const gx_string_type& param1)
                {
                    int32_t ret = App_iProfileShown_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_window_y_axis_direction(int32_t param1)
                {
                    int32_t ret = App_iGetWindowYAxisDirection_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t window_profiles(int32_t param1)
                {
                    int32_t ret = App_iWindowProfiles_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void launch_histogram(const gx_string_type& param1)
                {
                    LaunchHistogram_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void launch_scatter()
                {
                    LaunchScatter_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static GXEDBPtr load(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Load_EDB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }
                static GXEDBPtr load_no_activate(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadNoActivate_EDB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }
                void load_all_chans()
                {
                    App_LoadAllChans_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void load_chan(const gx_string_type& param1)
                {
                    App_LoadChan_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                static GXEDBPtr load_new(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadNew_EDB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }
                static GXEDBPtr load_pass(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadPass_EDB(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }
                static GXEDBPtr load_with_view(const gx_string_type& param1, GXEDBPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadWithView_EDB(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDB>(ret);
                }
                GXDBPtr lock()
                {
                    int32_t ret = App_Lock_EDB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDB>(ret);
                }
                void make_current()
                {
                    App_MakeCurrent_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void remove_profile(int32_t param1, int32_t param2)
                {
                    App_RemoveProfile_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                double get_cur_fid()
                {
                    double ret = App_rGetCurFid_EDB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_profile_parm_double(int32_t param1, int32_t param2, int32_t param3)
                {
                    double ret = App_rGetProfileParm_EDB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_split()
                {
                    double ret = App_rGetSplit_EDB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void run_channel_maker(const gx_string_type& param1)
                {
                    App_RunChannelMaker_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void run_channel_makers()
                {
                    App_RunChannelMakers_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void set_cur_line(const gx_string_type& param1)
                {
                    App_SetCurLine_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_cur_line_no_message(const gx_string_type& param1)
                {
                    App_SetCurLineNoMessage_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_cur_mark(double param1, double param2)
                {
                    App_SetCurMark_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void set_profile_parm_i(int32_t param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    App_SetProfileParmI_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void set_profile_parm_r(int32_t param1, int32_t param2, int32_t param3, double param4)
                {
                    App_SetProfileParmR_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }
                void set_profile_range_x(double param1, double param2, int32_t param3)
                {
                    App_SetProfileRangeX_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void set_profile_range_y(int32_t param1, int32_t param2, double param3, double param4, int32_t param5)
                {
                    App_SetProfileRangeY_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                void profile_rescale_all(int32_t param1)
                {
                    App_ProfileRescaleAll_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_profile_split(double param1, double param2)
                {
                    App_SetProfileSplit_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void set_profile_split5(double param1, double param2, double param3, double param4)
                {
                    App_SetProfileSplit5_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void set_profile_split_vv(GXVVPtr param1)
                {
                    App_SetProfileSplitVV_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_split(double param1)
                {
                    App_SetSplit_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_window_state(int32_t param1)
                {
                    App_SetWindowState_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void show_profile(int32_t param1, int32_t param2)
                {
                    App_ShowProfile_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void statistics(GXSTPtr param1)
                {
                    App_Statistics_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void un_load(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoad_EDB(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void un_load_all()
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadAll_EDB(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                void un_load_all_chans()
                {
                    App_UnLoadAllChans_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void un_load_chan(const gx_string_type& param1)
                {
                    App_UnLoadChan_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                static void un_load_discard(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadDiscard_EDB(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void un_load_verify(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadVerify_EDB(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void un_lock()
                {
                    App_UnLock_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static void load_control(const gx_string_type& param1, HWND param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LoadControl_EDB(
                        gx_->pGeo, param1.c_str(), param2);
                    gx_->throw_on_error();
                }
                static void load_new_control(const gx_string_type& param1, HWND param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LoadNewControl_EDB(
                        gx_->pGeo, param1.c_str(), param2);
                    gx_->throw_on_error();
                }
                static void load_pass_control(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, HWND param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LoadPassControl_EDB(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4);
                    gx_->throw_on_error();
                }
                static void load_with_view_control(const gx_string_type& param1, GXEDBPtr param2, HWND param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LoadWithViewControl_EDB(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), param3);
                    gx_->throw_on_error();
                }
                void load_channel_after(const gx_string_type& param1, const gx_string_type& param2)
                {
                    App_LoadChannelAfter_EDB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXEDOC
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXEDOC(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXEDOCPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXEDOC>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXEDOCPtr create_new_gms_3d(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CreateNewGMS3D_EDOC(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDOC>(ret);
                }
                static GXEDOCPtr current(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Current_EDOC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDOC>(ret);
                }
                static GXEDOCPtr current_no_activate(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentNoActivate_EDOC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDOC>(ret);
                }
                static GXEDOCPtr current_if_exists(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentIfExists_EDOC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDOC>(ret);
                }
                ~GXEDOC()
                {
                    if (handle_ == 0)
                        return;
                    App_Destroy_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                static int32_t get_documents_lst(GXLSTPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iGetDocumentsLST_EDOC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    App_IGetName_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                int32_t get_window_state()
                {
                    int32_t ret = App_iGetWindowState_EDOC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t have_current(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iHaveCurrent_EDOC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t loaded(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iLoaded_EDOC(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_window_position(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5, int32_t& param6)
                {
                    App_GetWindowPosition_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                }
                void set_window_position(int32_t param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    App_SetWindowPosition_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                int32_t read_only()
                {
                    int32_t ret = App_iReadOnly_EDOC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                static GXEDOCPtr load(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Load_EDOC(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDOC>(ret);
                }
                static GXEDOCPtr load_no_activate(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadNoActivate_EDOC(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEDOC>(ret);
                }
                void make_current()
                {
                    App_MakeCurrent_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void set_window_state(int32_t param1)
                {
                    App_SetWindowState_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static void sync(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_Sync_EDOC(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void sync_open()
                {
                    App_SyncOpen_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static void un_load(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoad_EDOC(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void un_load_all(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadAll_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static void un_load_discard(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadDiscard_EDOC(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void un_load_verify(const gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadVerify_EDOC(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                int32_t copy(const gx_string_type& param1)
                {
                    int32_t ret = App_iCopy_EDOC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void save()
                {
                    App_Save_EDOC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

            };
            class GXEMAP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXEMAP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXEMAPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXEMAP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void drop_map_clip_data(int32_t param1)
                {
                    App_DropMapClipData_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                int32_t drag_drop_enabled()
                {
                    int32_t ret = App_iDragDropEnabled_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_drag_drop_enabled(int32_t param1)
                {
                    App_SetDragDropEnabled_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void copy_to_clip()
                {
                    App_CopyToClip_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void draw_line(double param1, double param2, double param3, double param4)
                {
                    App_DrawLine_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void draw_rect(double param1, double param2, double param3, double param4)
                {
                    App_DrawRect_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void draw_rect_3d(double param1, double param2, double param3, int32_t param4)
                {
                    App_DrawRect3D_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void draw_ply(GXPLYPtr param1)
                {
                    App_DrawPLY_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_display_area(double& param1, double& param2, double& param3, double& param4)
                {
                    App_GetDisplayArea_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void get_display_area_raw(double& param1, double& param2, double& param3, double& param4)
                {
                    App_GetDisplayAreaRaw_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void get_map_layout_props(int32_t& param1, double& param2, int32_t& param3, int32_t& param4, int32_t& param5, int32_t& param6, int32_t& param7, int32_t& param8)
                {
                    App_GetMapLayoutProps_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6), reinterpret_cast<long*>(&param7), reinterpret_cast<long*>(&param8));
                    gx_->throw_on_error();
                }
                void get_map_snap(double& param1)
                {
                    App_GetMapSnap_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                int32_t get_window_state()
                {
                    int32_t ret = App_iGetWindowState_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_display_area(double param1, double param2, double param3, double param4)
                {
                    App_SetDisplayArea_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void set_map_layout_props(int32_t param1, double param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8)
                {
                    App_SetMapLayoutProps_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                void set_map_snap(double param1)
                {
                    App_SetMapSnap_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_window_state(int32_t param1)
                {
                    App_SetWindowState_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                int32_t packed_files()
                {
                    int32_t ret = App_iPackedFiles_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void activate_group(const gx_string_type& param1)
                {
                    App_ActivateGroup_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void activate_view(const gx_string_type& param1)
                {
                    App_ActivateView_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                static GXEMAPPtr current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Current_EMAP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAP>(ret);
                }
                static GXEMAPPtr current_no_activate()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentNoActivate_EMAP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAP>(ret);
                }
                static GXEMAPPtr current_if_exists()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentIfExists_EMAP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAP>(ret);
                }
                ~GXEMAP()
                {
                    if (handle_ == 0)
                        return;
                    App_Destroy_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void destroy_view(int32_t param1)
                {
                    App_DestroyView_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void font_lst(GXLSTPtr param1, int32_t param2)
                {
                    App_FontLST_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                int32_t change_current_view(const gx_string_type& param1)
                {
                    int32_t ret = App_iChangeCurrentView_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t create_group_snapshot(GXLSTPtr param1)
                {
                    int32_t ret = App_iCreateGroupSnapshot_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_3d_view_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    App_IGet3DViewName_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_current_group(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VIEW_GROUP * STRING_CHAR_SIZE;
                    param1.resize(STR_VIEW_GROUP);
                    App_IGetCurrentGroup_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_current_view(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VIEW * STRING_CHAR_SIZE;
                    param1.resize(STR_VIEW);
                    App_IGetCurrentView_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static int32_t get_maps_lst(GXLSTPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iGetMapsLST_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    App_IGetName_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static int32_t have_current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iHaveCurrent_EMAP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t i_get_specified_map_name(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_iIGetSpecifiedMapName_EMAP(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                int32_t is_grid()
                {
                    int32_t ret = App_iIsGrid_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                static void reload_grid(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ReloadGrid_EMAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                int32_t is_3d_view()
                {
                    int32_t ret = App_iIs3DView_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                GXE3DVPtr get_e_3dv()
                {
                    int32_t ret = App_GetE3DV_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXE3DV>(ret);
                }
                int32_t is_locked()
                {
                    int32_t ret = App_iIsLocked_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t loaded(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iLoaded_EMAP(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t read_only()
                {
                    int32_t ret = App_iReadOnly_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_window_position(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5, int32_t& param6)
                {
                    App_GetWindowPosition_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                }
                void set_window_position(int32_t param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    App_SetWindowPosition_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                int32_t doubleize_group_snapshot(GXLSTPtr param1)
                {
                    int32_t ret = App_iRealizeGroupSnapshot_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t set_current_view(const gx_string_type& param1)
                {
                    int32_t ret = App_iSetCurrentView_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void get_view_ipj(const gx_string_type& param1, GXIPJPtr param2)
                {
                    App_GetViewIPJ_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static GXEMAPPtr load(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Load_EMAP(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAP>(ret);
                }
                static GXEMAPPtr load_no_activate(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadNoActivate_EMAP(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAP>(ret);
                }
                static GXEMAPPtr load_with_view(const gx_string_type& param1, GXEMAPPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadWithView_EMAP(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAP>(ret);
                }
                GXMAPPtr lock()
                {
                    int32_t ret = App_Lock_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAP>(ret);
                }
                void make_current()
                {
                    App_MakeCurrent_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void print_(int32_t param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, double param9, int32_t param10, int32_t param11, int32_t param12, const gx_string_type& param13)
                {
                    App_Print_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), param13.c_str());
                    gx_->throw_on_error();
                }
                void redraw()
                {
                    App_Redraw_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void select_group(const gx_string_type& param1)
                {
                    App_SelectGroup_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_redraw_flag(int32_t param1)
                {
                    App_SetRedrawFlag_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static void un_load(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoad_EMAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void un_load_all()
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadAll_EMAP(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static void un_load_verify(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadVerify_EMAP(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void un_lock()
                {
                    App_UnLock_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void get_cur_point(double& param1, double& param2)
                {
                    App_GetCurPoint_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void get_cur_point_mm(double& param1, double& param2)
                {
                    App_GetCurPointMM_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void get_cursor(double& param1, double& param2)
                {
                    App_GetCursor_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void get_cursor_mm(double& param1, double& param2)
                {
                    App_GetCursorMM_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                int32_t digitize(GXWAPtr param1, GXIMGPtr param2, int32_t param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, int32_t param7)
                {
                    int32_t ret = App_iDigitize_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str(), param5.c_str(), param6.c_str(), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t digitize2(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXIMGPtr param4, const gx_string_type& param5, int32_t param6)
                {
                    int32_t ret = App_iDigitize2_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t digitize_peaks(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXIMGPtr param4, const gx_string_type& param5, int32_t param6)
                {
                    int32_t ret = App_iDigitizePeaks_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t digitize_polygon(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXIMGPtr param4, const gx_string_type& param5, int32_t param6, int32_t param7)
                {
                    int32_t ret = App_iDigitizePolygon_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_box(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = App_iGetBox_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_box2(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9)
                {
                    int32_t ret = App_iGetBox2_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_grid(const gx_string_type& param1, int32_t param2, int32_t param3, double& param4, double& param5, double& param6, double& param7, double& param8)
                {
                    int32_t ret = App_iGetGrid_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_line(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = App_iGetLine_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_line_ex(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = App_iGetLineEx_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_line_xyz(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7)
                {
                    int32_t ret = App_iGetLineXYZ_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_point(const gx_string_type& param1, double& param2, double& param3)
                {
                    int32_t ret = App_iGetPoint_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_point_ex(const gx_string_type& param1, double& param2, double& param3)
                {
                    int32_t ret = App_iGetPointEx_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_point_3d(const gx_string_type& param1, double& param2, double& param3, double& param4)
                {
                    int32_t ret = App_iGetPoint3D_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_poly_line(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3)
                {
                    int32_t ret = App_iGetPolyLine_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_poly_line_xyz(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    int32_t ret = App_iGetPolyLineXYZ_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_rect(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = App_iGetRect_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t track_point(int32_t param1, double& param2, double& param3)
                {
                    int32_t ret = App_iTrackPoint_EMAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }
                void get_aoi_area(double& param1, double& param2, double& param3, double& param4)
                {
                    App_GetAOIArea_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void set_aoi_area(double param1, double param2, double param3, double param4)
                {
                    App_SetAOIArea_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void set_viewport_mode(int32_t param1)
                {
                    App_SetViewportMode_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void get_selected_vertices(GXVVPtr param1, GXVVPtr param2)
                {
                    App_GetSelectedVertices_EMAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static GXEMAPPtr create_virtual(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CreateVirtual_EMAP(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAP>(ret);
                }
                static void load_control(const gx_string_type& param1, HWND param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LoadControl_EMAP(
                        gx_->pGeo, param1.c_str(), param2);
                    gx_->throw_on_error();
                }
                static void load_with_view_control(const gx_string_type& param1, GXEMAPPtr param2, HWND param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LoadWithViewControl_EMAP(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), param3);
                    gx_->throw_on_error();
                }

            };
            class GXEMAPTEMPLATE
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXEMAPTEMPLATE(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXEMAPTEMPLATEPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXEMAPTEMPLATE>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                int32_t drag_drop_enabled()
                {
                    int32_t ret = App_iDragDropEnabled_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_drag_drop_enabled(int32_t param1)
                {
                    App_SetDragDropEnabled_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static GXEMAPTEMPLATEPtr current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Current_EMAPTEMPLATE(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAPTEMPLATE>(ret);
                }
                static GXEMAPTEMPLATEPtr current_no_activate()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentNoActivate_EMAPTEMPLATE(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAPTEMPLATE>(ret);
                }
                static GXEMAPTEMPLATEPtr current_if_exists()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CurrentIfExists_EMAPTEMPLATE(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAPTEMPLATE>(ret);
                }
                ~GXEMAPTEMPLATE()
                {
                    if (handle_ == 0)
                        return;
                    App_Destroy_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                static int32_t get_map_templates_lst(GXLSTPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iGetMapTemplatesLST_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    App_IGetName_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static int32_t have_current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iHaveCurrent_EMAPTEMPLATE(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t i_get_specified_map_name(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_iIGetSpecifiedMapName_EMAPTEMPLATE(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                int32_t is_locked()
                {
                    int32_t ret = App_iIsLocked_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t loaded(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iLoaded_EMAPTEMPLATE(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void get_window_position(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5, int32_t& param6)
                {
                    App_GetWindowPosition_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                }
                void set_window_position(int32_t param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    App_SetWindowPosition_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                int32_t read_only()
                {
                    int32_t ret = App_iReadOnly_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                static GXEMAPTEMPLATEPtr load(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Load_EMAPTEMPLATE(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAPTEMPLATE>(ret);
                }
                static GXEMAPTEMPLATEPtr load_no_activate(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_LoadNoActivate_EMAPTEMPLATE(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAPTEMPLATE>(ret);
                }
                GXMAPTEMPLATEPtr lock()
                {
                    int32_t ret = App_Lock_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAPTEMPLATE>(ret);
                }
                void make_current()
                {
                    App_MakeCurrent_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static void un_load(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoad_EMAPTEMPLATE(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void un_load_all()
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadAll_EMAPTEMPLATE(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static void un_load_verify(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_UnLoadVerify_EMAPTEMPLATE(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void un_lock()
                {
                    App_UnLock_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                int32_t get_box(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = App_iGetBox_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_line(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = App_iGetLine_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_point(const gx_string_type& param1, double& param2, double& param3)
                {
                    int32_t ret = App_iGetPoint_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_rect(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    int32_t ret = App_iGetRect_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t track_point(int32_t param1, double& param2, double& param3)
                {
                    int32_t ret = App_iTrackPoint_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_item_selection(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    int32_t ret = App_iGetItemSelection_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }
                void set_item_selection(const gx_string_type& param1)
                {
                    App_SetItemSelection_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void get_display_area(double& param1, double& param2, double& param3, double& param4)
                {
                    App_GetDisplayArea_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void get_template_layout_props(int32_t& param1, double& param2, int32_t& param3, int32_t& param4, int32_t& param5, int32_t& param6, int32_t& param7, int32_t& param8)
                {
                    App_GetTemplateLayoutProps_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6), reinterpret_cast<long*>(&param7), reinterpret_cast<long*>(&param8));
                    gx_->throw_on_error();
                }
                int32_t get_window_state()
                {
                    int32_t ret = App_iGetWindowState_EMAPTEMPLATE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_display_area(double param1, double param2, double param3, double param4)
                {
                    App_SetDisplayArea_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void set_template_layout_props(int32_t param1, double param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8)
                {
                    App_SetTemplateLayoutProps_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                void set_window_state(int32_t param1)
                {
                    App_SetWindowState_EMAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static GXEMAPTEMPLATEPtr create_virtual(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CreateVirtual_EMAPTEMPLATE(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEMAPTEMPLATE>(ret);
                }

            };
            class GXEUL3
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXEUL3(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXEUL3Ptr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXEUL3>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void destr()
                {
                    _Destr_EUL3(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static GXEUL3Ptr creat(GXIMGPtr param1, GXIMGPtr param2, GXIMGPtr param3, GXIMGPtr param4, int32_t param5, double param6, double param7, double param8, int32_t param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Creat_EUL3(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), &param6, &param7, &param8, reinterpret_cast<const long*>(&param9), &param10, &param11);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEUL3>(ret);
                }
                void get_result(GXVVPtr param1, int32_t param2)
                {
                    GetResult_EUL3(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void write(const gx_string_type& param1)
                {
                    Write_EUL3(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                static int32_t ex_euler_derive(GXVVPtr param1, double param2, GXVVPtr param3, int32_t param4, GXVVPtr param5, GXVVPtr param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = ExEulerDerive_EUL3(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t ex_euler_calc(int32_t param1, double param2, int32_t param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, int32_t param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14, GXVVPtr param15, int32_t param16, GXVVPtr param17, GXVVPtr param18, GXVVPtr param19, GXVVPtr param20)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = ExEulerCalc_EUL3(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), &param2, reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8, &param9, &param10, reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&gx_->handle(param18)), reinterpret_cast<const long*>(&gx_->handle(param19)), reinterpret_cast<const long*>(&gx_->handle(param20)));
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXEXP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXEXP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXEXPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXEXP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXEXPPtr create(GXDBPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_EXP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEXP>(ret);
                }
                static GXEXPPtr create_file(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateFile_EXP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXEXP>(ret);
                }
                ~GXEXP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_EXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

            };
            class GXEXT
            {
            private:
                GXEXT();
                ~GXEXT();
            public:


                static void get_info(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5, GXIPJPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetInfo_EXT(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

            };
            class GXFFT
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXFFT(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXFFTPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXFFT>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_white_noise(double param1, int32_t param2)
                {
                    AddWhiteNoise_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void app_dens(double param1, double param2)
                {
                    AppDens_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void app_susc(double param1)
                {
                    AppSusc_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void band_pass(double param1, double param2, int32_t param3)
                {
                    BandPass_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void b_worth(double param1, double param2, int32_t param3)
                {
                    BWorth_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void rc_filter(double param1, int32_t param2)
                {
                    RCFilter_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void contin(double param1)
                {
                    Contin_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void cos_roll(double param1, double param2, double param3, int32_t param4)
                {
                    CosRoll_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static GXFFTPtr create(GXVVPtr param1, double param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_FFT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXFFT>(ret);
                }
                static GXFFTPtr create_ex(GXVVPtr param1, double param2, int32_t param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateEx_FFT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXFFT>(ret);
                }
                static GXFFTPtr create_ref(GXVVPtr param1, double param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateRef_FFT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXFFT>(ret);
                }
                static GXFFTPtr create_ref_ex(GXVVPtr param1, double param2, int32_t param3, double param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateRefEx_FFT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&param3), &param4, &param5);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXFFT>(ret);
                }
                ~GXFFT()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void gaus(double param1, int32_t param2)
                {
                    Gaus_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void get_vv(GXVVPtr param1, GXVVPtr param2)
                {
                    GetVV_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void h_drv(double param1)
                {
                    HDrv_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void high_pass(double param1, double param2)
                {
                    HighPass_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void h_int()
                {
                    HInt_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void inverse(GXVVPtr param1, GXVVPtr param2)
                {
                    Inverse_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void low_pass(double param1)
                {
                    LowPass_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void red_pol(double param1, double param2, double param3, double param4)
                {
                    RedPol_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                double nyquist()
                {
                    double ret = rNyquist_FFT(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double samp_incr()
                {
                    double ret = rSampIncr_FFT(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double wave_incr()
                {
                    double ret = rWaveIncr_FFT(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_vv(GXVVPtr param1, GXVVPtr param2)
                {
                    SetVV_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void spectrum(GXVVPtr param1)
                {
                    Spectrum_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void v_drv(double param1)
                {
                    VDrv_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void v_int()
                {
                    VInt_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void write_spectrum(GXVVPtr param1, const gx_string_type& param2)
                {
                    WriteSpectrum_FFT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXFFT2
            {
            private:
                GXFFT2();
                ~GXFFT2();
            public:


                static void cross_correlation_pg(GXPGPtr param1, GXPGPtr param2, int32_t param3, GXPGPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CrossCorrelationPG_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void fft2_in(GXIMGPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Fft2In_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void filter_pg(GXPGPtr param1, const gx_string_type& param2, GXTRPtr param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FilterPG_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                static void flt(GXIMGPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Flt_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void flt_inv(GXIMGPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FltInv_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void pow_spc(GXIMGPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PowSpc_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void rad_spc(GXIMGPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RadSpc_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void rad_spc_alt(GXIMGPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RadSpcAlt_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void rad_spc1(GXIMGPtr param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RadSpc1_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void rad_spc2(GXIMGPtr param1, GXIMGPtr param2, GXVVPtr param3, GXVVPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RadSpc2_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void td_xd_y(GXIMGPtr param1, GXIMGPtr param2, const gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TdXdY_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void trans_pg(GXPGPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TransPG_FFT2(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void filter_response(const gx_string_type& param1, double param2, double param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FilterResponse_FFT2(
                        gx_->pGeo, param1.c_str(), &param2, &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }

            };
            class GXFLT
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXFLT(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXFLTPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXFLT>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXFLTPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_FLT(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXFLT>(ret);
                }
                ~GXFLT()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_FLT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                static GXFLTPtr load(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Load_FLT(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXFLT>(ret);
                }

            };
            class GXGD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXGD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXGDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXGD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXGDPtr create(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_GD(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXGD>(ret);
                }
                ~GXGD()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_GD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

            };
            class GXGEO
            {
            private:
                GXGEO();
                ~GXGEO();
            public:



            };
            class GXGEOSTRING
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXGEOSTRING(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXGEOSTRINGPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXGEOSTRING>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXGEOSTRINGPtr open(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Open_GEOSTRING(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXGEOSTRING>(ret);
                }
                ~GXGEOSTRING()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_features(GXLSTPtr param1)
                {
                    GetFeatures_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_sections(GXLSTPtr param1)
                {
                    GetSections_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_all_shapes(GXLSTPtr param1)
                {
                    GetAllShapes_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_shapes_for_feature(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GetShapesForFeature_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void get_shapes_for_section(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GetShapesForSection_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void get_shapes_for_feature_and_section(const gx_string_type& param1, const gx_string_type& param2, GXLSTPtr param3)
                {
                    GetShapesForFeatureAndSection_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void get_feature_properties(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, int32_t& param4, int32_t& param5, double& param6, double& param7, double& param8, int32_t& param9, int32_t& param10, int32_t& param11, double& param12, double& param13, int32_t& param14)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    param3.resize(STR_VERY_LONG);
                    GetFeatureProperties_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), &param6, &param7, &param8, reinterpret_cast<long*>(&param9), reinterpret_cast<long*>(&param10), reinterpret_cast<long*>(&param11), &param12, &param13, reinterpret_cast<long*>(&param14));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }
                void get_section_properties(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, int32_t& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    GetSectionProperties_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<long*>(&param4), &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13);
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }
                void get_shape_properties(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6)
                {
                    int32_t paramSize3 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_SHORT);
                    param3.resize(STR_DEFAULT_SHORT);
                    GetShapeProperties_GEOSTRING(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }

            };
            class GXGER
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXGER(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXGERPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXGER>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXGERPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_GER(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXGER>(ret);
                }
                ~GXGER()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_GER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t get(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    int32_t ret = IiGet_GER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }
                void set_int(const gx_string_type& param1, int32_t param2)
                {
                    SetInt_GER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_double(const gx_string_type& param1, double param2)
                {
                    SetReal_GER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2);
                    gx_->throw_on_error();
                }
                void set_string(const gx_string_type& param1, const gx_string_type& param2)
                {
                    SetString_GER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXGIS
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXGIS(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXGISPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXGIS>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXGISPtr create(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_GIS(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXGIS>(ret);
                }
                void create_map_2d(const gx_string_type& param1, double param2, GXIPJPtr param3, int32_t param4)
                {
                    CreateMap2D_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                ~GXGIS()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_bpr_models_lst(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GetBPRModelsLST_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                GXIPJPtr get_ipj()
                {
                    int32_t ret = GetIPJ_GIS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIPJ>(ret);
                }
                void get_meta(GXMETAPtr param1)
                {
                    GetMETA_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_range(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetRange_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                static int32_t datamine_type(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDatamineType_GIS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void get_file_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetFileName_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static int32_t is_mi_map_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsMIMapFile_GIS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t is_mi_raster_tab_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsMIRasterTabFile_GIS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t is_mi_rotated_raster_tab_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsMIRotatedRasterTabFile_GIS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_shp_file_3d()
                {
                    int32_t ret = iIsSHPFile3D_GIS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_shp_file_point()
                {
                    int32_t ret = iIsSHPFilePoint_GIS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t num_attribs()
                {
                    int32_t ret = iNumAttribs_GIS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t num_shapes()
                {
                    int32_t ret = iNumShapes_GIS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                static void scan_mi_raster_tab_file(const gx_string_type& param1, gx_string_type& param2, GXIPJPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IScanMIRasterTabFile_GIS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void load_ascii(GXWAPtr param1)
                {
                    LoadASCII_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void load_gdb(GXDBPtr param1)
                {
                    LoadGDB_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void load_map(GXMVIEWPtr param1)
                {
                    LoadMAP_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void load_map_ex(GXMAPPtr param1, const gx_string_type& param2)
                {
                    LoadMAPEx_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void load_meta_groups_map(GXMVIEWPtr param1, GXMETAPtr param2, int32_t param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    LoadMetaGroupsMAP_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                }
                void load_ply(GXPLYPtr param1)
                {
                    LoadPLY_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void load_shapes_gdb(GXDBPtr param1)
                {
                    LoadShapesGDB_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_dm_wireframe_pt_file(const gx_string_type& param1)
                {
                    SetDmWireframePtFile_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_lst(GXLSTPtr param1)
                {
                    SetLST_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_triangulation_object_index(int32_t param1)
                {
                    SetTriangulationObjectIndex_GIS(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

            };
            class GXGMSYS
            {
            private:
                GXGMSYS();
                ~GXGMSYS();
            public:


                static void launch(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Launch_GMSYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void remove_legacy_gms(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveLegacyGMS_GMSYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXGRID3D
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXGRID3D(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXGRID3DPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXGRID3D>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                int32_t get_type()
                {
                    int32_t ret = GetType_GRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_thematic()
                {
                    int32_t ret = iIsThematic_GRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_double()
                {
                    int32_t ret = iIsDouble_GRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_vector()
                {
                    int32_t ret = iIsVector_GRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_tpat(GXTPATPtr param1)
                {
                    GetTPAT_GRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_tpat(GXTPATPtr param1)
                {
                    SetTPAT_GRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_double_stats(int32_t& param1, int32_t& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetDoubleStats_GRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void get_thematic_stats(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5, int32_t& param6)
                {
                    GetThematicStats_GRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                }
                void get_vector_stats(int32_t& param1, int32_t& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13, double& param14)
                {
                    GetVectorStats_GRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14);
                    gx_->throw_on_error();
                }
                void fill_double(double param1)
                {
                    FillDouble_GRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void fill_thematic(int32_t param1)
                {
                    FillThematic_GRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void fill_vector(double param1, double param2, double param3)
                {
                    FillVector_GRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                int32_t get_elements_in_block_x()
                {
                    int32_t ret = GetElementsInBlockX_GRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_elements_in_block_y()
                {
                    int32_t ret = GetElementsInBlockY_GRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_elements_in_block_z()
                {
                    int32_t ret = GetElementsInBlockZ_GRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t read_x(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    int32_t ret = ReadX_GRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t write_x(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    int32_t ret = WriteX_GRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t read_y(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    int32_t ret = ReadY_GRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t write_y(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    int32_t ret = WriteY_GRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t read_z(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    int32_t ret = ReadZ_GRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t write_z(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    int32_t ret = WriteZ_GRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXGU
            {
            private:
                GXGU();
                ~GXGU();
            public:


                static void dipole_mag(const gx_string_type& param1, double param2, double param3, int32_t param4, int32_t param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DipoleMag_GU(
                        gx_->pGeo, param1.c_str(), &param2, &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7);
                    gx_->throw_on_error();
                }
                static void em_half_space_inv(double param1, double param2, int32_t param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, int32_t param10, int32_t param11, double param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EMHalfSpaceInv_GU(
                        gx_->pGeo, &param1, &param2, reinterpret_cast<const long*>(&param3), &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), &param12);
                    gx_->throw_on_error();
                }
                static void em_half_space_vv(double param1, double param2, int32_t param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EMHalfSpaceVV_GU(
                        gx_->pGeo, &param1, &param2, reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                static void geometrics2_db(GXDBPtr param1, GXRAPtr param2, GXWAPtr param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, double param8, double param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Geometrics2DB_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), &param8, &param9, &param10, &param11);
                    gx_->throw_on_error();
                }
                static void geometrics2_tbl(GXRAPtr param1, GXWAPtr param2, GXWAPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Geometrics2TBL_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void geometrics_qc(GXWAPtr param1, const gx_string_type& param2, GXVVPtr param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GeometricsQC_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                }
                static void geonics3138_dump2_db(GXDBPtr param1, GXRAPtr param2, GXRAPtr param3, GXWAPtr param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Geonics3138Dump2DB_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6);
                    gx_->throw_on_error();
                }
                static void geonics61_dump2_db(GXDBPtr param1, GXRAPtr param2, GXWAPtr param3, double param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Geonics61Dump2DB_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5);
                    gx_->throw_on_error();
                }
                static void geonics_dat2_db(GXDBPtr param1, GXRAPtr param2, GXWAPtr param3, double param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GeonicsDAT2DB_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5);
                    gx_->throw_on_error();
                }
                static void gr_curv_cor(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GrCurvCor_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void gr_curv_cor_ex(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GrCurvCorEx_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4);
                    gx_->throw_on_error();
                }
                static void gr_demvv(GXIMGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GrDEMVV_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void gr_test(double param1, double param2, double param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GrTest_GU(
                        gx_->pGeo, &param1, &param2, &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }
                static void gravity_still_reading_correction(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, const gx_string_type& param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GravityStillReadingCorrection_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void gravity_still_reading_database_correction(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXDBPtr param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GravityStillReadingDatabaseCorrection_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }
                static void despike_em_array(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DespikeEMArray_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }
                static int32_t em_layer(double param1, double param2, double param3, int32_t param4, int32_t param5, GXVVPtr param6, GXVVPtr param7, double& param8, double& param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iEMLayer_GU(
                                      gx_->pGeo, &param1, &param2, &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), &param8, &param9);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t em_plate(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, int32_t param10, GXVVPtr param11, int32_t param12, double param13, double param14, double param15, GXVVPtr param16, GXVVPtr param17, GXVVPtr param18, GXVVPtr param19, GXVVPtr param20, GXVVPtr param21)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iEMPlate_GU(
                                      gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&param12), &param13, &param14, &param15, reinterpret_cast<const long*>(&gx_->handle(param16)), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&gx_->handle(param18)), reinterpret_cast<const long*>(&gx_->handle(param19)), reinterpret_cast<const long*>(&gx_->handle(param20)), reinterpret_cast<const long*>(&gx_->handle(param21)));
                    gx_->throw_on_error();
                    return ret;
                }
                static void gen_ux_detect_symbols_group_name(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_GROUP * STRING_CHAR_SIZE;
                    param3.resize(STR_GROUP);
                    IGenUXDetectSymbolsGroupName_GU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                static void import_daarc500_ethernet(const gx_string_type& param1, const gx_string_type& param2, int32_t& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportDAARC500Ethernet_GU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }
                static void import_daarc500_serial(const gx_string_type& param1, int32_t param2, const gx_string_type& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportDAARC500Serial_GU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), param3.c_str(), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }
                static void import_p190(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXWAPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportP190_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void lag_daarc500_gps(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LagDAARC500GPS_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void magnetic_tilt_depth(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MagneticTiltDepth_GU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void maxwell_plate_corners(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double& param9, double& param10, double& param11, double& param12, double& param13, double& param14, double& param15, double& param16, double& param17, double& param18, double& param19, double& param20)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MaxwellPlateCorners_GU(
                        gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18, &param19, &param20);
                    gx_->throw_on_error();
                }
                static void scan_daarc500_ethernet(const gx_string_type& param1, int32_t& param2, int32_t& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ScanDAARC500Ethernet_GU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }
                static void scan_daarc500_serial(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ScanDAARC500Serial_GU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void vv_euler(GXVVPtr param1, GXVVPtr param2, GXIMGPtr param3, GXIMGPtr param4, GXIMGPtr param5, GXIMGPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10, GXVVPtr param11, GXVVPtr param12, int32_t param13, double param14, double param15, int32_t param16)
                {
                    GXContextPtr gx_ = GXContext::current();
                    VVEuler_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&param13), &param14, &param15, reinterpret_cast<const long*>(&param16));
                    gx_->throw_on_error();
                }
                static void vv_euler2(GXVVPtr param1, GXVVPtr param2, GXIMGPtr param3, GXIMGPtr param4, GXIMGPtr param5, GXIMGPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10, GXVVPtr param11, GXVVPtr param12, GXVVPtr param13, double param14, double param15, int32_t param16)
                {
                    GXContextPtr gx_ = GXContext::current();
                    VVEuler2_GU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), &param14, &param15, reinterpret_cast<const long*>(&param16));
                    gx_->throw_on_error();
                }

            };
            class GXGUI
            {
            private:
                GXGUI();
                ~GXGUI();
            public:


                static int32_t create_wnd_from_hwnd(HWND param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_CreateWNDFromHWND_GUI(
                                      gx_->pGeo, param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_parent_wnd()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_GetParentWND_GUI(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_printer_lst(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_GetPrinterLST_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static int32_t get_window_state()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iGetWindowState_GUI(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static void set_window_state(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetWindowState_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static void get_window_position(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_GetWindowPosition_GUI(
                        gx_->pGeo, reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                }
                static void set_window_position(int32_t param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetWindowPosition_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void get_client_window_area(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_GetClientWindowArea_GUI(
                        gx_->pGeo, reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }
                static void grid_stat_hist(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_GridStatHist_GUI(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void grid_stat_hist5(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_GridStatHist5_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                }
                static void voxel_stat_hist(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_VoxelStatHist_GUI(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static int32_t color_form(int32_t& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iColorForm_GUI(
                                      gx_->pGeo, reinterpret_cast<long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t color_transform(GXITRPtr param1, GXSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iColorTransform_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t coord_sys_wizard(GXIPJPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iCoordSysWizard_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t coord_sys_wizard_licensed(GXIPJPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iCoordSysWizardLicensed_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t coord_sys_wizard_grid(GXIPJPtr param1, GXIPJPtr param2, int32_t param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6, int32_t param7, int32_t param8, double& param9, double& param10, double& param11, double& param12, double& param13)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iCoordSysWizardGrid_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str(), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), &param9, &param10, &param11, &param12, &param13);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t database_type(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    int32_t ret = App_iDatabaseType_GUI(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }
                static int32_t datamine_type(const gx_string_type& param1, int32_t& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iDatamineType_GUI(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t export_xyz_template_editor(GXDBPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iExportXYZTemplateEditor_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t export_xyz_template_editor_ex(GXEDBPtr param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    int32_t ret = App_iExportXYZTemplateEditorEx_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }
                static int32_t file_filter_index(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iFileFilterIndex_GUI(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t gcs_datum_warning_shp(const gx_string_type& param1, GXIPJPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGCSDatumWarningSHP_GUI(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t gcs_datum_warning_shpdb_ex(GXLSTPtr param1, GXLSTPtr param2, GXLSTPtr param3, GXDBPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGCSDatumWarningSHPDBEx_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t gcs_datum_warning_shp_ex(GXLSTPtr param1, GXLSTPtr param2, GXLSTPtr param3, GXMVIEWPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGCSDatumWarningSHPEx_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_area_of_interest(double& param1, double& param2, double& param3, double& param4, GXPLYPtr param5, GXIPJPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iGetAreaOfInterest_GUI(
                                      gx_->pGeo, &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_area_of_interest_3d(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, GXPLYPtr param7, GXIPJPtr param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iGetAreaOfInterest3D_GUI(
                                      gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_dat_defaults(int32_t param1, int32_t param2, gx_string_type& param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    param4.resize(STR_FILE);
                    IGetDATDefaults_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                }
                static void get_file_filter(int32_t param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4, int32_t& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_SHORT);
                    param3.resize(STR_DEFAULT_SHORT);
                    param4.resize(STR_DEFAULT_SHORT);
                    IGetFileFilter_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize6 ), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                }
                static void get_gs_directory(int32_t param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetGSDirectory_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static int32_t browse_dir(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_IiBrowseDir_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t color_transform_ex(GXITRPtr param1, GXSTPtr param2, int32_t param3, int32_t param4, gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param5.resize(STR_FILE);
                    int32_t ret = App_IiColorTransformEx_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param5.resize(gx_string_len(param5.c_str()));
                    return ret;
                }
                static int32_t cumulative_percent(gx_string_type& param1, GXITRPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    int32_t ret = App_IiCumulativePercent_GUI(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }
                static int32_t dat_file_form(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_MULTI_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_MULTI_FILE);
                    int32_t ret = App_IiDatFileForm_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t dat_file_form_ex(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_MULTI_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_MULTI_FILE);
                    int32_t ret = App_IiDatFileFormEx_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t gen_file_form(const gx_string_type& param1, GXVVPtr param2, int32_t param3, const gx_string_type& param4, gx_string_type& param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize5 = STR_MULTI_FILE * STRING_CHAR_SIZE;
                    param5.resize(STR_MULTI_FILE);
                    int32_t ret = App_IiGenFileForm_GUI(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), param4.c_str(), (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    param5.resize(gx_string_len(param5.c_str()));
                    return ret;
                }
                static int32_t custom_file_form(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_MULTI_FILE * STRING_CHAR_SIZE;
                    param4.resize(STR_MULTI_FILE);
                    int32_t ret = App_IiCustomFileForm_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    return ret;
                }
                static int32_t import_drill_database_ado2(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, int32_t& param4, GXREGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    int32_t ret = App_IiImportDrillDatabaseADO2_GUI(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ), reinterpret_cast<long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t import_drill_database_esri(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, int32_t& param4, int32_t param5, GXREGPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    int32_t ret = App_IiImportDrillDatabaseESRI_GUI(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ), reinterpret_cast<long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t import_drill_database_odbc(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, int32_t& param4, GXREGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    int32_t ret = App_IiImportDrillDatabaseODBC_GUI(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t configure_connection(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    int32_t ret = App_iConfigureConnection_GUI(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t import_drill_database_odbc_maxwell(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, int32_t& param4, GXREGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    param2.resize(STR_FILE);
                    param3.resize(STR_FILE);
                    int32_t ret = App_IiImportDrillDatabaseODBCMaxwell_GUI(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t import_ascii_wizard(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iImportAsciiWizard_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t import_chem_database(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_iImportChemDatabase_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t import_chem_database_ado(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_iImportChemDatabaseADO_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t import_database(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_iImportDatabase_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t import_database_ado(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_iImportDatabaseADO_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t import_database_sql(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param4.resize(STR_FILE);
                    int32_t ret = App_iImportDatabaseSQL_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    return ret;
                }
                static int32_t import_database_sqlado(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param4.resize(STR_FILE);
                    int32_t ret = App_iImportDatabaseSQLADO_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    return ret;
                }
                static int32_t import_drill_database_ado(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3, int32_t& param4, GXREGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = App_iImportDrillDatabaseADO_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t import_template_sql(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iImportTemplateSQL_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t import_template_sqlado(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iImportTemplateSQLADO_GUI(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t import_xyz_template_editor(GXDBPtr param1, gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    int32_t ret = App_iImportXYZTemplateEditor_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), param3.c_str());
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }
                static int32_t odbc_file_connect(const gx_string_type& param1, gx_string_type& param2, int32_t param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    param4.resize(STR_FILE);
                    int32_t ret = App_IiODBCFileConnect_GUI(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    return ret;
                }
                static int32_t symbol_form(gx_string_type& param1, int32_t& param2, int32_t& param3, int32_t& param4, double& param5, double& param6, int32_t& param7, int32_t& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    int32_t ret = App_IiSymbolForm_GUI(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), &param5, &param6, reinterpret_cast<long*>(&param7), reinterpret_cast<long*>(&param8));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }
                static int32_t meta_data_tool(GXMETAPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iMetaDataTool_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static void import_chem_wizard(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ImportChemWizard_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void import_drill_wizard(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3, int32_t& param4, GXREGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    App_ImportDrillWizard_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                static void import_drill_wizard_ex(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3, int32_t param4, GXREGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    App_ImportDrillWizardEx_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                static void internet_trust()
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_InternetTrust_GUI(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static int32_t pattern_form(int32_t& param1, double& param2, int32_t& param3, double& param4, int32_t& param5, int32_t& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iPatternForm_GUI(
                                      gx_->pGeo, reinterpret_cast<long*>(&param1), &param2, reinterpret_cast<long*>(&param3), &param4, reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t line_pattern_form(int32_t& param1, double& param2, double& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iLinePatternForm_GUI(
                                      gx_->pGeo, reinterpret_cast<long*>(&param1), &param2, &param3, reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t two_panel_selection(GXLSTPtr param1, GXLSTPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iTwoPanelSelection_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t two_panel_selection2(GXLSTPtr param1, GXLSTPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iTwoPanelSelection2_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t two_panel_selection_ex(GXLSTPtr param1, GXLSTPtr param2, int32_t param3, int32_t param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iTwoPanelSelectionEx_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t two_panel_selection_ex2(GXLSTPtr param1, GXLSTPtr param2, int32_t param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iTwoPanelSelectionEx2_GUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void launch_single_geo_dotnetx_tool(const gx_string_type& param1, const gx_string_type& param2, GXMETAPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LaunchSingleGeoDOTNETXTool_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void launch_geo_dotnetx_tool(const gx_string_type& param1, const gx_string_type& param2, GXMETAPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LaunchGeoDOTNETXTool_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void launch_geo_x_tool(const gx_string_type& param1, const gx_string_type& param2, GXMETAPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LaunchGeoXTool_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void launch_single_geo_dotnetx_tool_ex(const gx_string_type& param1, const gx_string_type& param2, GXMETAPtr param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LaunchSingleGeoDOTNETXToolEx_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void launch_geo_dotnetx_tool_ex(const gx_string_type& param1, const gx_string_type& param2, GXMETAPtr param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LaunchGeoDOTNETXToolEx_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void launch_geo_x_tool_ex(const gx_string_type& param1, const gx_string_type& param2, GXMETAPtr param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_LaunchGeoXToolEx_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void meta_data_viewer(GXMETAPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_MetaDataViewer_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void print_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_PrintFile_GUI(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void render_pattern(HDC param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7, int32_t param8, double param9, int32_t param10, int32_t param11, int32_t param12, int32_t param13, int32_t param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_RenderPattern_GUI(
                        gx_->pGeo, param1, reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8), &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13), reinterpret_cast<const long*>(&param14));
                    gx_->throw_on_error();
                }
                static void render_line_pattern(HDC param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7, double param8, int32_t param9, int32_t param10, int32_t param11, int32_t param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_RenderLinePattern_GUI(
                        gx_->pGeo, param1, reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                }
                static void set_parent_wnd(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetParentWND_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static void set_printer(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetPrinter_GUI(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void set_prog_always_on(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetProgAlwaysOn_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static void show_direct_hist(double param1, double param2, double param3, double param4, double param5, int32_t param6, GXVVPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ShowDirectHist_GUI(
                        gx_->pGeo, &param1, &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                static void show_hist(GXSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ShowHist_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void simple_map_dialog(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SimpleMapDialog_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void thematic_voxel_info(GXVOXPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ThematicVoxelInfo_GUI(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void show_3d_viewer_dialog(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_Show3DViewerDialog_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void fft2_spec_filter(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_Fft2SpecFilter_GUI(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXHGD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXHGD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXHGDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXHGD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXHGDPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_HGD(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXHGD>(ret);
                }
                ~GXHGD()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_HGD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void export_img(const gx_string_type& param1)
                {
                    ExportIMG_HGD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void get_meta(GXMETAPtr param1)
                {
                    GetMETA_HGD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXHGDPtr h_create_img(GXIMGPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = hCreateIMG_HGD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXHGD>(ret);
                }
                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_HGD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

            };
            class GXHTTP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXHTTP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXHTTPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXHTTP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXHTTPPtr create(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_HTTP(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXHTTP>(ret);
                }
                ~GXHTTP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_HTTP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void download(const gx_string_type& param1, GXBFPtr param2, int32_t param3)
                {
                    Download_HTTP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void silent_download(const gx_string_type& param1, GXBFPtr param2, int32_t param3)
                {
                    SilentDownload_HTTP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void get(const gx_string_type& param1, const gx_string_type& param2, GXBFPtr param3, GXBFPtr param4)
                {
                    Get_HTTP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void post(const gx_string_type& param1, const gx_string_type& param2, GXBFPtr param3)
                {
                    Post_HTTP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void set_proxy_credentials(const gx_string_type& param1, const gx_string_type& param2)
                {
                    SetProxyCredentials_HTTP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXHXYZ
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXHXYZ(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXHXYZPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXHXYZ>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXHXYZPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_HXYZ(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXHXYZ>(ret);
                }
                ~GXHXYZ()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_HXYZ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_meta(GXMETAPtr param1)
                {
                    GetMETA_HXYZ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXHXYZPtr h_create_db(GXDBPtr param1, GXVVPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = hCreateDB_HXYZ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXHXYZ>(ret);
                }
                static GXHXYZPtr h_create_sql(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, GXIPJPtr param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = hCreateSQL_HXYZ(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&gx_->handle(param5)), param6.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXHXYZ>(ret);
                }
                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_HXYZ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

            };
            class GXIEXP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXIEXP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXIEXPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXIEXP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_grid(GXIMGPtr param1, const gx_string_type& param2)
                {
                    AddGrid_IEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static GXIEXPPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_IEXP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIEXP>(ret);
                }
                ~GXIEXP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_IEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void do_formula(const gx_string_type& param1, int32_t param2)
                {
                    DoFormula_IEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

            };
            class GXIGRF
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXIGRF(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXIGRFPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXIGRF>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void calc(double param1, double param2, double param3, double& param4, double& param5, double& param6)
                {
                    Calc_IGRF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void calc_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6)
                {
                    CalcVV_IGRF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static GXIGRFPtr create(double param1, int32_t param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_IGRF(
                                      gx_->pGeo, &param1, reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIGRF>(ret);
                }
                static void date_range(const gx_string_type& param1, double& param2, double& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DateRange_IGRF(
                        gx_->pGeo, param1.c_str(), &param2, &param3);
                    gx_->throw_on_error();
                }
                ~GXIGRF()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_IGRF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

            };
            class GXIMG
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXIMG(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXIMGPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXIMG>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static void average2(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Average2_IMG(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void copy(GXIMGPtr param1)
                {
                    Copy_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXIMGPtr create(int32_t param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIMG>(ret);
                }
                static GXIMGPtr create_file(int32_t param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateFile_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIMG>(ret);
                }
                static GXIMGPtr create_mem(int32_t param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateMem_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIMG>(ret);
                }
                static GXIMGPtr create_new_file(int32_t param1, int32_t param2, int32_t param3, int32_t param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateNewFile_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIMG>(ret);
                }
                static GXIMGPtr create_out_file(int32_t param1, const gx_string_type& param2, GXIMGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateOutFile_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIMG>(ret);
                }
                void create_projected(GXIPJPtr param1)
                {
                    CreateProjected_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void create_projected2(GXIPJPtr param1, double param2)
                {
                    CreateProjected2_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }
                void create_projected3(GXIPJPtr param1, double param2, double param3)
                {
                    CreateProjected3_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3);
                    gx_->throw_on_error();
                }
                ~GXIMG()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void extent(double& param1, double& param2, double& param3, double& param4)
                {
                    Extent_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                GXPGPtr geth_pg()
                {
                    int32_t ret = GethPG_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }
                void get_info(double& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    GetInfo_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_meta(GXMETAPtr param1)
                {
                    GetMETA_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_pg(GXPGPtr param1)
                {
                    GetPG_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_projected_cell_size(GXIPJPtr param1, double& param2)
                {
                    GetProjectedCellSize_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }
                void get_tr(GXTRPtr param1)
                {
                    GetTR_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                int32_t element_type(int32_t param1)
                {
                    int32_t ret = iElementType_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t e_type()
                {
                    int32_t ret = iEType_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_def_itr(GXITRPtr param1)
                {
                    int32_t ret = iGetDefITR_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_colour()
                {
                    int32_t ret = iIsColour_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t is_valid_img_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsValidIMGFile_IMG(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t is_valid_img_file_ex(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    int32_t ret = iIsValidIMGFileEx_IMG(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }
                int32_t ne()
                {
                    int32_t ret = iNE_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void inherit(GXIPJPtr param1, double param2)
                {
                    Inherit_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }
                void inherit_img(GXIMGPtr param1)
                {
                    InheritIMG_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                int32_t nv()
                {
                    int32_t ret = iNV_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t nx()
                {
                    int32_t ret = iNX_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t ny()
                {
                    int32_t ret = iNY_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t query_int(int32_t param1)
                {
                    int32_t ret = iQuery_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t query_kx()
                {
                    int32_t ret = iQueryKX_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t set_def_itr(GXITRPtr param1)
                {
                    int32_t ret = iSetDefITR_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t user_preference_to_plot_as_colour_shaded_grid()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iUserPreferenceToPlotAsColourShadedGrid_IMG(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                void load_img(GXIMGPtr param1)
                {
                    LoadIMG_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void load_into_pager()
                {
                    LoadIntoPager_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void opt_kx(int32_t param1)
                {
                    OptKX_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void read_v(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    ReadV_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void read_x(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    ReadX_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void read_y(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    ReadY_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void refresh_gi(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RefreshGI_IMG(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                void relocate(double param1, double param2, double param3, double param4, int32_t param5)
                {
                    Relocate_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void report(const gx_string_type& param1, GXWAPtr param2, int32_t param3, int32_t param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Report_IMG(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str());
                    gx_->throw_on_error();
                }
                static void report_csv(const gx_string_type& param1, GXWAPtr param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReportCSV_IMG(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                double get_display_property(int32_t param1)
                {
                    double ret = rGetDisplayProperty_IMG(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_z(double param1, double param2)
                {
                    double ret = rGetZ_IMG(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }
                double query_double(int32_t param1)
                {
                    double ret = rQuery_IMG(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_display_property(int32_t param1, double param2)
                {
                    SetDisplayProperty_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                void get_shadow_grid_path(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetShadowGridPath_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void set_shadow_grid_path(const gx_string_type& param1)
                {
                    SetShadowGridPath_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_grid_unchanged()
                {
                    SetGridUnchanged_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void set_info(double param1, double param2, double param3, double param4, double param5)
                {
                    SetInfo_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_pg(GXPGPtr param1)
                {
                    SetPG_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_tr(GXTRPtr param1)
                {
                    SetTR_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void sync(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Sync_IMG(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                void write_v(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    WriteV_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void write_x(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    WriteX_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void write_y(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    WriteY_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void set_double_parameter(const gx_string_type& param1, double param2)
                {
                    SetRealParameter_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2);
                    gx_->throw_on_error();
                }
                double get_double_parameter(const gx_string_type& param1)
                {
                    double ret = rGetRealParameter_IMG(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t number_of_faults()
                {
                    int32_t ret = iNumberOfFaults_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_fault(int32_t param1, GXVVPtr param2, GXVVPtr param3, int32_t& param4)
                {
                    GetFault_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }
                int32_t add_fault(GXVVPtr param1, GXVVPtr param2, int32_t param3)
                {
                    int32_t ret = iAddFault_IMG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                void delete_fault(int32_t param1)
                {
                    DeleteFault_IMG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

            };
            class GXIMU
            {
            private:
                GXIMU();
                ~GXIMU();
            public:


                static void agg_to_geo_color(GXAGGPtr param1, const gx_string_type& param2, GXIPJPtr param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AggToGeoColor_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4);
                    gx_->throw_on_error();
                }
                static int32_t crc(GXIMGPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CRC_IMU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t crc_grid(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CRCGrid_IMU(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t crc_grid_inexact(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CRCGridInexact_IMU(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t crc_inexact(GXIMGPtr param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CRCInexact_IMU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }
                static void decimate_crooked_section_grid(GXIMGPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DecimateCrookedSectionGrid_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }
                static void export_grid_without_data_section_xml(const gx_string_type& param1, int32_t& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportGridWithoutDataSectionXML_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                static void export_grid_xml(const gx_string_type& param1, int32_t& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportGridXML_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                static void export_raw_xml(GXIMGPtr param1, int32_t& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportRawXML_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                static void export_xml(GXIMGPtr param1, int32_t& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportXML_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                static void get_zvv(GXIMGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetZVV_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void get_z_peaks_vv(GXIMGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetZPeaksVV_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void grid_add(GXIMGPtr param1, double param2, GXIMGPtr param3, double param4, GXIMGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridAdd_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void grid_agc(GXIMGPtr param1, GXIMGPtr param2, int32_t param3, double param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridAGC_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void grid_bool(GXIMGPtr param1, GXIMGPtr param2, const gx_string_type& param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridBool_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void grid_edge(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridEdge_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void grid_edge_ply(GXIMGPtr param1, GXPLYPtr param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridEdgePLY_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void grid_expand(GXIMGPtr param1, const gx_string_type& param2, double param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridExpand_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void grid_exp_fill(const gx_string_type& param1, const gx_string_type& param2, double param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridExpFill_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void grid_fill(GXIMGPtr param1, GXIMGPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7, double param8, double param9, int32_t param10, int32_t param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridFill_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                }
                static void grid_filt(GXIMGPtr param1, GXIMGPtr param2, int32_t param3, double param4, int32_t param5, int32_t param6, int32_t param7, const gx_string_type& param8, GXVVPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridFilt_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), param8.c_str(), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }
                static void grid_head(const gx_string_type& param1, double param2, double param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridHead_IMU(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                static void grid_mask(const gx_string_type& param1, const gx_string_type& param2, GXPLYPtr param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridMask_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void grid_peak(const gx_string_type& param1, int32_t param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridPeak_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void grid_ply(GXIMGPtr param1, GXPLYPtr param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridPLY_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void grid_ply_ex(GXIMGPtr param1, GXPLYPtr param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridPLYEx_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void grid_reproject_and_window(const gx_string_type& param1, const gx_string_type& param2, GXIPJPtr param3, double param4, double param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridReprojectAndWindow_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }
                static void grid_resample(const gx_string_type& param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, int32_t param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridResample_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void grid_resize(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridResize_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void grid_shad(const gx_string_type& param1, const gx_string_type& param2, double& param3, double& param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridShad_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                static void refresh_shad(GXIMGPtr param1, GXIMGPtr param2, double& param3, double& param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RefreshShad_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                static void grid_st(const gx_string_type& param1, GXSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridST_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void grid_stat(const gx_string_type& param1, int32_t& param2, int32_t& param3, int32_t& param4, double& param5, double& param6, int32_t& param7, double& param8, double& param9, double& param10, double& param11, double& param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridStat_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), &param5, &param6, reinterpret_cast<long*>(&param7), &param8, &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                }
                static void grid_stat_comp(const gx_string_type& param1, int32_t& param2, int32_t& param3, int32_t& param4, double& param5, double& param6, int32_t& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridStatComp_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), &param5, &param6, reinterpret_cast<long*>(&param7), &param8, &param9, &param10, &param11, &param12, &param13);
                    gx_->throw_on_error();
                }
                static void grid_stat_ext(const gx_string_type& param1, int32_t param2, int32_t& param3, int32_t& param4, double& param5, double& param6, double& param7, double& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridStatExt_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }
                static void grid_stat_trend(const gx_string_type& param1, int32_t& param2, double& param3, double& param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridStatTrend_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                static void grid_stat_trend_ext(const gx_string_type& param1, int32_t& param2, int32_t& param3, double& param4, double& param5, GXVMPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridStatTrendExt_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static double slope_standard_deviation(GXIMGPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rSlopeStandardDeviation_IMU(
                                     gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                static void grid_stitch(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, double param8, int32_t param9, int32_t param10, GXPLYPtr param11, double param12, int32_t param13)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridStitch_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&gx_->handle(param11)), &param12, reinterpret_cast<const long*>(&param13));
                    gx_->throw_on_error();
                }
                static void grid_stitch_ctl(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridStitchCtl_IMU(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void grid_tiff(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4, int32_t param5, int32_t param6, double param7, int32_t param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridTiff_IMU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8), &param9);
                    gx_->throw_on_error();
                }
                static void grid_trnd(GXIMGPtr param1, GXIMGPtr param2, int32_t param3, int32_t param4, int32_t param5, GXVMPtr param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridTrnd_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void grid_trns(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridTrns_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void grid_vc(GXIMGPtr param1, GXIMGPtr param2, int32_t param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridVC_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }
                static void grid_vd(GXIMGPtr param1, GXIMGPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridVD_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void grid_vol(GXIMGPtr param1, double param2, double param3, double& param4, double& param5, double& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridVol_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                static void grid_wind(GXIMGPtr param1, const gx_string_type& param2, int32_t param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, int32_t param11, int32_t param12, const gx_string_type& param13)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridWind_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8, &param9, &param10, reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), param13.c_str());
                    gx_->throw_on_error();
                }
                static void grid_wind2(GXIMGPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, double param7, double param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridWind2_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                static void grid_xyz(GXIMGPtr param1, const gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridXYZ_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static int32_t grid_type(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGridType_IMU(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void make_mi_tab_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MakeMITabFile_IMU(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void make_mi_tabfrom_grid(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MakeMITabfromGrid_IMU(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void make_mi_tabfrom_map(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MakeMITabfromMap_IMU(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static GXIMGPtr mosaic(const gx_string_type& param1, const gx_string_type& param2, GXIPJPtr param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Mosaic_IMU(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIMG>(ret);
                }
                static void peak_size(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, int32_t param4, double param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PeakSize_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5, reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static void peak_size2(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, int32_t param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PeakSize2_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void pigeon_hole(GXIMGPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PigeonHole_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }
                static void pigeon_hole_color(GXIMGPtr param1, GXIMGPtr param2, GXVVPtr param3, GXVVPtr param4, GXITRPtr param5, int32_t& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PigeonHoleColor_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                }
                static void profile(GXIMGPtr param1, double param2, double param3, double param4, double param5, double param6, GXVVPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Profile_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                static void profile_vv(GXIMGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProfileVV_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void range_grids(const gx_string_type& param1, GXIPJPtr param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RangeGrids_IMU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                static void range_ll(GXIMGPtr param1, double& param2, double& param3, double& param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RangeLL_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                static void stat_window(GXIMGPtr param1, double param2, double param3, double param4, double param5, int32_t param6, GXSTPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    StatWindow_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                static void update_ply(GXIMGPtr param1, GXPLYPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    UpdatePLY_IMU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

            };
            class GXINTERNET
            {
            private:
                GXINTERNET();
                ~GXINTERNET();
            public:


                static int32_t download_http(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDownloadHTTP_INTERNET(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static void send_mail(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SendMail_INTERNET(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXIP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXIP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXIPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXIP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static void convert_ubcip_2d_to_grid(const gx_string_type& param1, GXPGPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7, double param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertUBCIP2DToGrid_IP(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                void create_default_job(const gx_string_type& param1, int32_t param2)
                {
                    CreateDefaultJob_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void export_ubcip3(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, double param7)
                {
                    ExportUBCIP3_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), &param7);
                    gx_->throw_on_error();
                }
                static void export_ubcip_control(const gx_string_type& param1, int32_t param2, int32_t param3, double param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, const gx_string_type& param11, const gx_string_type& param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportUBCIPControl_IP(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4, param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), param11.c_str(), param12.c_str());
                    gx_->throw_on_error();
                }
                static void export_ubcip_control_v5(const gx_string_type& param1, int32_t param2, double param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6, const gx_string_type& param7, int32_t param8, const gx_string_type& param9, int32_t param10, const gx_string_type& param11, int32_t param12, const gx_string_type& param13, int32_t param14, const gx_string_type& param15, const gx_string_type& param16)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportUBCIPControlV5_IP(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), &param3, param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6), param7.c_str(), reinterpret_cast<const long*>(&param8), param9.c_str(), reinterpret_cast<const long*>(&param10), param11.c_str(), reinterpret_cast<const long*>(&param12), param13.c_str(), reinterpret_cast<const long*>(&param14), param15.c_str(), param16.c_str());
                    gx_->throw_on_error();
                }
                void export_ubc_res3(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, double param8)
                {
                    ExportUBCRes3_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), &param8);
                    gx_->throw_on_error();
                }
                static void export_ubc_res_control(const gx_string_type& param1, int32_t param2, int32_t param3, double param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, double param9, const gx_string_type& param10, const gx_string_type& param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportUBCResControl_IP(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4, param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), &param9, param10.c_str(), param11.c_str());
                    gx_->throw_on_error();
                }
                static void export_ubc_res_control_v5(const gx_string_type& param1, int32_t param2, double param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6, const gx_string_type& param7, int32_t param8, const gx_string_type& param9, int32_t param10, const gx_string_type& param11, int32_t param12, const gx_string_type& param13, const gx_string_type& param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportUBCResControlV5_IP(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), &param3, param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6), param7.c_str(), reinterpret_cast<const long*>(&param8), param9.c_str(), reinterpret_cast<const long*>(&param10), param11.c_str(), reinterpret_cast<const long*>(&param12), param13.c_str(), param14.c_str());
                    gx_->throw_on_error();
                }
                void export_data_to_ubc_3d(GXDBPtr param1, GXLSTPtr param2, int32_t param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, int32_t param8, const gx_string_type& param9, const gx_string_type& param10)
                {
                    ExportDataToUBC3D_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str(), param7.c_str(), reinterpret_cast<const long*>(&param8), param9.c_str(), param10.c_str());
                    gx_->throw_on_error();
                }
                static GXPGPtr import_ubc2_dmod(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = ImportUBC2DMOD_IP(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }
                static void import_ubc2_dmsh(const gx_string_type& param1, double& param2, double& param3, GXVVPtr param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportUBC2DMSH_IP(
                        gx_->pGeo, param1.c_str(), &param2, &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void import_ubc_2d_topo(const gx_string_type& param1, double& param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportUBC2DTopo_IP(
                        gx_->pGeo, param1.c_str(), &param2, reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void open_job(const gx_string_type& param1, int32_t param2)
                {
                    OpenJob_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void save_job(const gx_string_type& param1, int32_t param2)
                {
                    SaveJob_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static GXPGPtr trim_ubc_2d_model(GXPGPtr param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5, GXVVPtr param6, double& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = TrimUBC2DModel_IP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), &param7);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }
                void write_distant_electrodes(GXDBPtr param1)
                {
                    WriteDistantElectrodes_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void write_distant_electrodes_lst(GXDBPtr param1, GXLSTPtr param2)
                {
                    WriteDistantElectrodesLST_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void average_duplicates_qc(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4)
                {
                    AverageDuplicatesQC_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static GXIPPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_IP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIP>(ret);
                }
                ~GXIP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void export_i2_x(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, const gx_string_type& param11)
                {
                    ExportI2X_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), param11.c_str());
                    gx_->throw_on_error();
                }
                void export_ipdata(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    ExportIPDATA_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                void export_ipdata_dir(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    ExportIPDATADir_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                void export_ipred(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, const gx_string_type& param6, double param7, double param8, int32_t param9)
                {
                    ExportIPRED_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), param6.c_str(), &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                void export_ipred_dir(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, const gx_string_type& param6, double param7, double param8, int32_t param9, const gx_string_type& param10)
                {
                    ExportIPREDDir_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), param6.c_str(), &param7, &param8, reinterpret_cast<const long*>(&param9), param10.c_str());
                    gx_->throw_on_error();
                }
                void export_line_ipdata(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    ExportLineIPDATA_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                void export_sgdf(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    ExportSGDF_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                void get_n_value_lst(GXDBPtr param1, GXLSTPtr param2)
                {
                    GetNValueLST_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void get_topo_line(GXDBPtr param1, const gx_string_type& param2, double param3, double param4, double param5, GXVVPtr param6)
                {
                    GetTopoLine_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                int32_t get_chan_domain(GXDBPtr param1, const gx_string_type& param2)
                {
                    int32_t ret = iGetChanDomain_IP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_chan_label(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    param3.resize(STR_DEFAULT);
                    IGetChanLabel_IP(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }
                void get_channel_info(GXDBPtr param1, const gx_string_type& param2, int32_t& param3, double& param4, int32_t& param5, GXVVPtr param6)
                {
                    GetChannelInfo_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<long*>(&param3), &param4, reinterpret_cast<long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                void set_channel_info(GXDBPtr param1, const gx_string_type& param2, int32_t param3, double param4, int32_t param5, GXVVPtr param6)
                {
                    SetChannelInfo_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                void import_dump(int32_t param1, GXDBPtr param2, const gx_string_type& param3)
                {
                    ImportDump_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }
                void import_grid(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    ImportGrid_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                void import_i2_x(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, const gx_string_type& param11, int32_t param12)
                {
                    ImportI2X_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), param11.c_str(), reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                }
                void import_i2_x_ex(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, const gx_string_type& param11, const gx_string_type& param12, const gx_string_type& param13, int32_t param14)
                {
                    ImportI2XEx_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), param11.c_str(), param12.c_str(), param13.c_str(), reinterpret_cast<const long*>(&param14));
                    gx_->throw_on_error();
                }
                void import_instrumentation_gdd(GXDBPtr param1, const gx_string_type& param2)
                {
                    ImportInstrumentationGDD_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void import_ipdata(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    ImportIPDATA_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                void import_ipdata2(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    ImportIPDATA2_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                void import_ipred(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    ImportIPRED_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                void import_merge_ipred(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    ImportMergeIPRED_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                void import_sgdf(GXDBPtr param1, const gx_string_type& param2)
                {
                    ImportSGDF_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void import_topo_csv(GXDBPtr param1, const gx_string_type& param2)
                {
                    ImportTopoCSV_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void import_topo_grid(GXDBPtr param1, const gx_string_type& param2)
                {
                    ImportTopoGrid_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void import_zonge_avg(GXDBPtr param1, const gx_string_type& param2, double param3, int32_t param4, double param5)
                {
                    ImportZongeAVG_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, reinterpret_cast<const long*>(&param4), &param5);
                    gx_->throw_on_error();
                }
                void import_zonge_fld(GXDBPtr param1, const gx_string_type& param2, int32_t param3, double param4)
                {
                    ImportZongeFLD_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }
                void new_xy_database(GXDBPtr param1, GXDBPtr param2, GXVVPtr param3, const gx_string_type& param4, double param5)
                {
                    NewXYDatabase_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), &param5);
                    gx_->throw_on_error();
                }
                void pseudo_plot(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    PseudoPlot_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                void pseudo_plot2(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    PseudoPlot2_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                }
                void pseudo_plot2_dir(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    PseudoPlot2Dir_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }
                void ps_stack(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    PSStack_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                void ps_stack2(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4, const gx_string_type& param5)
                {
                    PSStack2_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), param5.c_str());
                    gx_->throw_on_error();
                }
                void ps_stack2_dir(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    PSStack2Dir_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }
                void qc_chan_lst(GXDBPtr param1, GXLSTPtr param2)
                {
                    QCChanLST_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void recalculate(GXDBPtr param1)
                {
                    Recalculate_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void recalculate_ex(GXDBPtr param1, int32_t param2)
                {
                    RecalculateEx_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void recalculate_derived_data(GXDBPtr param1, int32_t param2, GXLSTPtr param3, int32_t param4)
                {
                    RecalculateDerivedData_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void recalculate_z(GXDBPtr param1)
                {
                    RecalculateZ_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_import_line(const gx_string_type& param1)
                {
                    SetImportLine_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_import_mode(int32_t param1)
                {
                    SetImportMode_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void window(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    Window_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                static void winnow_chan_list(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    WinnowChanList_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void winnow_chan_list2(GXLSTPtr param1, GXDBPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    WinnowChanList2_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                int32_t is_valid_line(GXDBPtr param1, const gx_string_type& param2)
                {
                    int32_t ret = isValidLine_IP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t line_array_type(GXDBPtr param1, const gx_string_type& param2)
                {
                    int32_t ret = iLineArrayType_IP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                double a_spacing(GXDBPtr param1, const gx_string_type& param2)
                {
                    double ret = rASpacing_IP(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t pldp_convention()
                {
                    int32_t ret = iPLDPConvention_IP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_electrode_locations_and_mask_values(GXDBPtr param1, const gx_string_type& param2, int32_t param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7)
                {
                    GetElectrodeLocationsAndMaskValues_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                void get_electrode_locations_and_mask_values2(GXDBPtr param1, const gx_string_type& param2, int32_t param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8)
                {
                    GetElectrodeLocationsAndMaskValues2_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                }
                void set_electrode_mask_values(GXDBPtr param1, const gx_string_type& param2, int32_t param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7)
                {
                    SetElectrodeMaskValues_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                void set_electrode_mask_values_single_qc_channel(GXDBPtr param1, const gx_string_type& param2, int32_t param3, int32_t param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7)
                {
                    SetElectrodeMaskValuesSingleQCChannel_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                static int32_t get_qc_channel(GXDBPtr param1, int32_t param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param3.resize(STR_DB_SYMBOL);
                    int32_t ret = GetQCChannel_IP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static void locate_contributing_electrodes(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LocateContributingElectrodes_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), &param11);
                    gx_->throw_on_error();
                }
                static void locate_contributing_electrodes_3d(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, const gx_string_type& param11, const gx_string_type& param12, const gx_string_type& param13, const gx_string_type& param14, double param15)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LocateContributingElectrodes3D_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), param11.c_str(), param12.c_str(), param13.c_str(), param14.c_str(), &param15);
                    gx_->throw_on_error();
                }
                GXVVPtr get_grids_vv()
                {
                    int32_t ret = GetGridsVV_IP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                void get_line_data(GXDBPtr param1, const gx_string_type& param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10, GXVVPtr param11, GXVVPtr param12, const gx_string_type& param13, GXVVPtr param14)
                {
                    GetLineData_IP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), param13.c_str(), reinterpret_cast<const long*>(&gx_->handle(param14)));
                    gx_->throw_on_error();
                }

            };
            class GXIPGUI
            {
            private:
                GXIPGUI();
                ~GXIPGUI();
            public:


                static int32_t modify_job(GXIPPtr param1, GXDBPtr param2, const gx_string_type& param3, int32_t param4, int32_t& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iModifyJob_IPGUI(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }
                static void launch_ipqc_tool(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchIPQCTool_IPGUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void launch_offset_ipqc_tool(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchOffsetIPQCTool_IPGUI(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static int32_t ipqc_tool_exists()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIPQCToolExists_IPGUI(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static void launch_remove_contributing_electrodes_ext_tool(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchRemoveContributingElectrodesEXTTool_IPGUI(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXIPJ
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXIPJ(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXIPJPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXIPJ>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void clear_warp()
                {
                    _ClearWarp_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void make_geographic()
                {
                    _MakeGeographic_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void make_wgs84()
                {
                    _MakeWGS84_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void set_units(double param1, const gx_string_type& param2)
                {
                    _SetUnits_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, param2.c_str());
                    gx_->throw_on_error();
                }
                void add_exagg_warp(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    AddExaggWarp_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void add_log_warp(int32_t param1, int32_t param2)
                {
                    AddLogWarp_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void add_matrix_warp(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12, double param13, double param14, double param15, double param16)
                {
                    AddMatrixWarp_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16);
                    gx_->throw_on_error();
                }
                void add_warp(int32_t param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5)
                {
                    AddWarp_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                void clear_coordinate_system()
                {
                    ClearCoordinateSystem_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void clear_orientation()
                {
                    ClearOrientation_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void copy_orientation(GXIPJPtr param1)
                {
                    CopyOrientation_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void convert_orientation_warp_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4)
                {
                    ConvertOrientationWarpVV_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void copy(GXIPJPtr param1)
                {
                    Copy_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void copy_projection(GXIPJPtr param1)
                {
                    CopyProjection_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXIPJPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_IPJ(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIPJ>(ret);
                }
                static GXIPJPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIPJ>(ret);
                }
                static GXIPJPtr create_xml(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateXML_IPJ(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIPJ>(ret);
                }
                ~GXIPJ()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_3d_view(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9)
                {
                    Get3DView_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }
                void get_3d_view_ex(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, int32_t& param10, int32_t& param11)
                {
                    Get3DViewEx_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, reinterpret_cast<long*>(&param10), reinterpret_cast<long*>(&param11));
                    gx_->throw_on_error();
                }
                void get_crooked_section_view_v_vs(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t& param4)
                {
                    GetCrookedSectionViewVVs_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }
                static void get_list(int32_t param1, const gx_string_type& param2, GXLSTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetList_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void get_orientation_info(double& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    GetOrientationInfo_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                void get_plane_equation(double param1, double param2, double param3, double param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13)
                {
                    GetPlaneEquation_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13);
                    gx_->throw_on_error();
                }
                void get_plane_equation2(GXIPJPtr param1, double param2, double param3, double param4, double param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13, double& param14)
                {
                    GetPlaneEquation2_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14);
                    gx_->throw_on_error();
                }
                int32_t compare_datums(GXIPJPtr param1)
                {
                    int32_t ret = iCompareDatums_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t compare_datums_to_specified_tolerance_with_feedback(GXIPJPtr param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_DEFAULT_LONG);
                    int32_t ret = iCompareDatumsToSpecifiedToleranceWithFeedback_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                int32_t convert_warp(double& param1, double& param2, double& param3, int32_t param4)
                {
                    int32_t ret = iConvertWarp_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t convert_warp_vv(GXVVPtr param1, GXVVPtr param2, int32_t param3)
                {
                    int32_t ret = iConvertWarpVV_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t coordinate_systems_are_the_same(GXIPJPtr param1)
                {
                    int32_t ret = iCoordinateSystemsAreTheSame_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t coordinate_systems_are_the_same_within_a_small_tolerance(GXIPJPtr param1)
                {
                    int32_t ret = iCoordinateSystemsAreTheSameWithinASmallTolerance_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t coordinate_systems_are_the_same_to_specified_tolerance_with_feedback(GXIPJPtr param1, int32_t param2, int32_t param3, gx_string_type& param4)
                {
                    int32_t paramSize5 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param4.resize(STR_DEFAULT_LONG);
                    int32_t ret = iCoordinateSystemsAreTheSameToSpecifiedToleranceWithFeedback_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    return ret;
                }
                void get_display_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetDisplayName_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_esri(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IGetESRI_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_gxf(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4, gx_string_type& param5)
                {
                    int32_t paramSize6 = STR_GXF * STRING_CHAR_SIZE;
                    param1.resize(STR_GXF);
                    param2.resize(STR_GXF);
                    param3.resize(STR_GXF);
                    param4.resize(STR_GXF);
                    param5.resize(STR_GXF);
                    IGetGXF_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), (gx_string_char_type*)param2.data(), (gx_string_char_type*)param3.data(), (gx_string_char_type*)param4.data(), (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize6 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param5.resize(gx_string_len(param5.c_str()));
                }
                void get_mi_coord_sys(gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    param2.resize(STR_DEFAULT_LONG);
                    IGetMICoordSys_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void get_name(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    IGetName_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void set_vcs(const gx_string_type& param1)
                {
                    SetVCS_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                int32_t get_orientation()
                {
                    int32_t ret = iGetOrientation_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_orientation_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetOrientationName_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_units(double& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IGetUnits_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void get_xml(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IGetXML_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                int32_t has_projection()
                {
                    int32_t ret = iHasProjection_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_3d_inverted()
                {
                    int32_t ret = iIs3DInverted_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_3d_inverted_angles()
                {
                    int32_t ret = iIs3DInvertedAngles_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_geographic()
                {
                    int32_t ret = iIsGeographic_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t orientations_are_the_same(GXIPJPtr param1)
                {
                    int32_t ret = iOrientationsAreTheSame_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t orientations_are_the_same_within_a_small_tolerance(GXIPJPtr param1)
                {
                    int32_t ret = iOrientationsAreTheSameWithinASmallTolerance_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t orientations_are_the_same_to_specified_tolerance_with_feedback(GXIPJPtr param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_DEFAULT_LONG);
                    int32_t ret = iOrientationsAreTheSameToSpecifiedToleranceWithFeedback_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                int32_t has_section_orientation()
                {
                    int32_t ret = iHasSectionOrientation_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t projection_type_is_fully_supported()
                {
                    int32_t ret = iProjectionTypeIsFullySupported_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t set_gxf_safe(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    int32_t ret = iSetGXF_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t source_type()
                {
                    int32_t ret = iSourceType_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t support_datum_transform(GXIPJPtr param1)
                {
                    int32_t ret = iSupportDatumTransform_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                static void unit_name(double param1, int32_t param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param3.resize(STR_DEFAULT);
                    IUnitName_IPJ(
                        gx_->pGeo, &param1, reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                int32_t warped()
                {
                    int32_t ret = iWarped_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t warps_are_the_same(GXIPJPtr param1)
                {
                    int32_t ret = iWarpsAreTheSame_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t warps_are_the_same_within_a_small_tolerance(GXIPJPtr param1)
                {
                    int32_t ret = iWarpsAreTheSameWithinASmallTolerance_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t warps_are_the_same_to_specified_tolerance_with_feedback(GXIPJPtr param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_DEFAULT_LONG);
                    int32_t ret = iWarpsAreTheSameToSpecifiedToleranceWithFeedback_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                int32_t warp_type()
                {
                    int32_t ret = iWarpType_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void make_projected(double param1, double param2, double param3, double param4)
                {
                    MakeProjected_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void new_box_resolution(GXIPJPtr param1, double param2, double param3, double param4, double param5, double param6, double& param7, double& param8, double& param9)
                {
                    NewBoxResolution_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }
                void read(int32_t param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    Read_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                double get_method_parm(int32_t param1)
                {
                    double ret = rGetMethodParm_IPJ(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_north_azimuth(double param1, double param2)
                {
                    double ret = rGetNorthAzimuth_IPJ(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }
                static double unit_scale(const gx_string_type& param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rUnitScale_IPJ(
                                     gx_->pGeo, param1.c_str(), &param2);
                    gx_->throw_on_error();
                    return ret;
                }
                void serial(GXBFPtr param1)
                {
                    Serial_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void serial_fgdcxml(const gx_string_type& param1)
                {
                    SerialFGDCXML_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void serial_isoxml(const gx_string_type& param1)
                {
                    SerialISOXML_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void serial_xml(const gx_string_type& param1)
                {
                    SerialXML_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_3d_inverted(int32_t param1)
                {
                    Set3DInverted_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_3d_inverted_angles(int32_t param1)
                {
                    Set3DInvertedAngles_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_3d_view(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9)
                {
                    Set3DView_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }
                void set_3d_view_ex(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, int32_t param10, int32_t param11)
                {
                    Set3DViewEx_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                }
                void set_3d_view_from_axes(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12)
                {
                    Set3DViewFromAxes_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                }
                void set_crooked_section_view(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4)
                {
                    SetCrookedSectionView_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void set_depth_section_view(double param1)
                {
                    SetDepthSectionView_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_esri(const gx_string_type& param1)
                {
                    SetESRI_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_gxf(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    SetGXF_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                }
                void set_method_parm(int32_t param1, double param2)
                {
                    SetMethodParm_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                void set_mi_coord_sys(const gx_string_type& param1, const gx_string_type& param2)
                {
                    SetMICoordSys_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_normal_section_view(double param1, double param2, double param3, double param4, double param5)
                {
                    SetNormalSectionView_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                void set_plan_view(double param1, double param2, double param3, double param4)
                {
                    SetPlanView_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void set_section_view(double param1, double param2, double param3, double param4, double param5)
                {
                    SetSectionView_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                void set_wms_coord_sys(const gx_string_type& param1, double param2, double param3, double param4, double param5)
                {
                    SetWMSCoordSys_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                void set_xml(const gx_string_type& param1)
                {
                    SetXML_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_from_binary_as_string(const gx_string_type& param1)
                {
                    SetFromBinaryAsString_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void get_from_binary_as_string(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    GetFromBinaryAsString_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_3d_matrix_orientation(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13, double& param14, double& param15, double& param16)
                {
                    Get3DMatrixOrientation_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16);
                    gx_->throw_on_error();
                }
                void set_3d_matrix_orientation(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12, double param13, double param14, double param15, double param16)
                {
                    Set3DMatrixOrientation_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16);
                    gx_->throw_on_error();
                }
                void reproject_section_grid(GXIPJPtr param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    ReprojectSectionGrid_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                int32_t get_authority_id(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    int32_t ret = iGetAuthorityID_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }
                int32_t get_epsgid_for_datum()
                {
                    int32_t ret = iGetEPSGIDForDatum_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void add_as_favourite_coordinate_system()
                {
                    AddAsFavouriteCoordinateSystem_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static int32_t get_number_of_favourite_coordinate_systems()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetNumberOfFavouriteCoordinateSystems_IPJ(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static GXIPJPtr get_favourite_coordinate_system(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GetFavouriteCoordinateSystem_IPJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIPJ>(ret);
                }
                static void remove_favourite_coordinate_system(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveFavouriteCoordinateSystem_IPJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

            };
            class GXITR
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXITR(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXITRPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXITR>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void set_name(const gx_string_type& param1)
                {
                    SetName_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void get_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetName_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void change_brightness(double param1)
                {
                    ChangeBrightness_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void color_vv(GXVVPtr param1, GXVVPtr param2)
                {
                    ColorVV_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void copy(GXITRPtr param1)
                {
                    Copy_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXITRPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_ITR(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXITR>(ret);
                }
                static GXITRPtr create_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateFile_ITR(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXITR>(ret);
                }
                static GXITRPtr create_img(GXIMGPtr param1, const gx_string_type& param2, int32_t param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateIMG_ITR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXITR>(ret);
                }
                static GXITRPtr create_map(GXMAPPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateMap_ITR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXITR>(ret);
                }
                static GXITRPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_ITR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXITR>(ret);
                }
                ~GXITR()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void equal_area(GXSTPtr param1, double param2)
                {
                    EqualArea_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }
                void equal_area_or_linear(GXSTPtr param1, double param2)
                {
                    EqualAreaOrLinear_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }
                void get_data_limits(double& param1, double& param2)
                {
                    GetDataLimits_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                GXREGPtr get_reg()
                {
                    int32_t ret = GetREG_ITR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXREG>(ret);
                }
                void get_zone_color(int32_t param1, int32_t& param2)
                {
                    GetZoneColor_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }
                void get_zone_base_color(int32_t param1, int32_t& param2)
                {
                    GetZoneBaseColor_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }
                int32_t color_value(double param1)
                {
                    int32_t ret = iColorValue_ITR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_size()
                {
                    int32_t ret = iGetSize_ITR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_zone_model_type()
                {
                    int32_t ret = iGetZoneModelType_ITR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_zone_model(int32_t& param1, GXVVPtr param2)
                {
                    GetZoneModel_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void set_zone_model(int32_t param1, GXVVPtr param2)
                {
                    SetZoneModel_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void linear(double param1, double param2, double param3)
                {
                    Linear_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                void load_a(const gx_string_type& param1)
                {
                    LoadA_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void log_linear(double param1, double param2, double param3)
                {
                    LogLinear_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                void normal(double param1, double param2, double param3, double param4)
                {
                    Normal_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void power_zone(int32_t param1)
                {
                    PowerZone_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                double get_brightness()
                {
                    double ret = rGetBrightness_ITR(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_contrast()
                {
                    double ret = rGetContrast_ITR(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_contour()
                {
                    double ret = rGetContour_ITR(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_zone_value(int32_t param1)
                {
                    double ret = rGetZoneValue_ITR(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void save_a(const gx_string_type& param1)
                {
                    SaveA_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void save_file(const gx_string_type& param1)
                {
                    SaveFile_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void serial(GXBFPtr param1)
                {
                    Serial_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void set_agg_map(GXMAPPtr param1, const gx_string_type& param2, GXITRPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetAggMap_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void set_bright_contrast(double param1, double param2)
                {
                    SetBrightContrast_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void set_color_model(int32_t param1)
                {
                    SetColorModel_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static int32_t default_color_method()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDefaultColorMethod_ITR(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                void set_data_limits(double param1, double param2)
                {
                    SetDataLimits_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void set_size(int32_t param1)
                {
                    SetSize_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_zone_color(int32_t param1, int32_t param2)
                {
                    SetZoneColor_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_zone_base_color(int32_t param1, int32_t param2)
                {
                    SetZoneBaseColor_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_zone_active(int32_t param1, int32_t param2)
                {
                    SetZoneActive_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                int32_t get_zone_active(int32_t param1)
                {
                    int32_t ret = iGetZoneActive_ITR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_zone_value(int32_t param1, double param2)
                {
                    SetZoneValue_ITR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }

            };
            class GXKGRD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXKGRD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXKGRDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXKGRD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void clear()
                {
                    _Clear_KGRD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static GXKGRDPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_KGRD(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXKGRD>(ret);
                }
                ~GXKGRD()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_KGRD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t load_parms(const gx_string_type& param1)
                {
                    int32_t ret = iLoadParms_KGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t run(const gx_string_type& param1, GXDATPtr param2, GXDATPtr param3, GXDATPtr param4, const gx_string_type& param5, const gx_string_type& param6, int32_t param7, int32_t param8, int32_t param9)
                {
                    int32_t ret = iRun_KGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), param6.c_str(), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t run2(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRun2_KGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t run3(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, int32_t param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRun3_KGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t run_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXIPJPtr param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, int32_t param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRunVV_KGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t save_parms(const gx_string_type& param1)
                {
                    int32_t ret = iSaveParms_KGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_defaults(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, double& param5, int32_t& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GetDefaults_KGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), &param5, reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXKML
            {
            private:
                GXKML();
                ~GXKML();
            public:


                static int32_t import_3d_polygon(GXMVIEWPtr param1, const gx_string_type& param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Import3DPolygon_KML(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t import_3d_line_path(GXMVIEWPtr param1, const gx_string_type& param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Import3DLinePath_KML(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXLAYOUT
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXLAYOUT(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXLAYOUTPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXLAYOUT>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void calculate_rects(double& param1, double& param2, double& param3, double& param4)
                {
                    CalculateRects_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void clear_all()
                {
                    ClearAll_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void clear_constraints()
                {
                    ClearConstraints_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static GXLAYOUTPtr create(int32_t param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_LAYOUT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLAYOUT>(ret);
                }
                ~GXLAYOUT()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_rectangle(int32_t param1, double& param2, double& param3, double& param4, double& param5)
                {
                    GetRectangle_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                void get_rect_name(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    GetRectName_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t add_constraint(int32_t param1, int32_t param2, int32_t param3, int32_t param4, double param5, double param6)
                {
                    int32_t ret = iAddConstraint_LAYOUT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t add_rectangle(double param1, double param2, double param3, double param4)
                {
                    int32_t ret = iAddRectangle_LAYOUT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t num_rectangles()
                {
                    int32_t ret = iNumRectangles_LAYOUT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_rectangle(int32_t param1, double param2, double param3, double param4, double param5)
                {
                    SetRectangle_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                void set_rectangle_name(int32_t param1, const gx_string_type& param2)
                {
                    SetRectangleName_LAYOUT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXLL2
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXLL2(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXLL2Ptr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXLL2>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXLL2Ptr create(double param1, double param2, double param3, double param4, int32_t param5, int32_t param6, GXIPJPtr param7, GXIPJPtr param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_LL2(
                                      gx_->pGeo, &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLL2>(ret);
                }
                ~GXLL2()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_LL2(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void save(const gx_string_type& param1)
                {
                    Save_LL2(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_row(int32_t param1, GXVVPtr param2, GXVVPtr param3)
                {
                    SetRow_LL2(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

            };
            class GXLMSG
            {
            private:
                GXLMSG();
                ~GXLMSG();
            public:


                static void goto_line(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GotoLine_LMSG(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void goto_point(double param1, double param2, double param3, GXIPJPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GotoPoint_LMSG(
                        gx_->pGeo, &param1, &param2, &param3, reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void view_area(double param1, double param2, double param3, double param4, GXIPJPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ViewArea_LMSG(
                        gx_->pGeo, &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }

            };
            class GXLPT
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXLPT(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXLPTPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXLPT>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXLPTPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_LPT(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLPT>(ret);
                }
                ~GXLPT()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_LPT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_lst(GXLSTPtr param1)
                {
                    GetLST_LPT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_standard_lst(GXLSTPtr param1)
                {
                    GetStandardLST_LPT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

            };
            class GXLST
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXLST(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXLSTPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXLST>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_item(const gx_string_type& param1, const gx_string_type& param2)
                {
                    AddItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void add_symb_item(const gx_string_type& param1, int32_t param2)
                {
                    AddSymbItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void add_unique_item(const gx_string_type& param1, const gx_string_type& param2)
                {
                    AddUniqueItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void append(GXLSTPtr param1)
                {
                    Append_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXLSTPtr assay_channel()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = AssayChannel_LST(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLST>(ret);
                }
                void clear()
                {
                    Clear_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void convert_from_csv_string(const gx_string_type& param1)
                {
                    ConvertFromCSVString_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void copy(GXLSTPtr param1)
                {
                    Copy_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXLSTPtr create(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_LST(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLST>(ret);
                }
                static GXLSTPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_LST(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLST>(ret);
                }
                void del_item(int32_t param1)
                {
                    DelItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                ~GXLST()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void find_items(int32_t param1, GXLSTPtr param2, GXVVPtr param3)
                {
                    FindItems_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void gt_item(int32_t param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    GtItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                void gt_symb_item(int32_t param1, gx_string_type& param2, int32_t& param3)
                {
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    GtSymbItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void convert_to_csv_string(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IConvertToCSVString_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                int32_t find_item(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = iFindItem_LST(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t find_item_mask(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = iFindItemMask_LST(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_int(int32_t param1, int32_t param2)
                {
                    int32_t ret = iGetInt_LST(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void insert_item(int32_t param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    InsertItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                int32_t size()
                {
                    int32_t ret = iSize_LST(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void load_csv(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    LoadCSV_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                void load_file(const gx_string_type& param1)
                {
                    LoadFile_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void resource(const gx_string_type& param1)
                {
                    Resource_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                double get_double(int32_t param1, int32_t param2)
                {
                    double ret = rGetReal_LST(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void save_file(const gx_string_type& param1)
                {
                    SaveFile_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void select_csv_string_items(const gx_string_type& param1, GXLSTPtr param2)
                {
                    SelectCSVStringItems_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void serial(GXBFPtr param1)
                {
                    Serial_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_item(int32_t param1, int32_t param2, const gx_string_type& param3)
                {
                    SetItem_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                void sort(int32_t param1, int32_t param2)
                {
                    Sort_LST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

            };
            class GXLTB
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXLTB(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXLTBPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXLTB>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_record(const gx_string_type& param1, int32_t& param2)
                {
                    AddRecord_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }
                GXLTBPtr contract(GXLTBPtr param1)
                {
                    int32_t ret = Contract_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLTB>(ret);
                }
                static GXLTBPtr create(const gx_string_type& param1, int32_t param2, int32_t param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_LTB(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLTB>(ret);
                }
                static GXLTBPtr create_crypt(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateCrypt_LTB(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLTB>(ret);
                }
                static GXLTBPtr create_ex(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateEx_LTB(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLTB>(ret);
                }
                void delete_record(int32_t param1)
                {
                    DeleteRecord_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                ~GXLTB()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_con_lst(int32_t param1, const gx_string_type& param2, int32_t param3, GXLSTPtr param4)
                {
                    GetConLST_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void get_lst(int32_t param1, GXLSTPtr param2)
                {
                    GetLST_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void get_lst2(int32_t param1, int32_t param2, GXLSTPtr param3)
                {
                    GetLST2_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                int32_t fields()
                {
                    int32_t ret = iFields_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t find_field(const gx_string_type& param1)
                {
                    int32_t ret = iFindField_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t find_key(const gx_string_type& param1)
                {
                    int32_t ret = iFindKey_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void get_field(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    IGetField_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t get_int(int32_t param1, int32_t param2)
                {
                    int32_t ret = iGetInt_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_string(int32_t param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    IGetString_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                void get_english_string(int32_t param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    IGetEnglishString_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                int32_t records()
                {
                    int32_t ret = iRecords_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t search(int32_t param1, int32_t param2, const gx_string_type& param3)
                {
                    int32_t ret = iSearch_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                GXLTBPtr merge(GXLTBPtr param1)
                {
                    int32_t ret = Merge_LTB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLTB>(ret);
                }
                double get_double(int32_t param1, int32_t param2)
                {
                    double ret = rGetReal_LTB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void save(const gx_string_type& param1)
                {
                    Save_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void save_crypt(const gx_string_type& param1, const gx_string_type& param2)
                {
                    SaveCrypt_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_int(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetInt_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void set_double(int32_t param1, int32_t param2, double param3)
                {
                    SetReal_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }
                void set_string(int32_t param1, int32_t param2, const gx_string_type& param3)
                {
                    SetString_LTB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXMAP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMAP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMAPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMAP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void export_all_in_view(const gx_string_type& param1, const gx_string_type& param2, double param3, double param4, int32_t param5, int32_t param6, const gx_string_type& param7, const gx_string_type& param8)
                {
                    ExportAllInView_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), param7.c_str(), param8.c_str());
                    gx_->throw_on_error();
                }
                void export_all_raster(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4, double param5, int32_t param6, int32_t param7, const gx_string_type& param8, const gx_string_type& param9)
                {
                    ExportAllRaster_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), param8.c_str(), param9.c_str());
                    gx_->throw_on_error();
                }
                void export_area_in_view(const gx_string_type& param1, const gx_string_type& param2, double param3, double param4, int32_t param5, int32_t param6, double param7, double param8, double param9, double param10, const gx_string_type& param11, const gx_string_type& param12)
                {
                    ExportAreaInView_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8, &param9, &param10, param11.c_str(), param12.c_str());
                    gx_->throw_on_error();
                }
                void export_area_raster(const gx_string_type& param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, int32_t param7, int32_t param8, double param9, int32_t param10, int32_t param11, const gx_string_type& param12, const gx_string_type& param13)
                {
                    ExportAreaRaster_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), param12.c_str(), param13.c_str());
                    gx_->throw_on_error();
                }
                void rename_view(const gx_string_type& param1, const gx_string_type& param2)
                {
                    RenameView_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void render_bitmap(const gx_string_type& param1, double param2, double param3, double param4, double param5, const gx_string_type& param6, int32_t param7)
                {
                    RenderBitmap_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, param6.c_str(), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                void render_view_bitmap(GXMVIEWPtr param1, int32_t param2, double param3, double param4, double param5, double param6, const gx_string_type& param7, int32_t param8)
                {
                    RenderViewBitmap_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, &param4, &param5, &param6, param7.c_str(), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                void create_linked_3d_view(GXMVIEWPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6)
                {
                    CreateLinked3DView_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void agg_list(GXLSTPtr param1, int32_t param2)
                {
                    AGGList_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void agg_list_ex(GXLSTPtr param1, int32_t param2, int32_t param3)
                {
                    AGGListEx_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void clean()
                {
                    Clean_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void delete_empty_groups()
                {
                    DeleteEmptyGroups_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void commit()
                {
                    Commit_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void copy_map_to_view(const gx_string_type& param1, const gx_string_type& param2)
                {
                    CopyMapToView_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void crc_map(int32_t& param1, const gx_string_type& param2)
                {
                    CRCMap_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                static GXMAPPtr create(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MAP(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAP>(ret);
                }
                static GXMAPPtr current()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_Current_MAP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAP>(ret);
                }
                void delete_view(const gx_string_type& param1)
                {
                    DeleteView_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                ~GXMAP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void discard()
                {
                    Discard_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void dup_map(GXMAPPtr param1, int32_t param2)
                {
                    DupMap_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                GXLPTPtr get_lpt()
                {
                    int32_t ret = GetLPT_MAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLPT>(ret);
                }
                void get_map_size(double& param1, double& param2, double& param3, double& param4)
                {
                    GetMapSize_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                GXMETAPtr get_meta()
                {
                    int32_t ret = GetMETA_MAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMETA>(ret);
                }
                GXREGPtr get_reg()
                {
                    int32_t ret = GetREG_MAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXREG>(ret);
                }
                void group_list(GXLSTPtr param1)
                {
                    GroupList_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void group_list_ex(GXLSTPtr param1, int32_t param2)
                {
                    GroupListEx_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void duplicate_view(const gx_string_type& param1, gx_string_type& param2, int32_t param3)
                {
                    int32_t paramSize3 = STR_VIEW * STRING_CHAR_SIZE;
                    param2.resize(STR_VIEW);
                    IDuplicateView_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t exist_view(const gx_string_type& param1)
                {
                    int32_t ret = iExistView_MAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void get_class_name(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IGetClassName_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void get_file_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetFileName_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_map_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetMapName_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                int32_t packed_files()
                {
                    int32_t ret = iPackedFiles_MAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void un_pack_files_ex(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_MULTI_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_MULTI_FILE);
                    IUnPackFilesEx_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void un_pack_files_to_folder(int32_t param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_MULTI_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_MULTI_FILE);
                    IUnPackFilesToFolder_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                void pack_files()
                {
                    PackFiles_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void render(const gx_string_type& param1)
                {
                    Render_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void resize_all()
                {
                    ResizeAll_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void resize_all_ex(int32_t param1)
                {
                    ResizeAllEx_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                double get_map_scale()
                {
                    double ret = rGetMapScale_MAP(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void save_as_mxd(const gx_string_type& param1)
                {
                    SaveAsMXD_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_class_name(const gx_string_type& param1, const gx_string_type& param2)
                {
                    SetClassName_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_current()
                {
                    App_SetCurrent_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void set_map_name(const gx_string_type& param1)
                {
                    SetMapName_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_map_scale(double param1)
                {
                    SetMapScale_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_map_size(double param1, double param2, double param3, double param4)
                {
                    SetMapSize_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_reg(GXREGPtr param1)
                {
                    SetREG_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void sync(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Sync_MAP(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                void un_pack_files()
                {
                    UnPackFiles_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void view_list(GXLSTPtr param1)
                {
                    ViewList_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void view_list_ex(GXLSTPtr param1, int32_t param2)
                {
                    ViewListEx_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                int32_t get_data_proj()
                {
                    int32_t ret = GetDataProj_MAP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void dataset_file_path_list(GXLSTPtr param1)
                {
                    DatasetFilePathList_MAP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

            };
            class GXMAPL
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMAPL(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMAPLPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMAPL>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXMAPLPtr create(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MAPL(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAPL>(ret);
                }
                static GXMAPLPtr create_reg(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, GXREGPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateREG_MAPL(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAPL>(ret);
                }
                ~GXMAPL()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_MAPL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void process(GXMAPPtr param1)
                {
                    Process_MAPL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void replace_string(const gx_string_type& param1, const gx_string_type& param2)
                {
                    ReplaceString_MAPL(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXMAPTEMPLATE
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMAPTEMPLATE(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMAPTEMPLATEPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMAPTEMPLATE>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void get_tmp_copy(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    GetTmpCopy_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void update_from_tmp_copy(const gx_string_type& param1)
                {
                    UpdateFromTmpCopy_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void commit()
                {
                    Commit_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static GXMAPTEMPLATEPtr create(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MAPTEMPLATE(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAPTEMPLATE>(ret);
                }
                ~GXMAPTEMPLATE()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void discard()
                {
                    Discard_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void get_file_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    GetFileName_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void create_map(const gx_string_type& param1, const gx_string_type& param2)
                {
                    CreateMap_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void refresh()
                {
                    Refresh_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void render_preview(HDC param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    RenderPreview_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1, reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                void render_preview_map_production(HDC param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5)
                {
                    RenderPreviewMapProduction_MAPTEMPLATE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1, reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                }
                static void get_media_size(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetMediaSize_MAPTEMPLATE(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }

            };
            class GXMATH
            {
            private:
                GXMATH();
                ~GXMATH();
            public:


                static void cross_product_(double param1, double param2, double param3, double param4, double param5, double param6, double& param7, double& param8, double& param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CrossProduct_MATH(
                        gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }
                static int32_t abs_int_(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iAbs_MATH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t and_(int32_t param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iAnd_MATH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t mod_int_(int32_t param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iMod_MATH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t or_(int32_t param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iOr_MATH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t round_int_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRound_MATH(
                                      gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t xor_(int32_t param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iXor_MATH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static void nicer_log_scale_(double& param1, double& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NicerLogScale_MATH(
                        gx_->pGeo, &param1, &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void nicer_scale_(double& param1, double& param2, double& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NicerScale_MATH(
                        gx_->pGeo, &param1, &param2, &param3, reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }
                static void normalise_3d_(double& param1, double& param2, double& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Normalise3D_MATH(
                        gx_->pGeo, &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                static double abs_double_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rAbs_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double arc_cos_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rArcCos_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double arc_sin_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rArcSin_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double arc_tan_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rArcTan_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double arc_tan2_(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rArcTan2_MATH(
                                     gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }
                static double ceil_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rCeil_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double cos_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rCos_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double dot_product_3d_(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rDotProduct3D_MATH(
                                     gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                    return ret;
                }
                static double exp_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rExp_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double floor_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rFloor_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double hypot_(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rHypot_MATH(
                                     gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }
                static double lambda_trans_(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rLambdaTrans_MATH(
                                     gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }
                static double lambda_trans_rev_(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rLambdaTransRev_MATH(
                                     gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }
                static double log_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rLog_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double log10_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rLog10_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double log_z_(double param1, int32_t param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rLogZ_MATH(
                                     gx_->pGeo, &param1, reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                    return ret;
                }
                static double mod_double_(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rMod_MATH(
                                     gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }
                static void rotate_vector_(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double& param8, double& param9, double& param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RotateVector_MATH(
                        gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                }
                static double pow_(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rPow_MATH(
                                     gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }
                static double rand_()
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rRand_MATH(
                                     gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static double round_double_(double param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rRound_MATH(
                                     gx_->pGeo, &param1, reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static double sign_(double param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rSign_MATH(
                                     gx_->pGeo, &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }
                static double sin_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rSin_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double sqrt_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rSqrt_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double tan_(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rTan_MATH(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double un_log_z_(double param1, int32_t param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rUnLogZ_MATH(
                                     gx_->pGeo, &param1, reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                    return ret;
                }
                static void s_rand_()
                {
                    GXContextPtr gx_ = GXContext::current();
                    SRand_MATH(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }

            };
            class GXMESH
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMESH(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMESHPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMESH>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXMESHPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MESH(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMESH>(ret);
                }
                static GXMESHPtr open(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Open_MESH(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMESH>(ret);
                }
                int32_t insert_patch(const gx_string_type& param1)
                {
                    int32_t ret = InsertPatch_MESH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void delete_patch(const gx_string_type& param1, int32_t param2)
                {
                    DeletePatch_MESH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                int32_t patch_exists(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = PatchExists_MESH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t num_patches(const gx_string_type& param1)
                {
                    int32_t ret = NumPatches_MESH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t add_vertex(const gx_string_type& param1, int32_t param2, double param3, double param4, double param5)
                {
                    int32_t ret = AddVertex_MESH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), &param3, &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t num_vertices(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = NumVertices_MESH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t add_face(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    int32_t ret = AddFace_MESH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t num_faces(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = NumFaces_MESH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_vertex_point(const gx_string_type& param1, int32_t param2, int32_t param3, double& param4, double& param5, double& param6)
                {
                    int32_t ret = GetVertexPoint_MESH(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6);
                    gx_->throw_on_error();
                    return ret;
                }
                void get_vertices(const gx_string_type& param1, int32_t param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5)
                {
                    GetVertices_MESH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                void get_faces(const gx_string_type& param1, int32_t param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5)
                {
                    GetFaces_MESH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                void insert_attributes(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    InsertAttributes_MESH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void set_attribute_values(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5, GXVVPtr param6)
                {
                    SetAttributeValues_MESH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                void get_attribute_values(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5, GXVVPtr param6)
                {
                    GetAttributeValues_MESH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static GXMESHPtr import_grid_to_mesh(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = ImportGridToMesh_MESH(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMESH>(ret);
                }
                void save()
                {
                    Save_MESH(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

            };
            class GXMESHUTIL
            {
            private:
                GXMESHUTIL();
                ~GXMESHUTIL();
            public:


                static void import_grid_to_surface(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportGridToSurface_MESHUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static int32_t clip_surface_with_grid(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = ClipSurfaceWithGrid_MESHUTIL(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str(), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t clip_surface_with_extents(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, double param5, double param6, double param7, double param8, double param9, double param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = ClipSurfaceWithExtents_MESHUTIL(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), &param5, &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t clip_surface_with_polygon2d(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = ClipSurfaceWithPolygon2d_MESHUTIL(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                    return ret;
                }
                static void compute_surface_union(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ComputeSurfaceUnion_MESHUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }
                static void compute_surface_clip(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ComputeSurfaceClip_MESHUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }
                static void compute_surface_intersection(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ComputeSurfaceIntersection_MESHUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }
                static void compute_surface_simplification(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ComputeSurfaceSimplification_MESHUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                static void compute_surface_subdivision(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ComputeSurfaceSubdivision_MESHUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                static int32_t does_surface_intersect(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = DoesSurfaceIntersect_MESHUTIL(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t does_surface_self_intersect(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = DoesSurfaceSelfIntersect_MESHUTIL(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void extract_isosurface_from_voxel(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, double param4, double param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExtractIsosurfaceFromVoxel_MESHUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), &param4, &param5, reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void reproject_geosurface_file(const gx_string_type& param1, const gx_string_type& param2, GXIPJPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReprojectGeosurfaceFile_MESHUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void project_geosurface_onto_grid(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProjectGeosurfaceOntoGrid_MESHUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), param5.c_str());
                    gx_->throw_on_error();
                }
                static void copy_mesh_to_geo_surface_file(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CopyMeshToGeoSurfaceFile_MESHUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void apply_transformation(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, double param6, double param7, double param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ApplyTransformation_MESHUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, &param7, &param8);
                    gx_->throw_on_error();
                }

            };
            class GXMETA
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMETA(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMETAPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMETA>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                int32_t create_attrib(const gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    int32_t ret = CreateAttrib_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                void delete_attrib(int32_t param1)
                {
                    DeleteAttrib_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_attribute_editable(int32_t param1, int32_t param2)
                {
                    SetAttributeEditable_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_attribute_visible(int32_t param1, int32_t param2)
                {
                    SetAttributeVisible_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                int32_t create_class(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = CreateClass_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void delete_class(int32_t param1)
                {
                    DeleteClass_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void copy(GXMETAPtr param1)
                {
                    Copy_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXMETAPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_META(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMETA>(ret);
                }
                static GXMETAPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMETA>(ret);
                }
                ~GXMETA()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void serial(GXBFPtr param1)
                {
                    Serial_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                int32_t find_data(int32_t param1, int32_t param2)
                {
                    int32_t ret = FindData_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_attrib_bool(int32_t param1, int32_t param2, int32_t& param3)
                {
                    GetAttribBool_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }
                void get_attrib_enum(int32_t param1, int32_t param2, int32_t& param3)
                {
                    GetAttribEnum_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }
                void get_attrib_int(int32_t param1, int32_t param2, int32_t& param3)
                {
                    GetAttribInt_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }
                void get_attrib_double(int32_t param1, int32_t param2, double& param3)
                {
                    GetAttribReal_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }
                void get_attrib_string(int32_t param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    IGetAttribString_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                int32_t has_value(int32_t param1, int32_t param2)
                {
                    int32_t ret = iHasValue_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void export_table_csv(int32_t param1, const gx_string_type& param2)
                {
                    ExportTableCSV_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void import_table_csv(int32_t param1, const gx_string_type& param2)
                {
                    ImportTableCSV_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void write_text(GXWAPtr param1)
                {
                    WriteText_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void delete_all_items(int32_t param1)
                {
                    DeleteAllItems_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void delete_item(int32_t param1)
                {
                    DeleteItem_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                int32_t h_creat_item(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = hCreatItem_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t h_get_next_item(int32_t param1, int32_t param2)
                {
                    int32_t ret = hGetNextItem_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_attrib_obj(int32_t param1, int32_t param2, int32_t param3)
                {
                    GetAttribOBJ_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void set_attrib_obj(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetAttribOBJ_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void set_attrib_bool(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetAttribBool_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void set_attrib_enum(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetAttribEnum_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void set_attrib_int(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetAttribInt_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void set_attrib_double(int32_t param1, int32_t param2, double param3)
                {
                    SetAttribReal_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }
                void set_attrib_string(int32_t param1, int32_t param2, const gx_string_type& param3)
                {
                    SetAttribString_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                void set_empty_attrib(int32_t param1, int32_t param2)
                {
                    SetEmptyAttrib_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                int32_t h_copy_across_attribute(GXMETAPtr param1, int32_t param2)
                {
                    int32_t ret = hCopyAcrossAttribute_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t h_copy_across_class(GXMETAPtr param1, int32_t param2)
                {
                    int32_t ret = hCopyAcrossClass_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t h_copy_across_data(GXMETAPtr param1, int32_t param2)
                {
                    int32_t ret = hCopyAcrossData_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t h_copy_across_item(GXMETAPtr param1, int32_t param2)
                {
                    int32_t ret = hCopyAcrossItem_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t h_copy_across_type(GXMETAPtr param1, int32_t param2)
                {
                    int32_t ret = hCopyAcrossType_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void move_datas_across(GXMETAPtr param1, int32_t param2, int32_t param3)
                {
                    MoveDatasAcross_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                int32_t create_type(const gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    int32_t ret = CreateType_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                void delete_data(int32_t param1)
                {
                    DeleteData_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void delete_type(int32_t param1)
                {
                    DeleteType_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void get_obj_name(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    IGetObjName_META(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t resolve_umn(const gx_string_type& param1)
                {
                    int32_t ret = ResolveUMN_META(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXMISC
            {
            private:
                GXMISC();
                ~GXMISC();
            public:


                static void convert_cg3to_raw(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertCG3toRAW_MISC(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void convert_cg5to_raw(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertCG5toRAW_MISC(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void ukoa2_tbl(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Ukoa2Tbl_MISC(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXMPLY
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMPLY(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMPLYPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMPLY>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXMPLYPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MPLY(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMPLY>(ret);
                }
                ~GXMPLY()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_MPLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }

            };
            class GXMSTK
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMSTK(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMSTKPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMSTK>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                GXSTKPtr add_stk()
                {
                    int32_t ret = AddSTK_MSTK(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSTK>(ret);
                }
                void chan_list_vv(GXDBPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6)
                {
                    ChanListVV_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static GXMSTKPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MSTK(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMSTK>(ret);
                }
                ~GXMSTK()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void draw_profile(GXDBPtr param1, int32_t param2, GXMAPPtr param3)
                {
                    DrawProfile_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void set_y_axis_direction(int32_t param1)
                {
                    SetYAxisDirection_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void find_stk2(const gx_string_type& param1, int32_t& param2, GXVVPtr param3)
                {
                    FindSTK2_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                GXSTKPtr get_stk(int32_t param1)
                {
                    int32_t ret = GetSTK_MSTK(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSTK>(ret);
                }
                void delete_stk(int32_t param1)
                {
                    IDelete_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void find_stk(const gx_string_type& param1, int32_t& param2, gx_string_type& param3, gx_string_type& param4, gx_string_type& param5)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize8 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    param4.resize(STR_VERY_LONG);
                    param5.resize(STR_VERY_LONG);
                    IFindSTK_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize6 ), (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize8 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param5.resize(gx_string_len(param5.c_str()));
                }
                int32_t get_num_stk()
                {
                    int32_t ret = iGetNumSTK_MSTK(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void read_ini(GXRAPtr param1)
                {
                    ReadINI_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void save_profile(GXWAPtr param1)
                {
                    SaveProfile_MSTK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

            };
            class GXMULTIGRID3D
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMULTIGRID3D(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMULTIGRID3DPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMULTIGRID3D>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXMULTIGRID3DPtr open(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Open_MULTIGRID3D(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMULTIGRID3D>(ret);
                }
                static GXMULTIGRID3DPtr modify(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Modify_MULTIGRID3D(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMULTIGRID3D>(ret);
                }
                static GXMULTIGRID3DPtr create(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MULTIGRID3D(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMULTIGRID3D>(ret);
                }
                GXMULTIGRID3DPtr duplicate(const gx_string_type& param1)
                {
                    int32_t ret = Duplicate_MULTIGRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMULTIGRID3D>(ret);
                }
                GXGRID3DPtr get_default()
                {
                    int32_t ret = GetDefault_MULTIGRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXGRID3D>(ret);
                }
                GXGRID3DPtr create_default(int32_t param1)
                {
                    int32_t ret = CreateDefault_MULTIGRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXGRID3D>(ret);
                }
                int32_t is_uniform_cell_size_x()
                {
                    int32_t ret = iIsUniformCellSizeX_MULTIGRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_uniform_cell_size_y()
                {
                    int32_t ret = iIsUniformCellSizeY_MULTIGRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_uniform_cell_size_z()
                {
                    int32_t ret = iIsUniformCellSizeZ_MULTIGRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_size_x()
                {
                    int32_t ret = GetSizeX_MULTIGRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_size_y()
                {
                    int32_t ret = GetSizeY_MULTIGRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_size_z()
                {
                    int32_t ret = GetSizeZ_MULTIGRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_cell_sizes_x(GXVVPtr param1)
                {
                    GetCellSizesX_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_cell_sizes_y(GXVVPtr param1)
                {
                    GetCellSizesY_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_cell_sizes_z(GXVVPtr param1)
                {
                    GetCellSizesZ_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_cell_sizes_x(GXVVPtr param1)
                {
                    SetCellSizesX_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_cell_sizes_y(GXVVPtr param1)
                {
                    SetCellSizesY_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_cell_sizes_z(GXVVPtr param1)
                {
                    SetCellSizesZ_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                double get_uniform_cell_size_x()
                {
                    double ret = rGetUniformCellSizeX_MULTIGRID3D(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_uniform_cell_size_y()
                {
                    double ret = rGetUniformCellSizeY_MULTIGRID3D(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_uniform_cell_size_z()
                {
                    double ret = rGetUniformCellSizeZ_MULTIGRID3D(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_uniform_cell_size_x(double param1)
                {
                    SetUniformCellSizeX_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_uniform_cell_size_y(double param1)
                {
                    SetUniformCellSizeY_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_uniform_cell_size_z(double param1)
                {
                    SetUniformCellSizeZ_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void get_origin(double& param1, double& param2, double& param3)
                {
                    GetOrigin_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                void set_origin(double param1, double param2, double param3)
                {
                    SetOrigin_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                void get_bounding_box(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetBoundingBox_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void get_volume_vectors(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12)
                {
                    GetVolumeVectors_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                }
                void get_oriented_data_extents(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12, double& param13, double& param14, double& param15, double& param16, double& param17, double& param18)
                {
                    GetOrientedDataExtents_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18);
                    gx_->throw_on_error();
                }
                void get_section_cell_sizes(double param1, double param2, double param3, double param4, double param5, double& param6, double& param7)
                {
                    GetSectionCellSizes_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }
                void get_vector_orientation(double& param1, double& param2, int32_t& param3)
                {
                    GetVectorOrientation_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }
                void fill(const gx_string_type& param1, int32_t param2, double param3)
                {
                    Fill_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }
                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void export_to_xyz(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    ExportToXYZ_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                void export_to_binary(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    ExportToBinary_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                void export_to_binary_ex(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7, int32_t param8)
                {
                    ExportToBinaryEx_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                void export_to_xml(const gx_string_type& param1)
                {
                    ExportToXML_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void export_to_wa(GXWAPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, const gx_string_type& param6)
                {
                    ExportToWA_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str());
                    gx_->throw_on_error();
                }
                void export_to_gdb(GXDBPtr param1, const gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    ExportToGDB_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                GXPGPtr export_to_pg()
                {
                    int32_t ret = ExportToPG_MULTIGRID3D(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }
                void get_data_extents(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5, int32_t& param6)
                {
                    GetDataExtents_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                }
                void get_data_ground_extents(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetDataGroundExtents_MULTIGRID3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

            };
            class GXMULTIGRID3DUTIL
            {
            private:
                GXMULTIGRID3DUTIL();
                ~GXMULTIGRID3DUTIL();
            public:


                static void import_from_xyz(const gx_string_type& param1, GXRAPtr param2, int32_t param3, GXIPJPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportFromXYZ_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void export_to_xyz(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportToXYZ_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void export_to_binary(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportToBinary_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void export_to_binary_ex(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, double param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportToBinaryEx_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                static void export_to_xml(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportToXML_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void check_equal_to_legacy_voxel(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CheckEqualToLegacyVoxel_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void import_from_ubc(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, double param4, GXIPJPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportFromUBC_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), &param4, reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void import_from_gocad(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, GXIPJPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportFromGOCAD_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void list_properties_gocad(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ListPropertiesGOCAD_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void import_from_gdb(const gx_string_type& param1, GXDBPtr param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportFromGDB_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void import_from_gdb_ignore_stored_voxel_geometry(const gx_string_type& param1, GXDBPtr param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportFromGDBIgnoreStoredVoxelGeometry_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static int32_t database_contains_voxel_geometry(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDatabaseContainsVoxelGeometry_MULTIGRID3DUTIL(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                static void import_from_vector_gdb(const gx_string_type& param1, GXDBPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7, double param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportFromVectorGDB_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8);
                    gx_->throw_on_error();
                }
                static void export_to_segy(const gx_string_type& param1, const gx_string_type& param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportToSEGY_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3);
                    gx_->throw_on_error();
                }
                static void export_to_gdb(const gx_string_type& param1, GXDBPtr param2, const gx_string_type& param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportToGDB_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void export_to_wa(const gx_string_type& param1, GXWAPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, const gx_string_type& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportToWA_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), param7.c_str());
                    gx_->throw_on_error();
                }
                static void convert_double_to_vector(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, double param5, double param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertDoubleToVector_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), &param5, &param6, reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void convert_vector_to_double(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertVectorToDouble_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void convert_vector_to_double_using_rotation(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertVectorToDoubleUsingRotation_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), &param5, &param6);
                    gx_->throw_on_error();
                }
                static void convert_thematic_to_double(const gx_string_type& param1, GXVVPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertThematicToDouble_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }
                static void convert_double_to_thematic(const gx_string_type& param1, GXVVPtr param2, GXTPATPtr param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertDoubleToThematic_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str());
                    gx_->throw_on_error();
                }
                static void convert_velocity_to_density(const gx_string_type& param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11, const gx_string_type& param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertVelocityToDensity_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, param12.c_str());
                    gx_->throw_on_error();
                }
                static void convert_density_to_velocity(const gx_string_type& param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11, const gx_string_type& param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertDensityToVelocity_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, param12.c_str());
                    gx_->throw_on_error();
                }
                static void get_gocad_location(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12, double& param13)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetGOCADLocation_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13);
                    gx_->throw_on_error();
                }
                static void create_double_constant(const gx_string_type& param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, int32_t param9, int32_t param10, int32_t param11, GXIPJPtr param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateDoubleConstant_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&gx_->handle(param12)));
                    gx_->throw_on_error();
                }
                static void create_double_constant_copy(const gx_string_type& param1, double param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateDoubleConstantCopy_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), &param2, param3.c_str());
                    gx_->throw_on_error();
                }
                static void create_thematic_constant(const gx_string_type& param1, int32_t param2, double param3, double param4, double param5, double param6, double param7, double param8, int32_t param9, int32_t param10, int32_t param11, GXIPJPtr param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateThematicConstant_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), &param3, &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&gx_->handle(param12)));
                    gx_->throw_on_error();
                }
                static void create_vector_constant(const gx_string_type& param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, int32_t param11, int32_t param12, int32_t param13, GXIPJPtr param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateVectorConstant_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13), reinterpret_cast<const long*>(&gx_->handle(param14)));
                    gx_->throw_on_error();
                }
                static void create_double_constant_vv(const gx_string_type& param1, double param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXIPJPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateDoubleConstantVV_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }
                static void create_thematic_constant_vv(const gx_string_type& param1, int32_t param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXIPJPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateThematicConstantVV_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }
                static void create_vector_constant_vv(const gx_string_type& param1, double param2, double param3, double param4, double param5, double param6, double param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10, GXIPJPtr param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateVectorConstantVV_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)));
                    gx_->throw_on_error();
                }
                static void export_to_voxel(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportToVoxel_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                static void import_from_voxel(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param4.resize(STR_DEFAULT_LONG);
                    ImportFromVoxel_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }
                static void import_from_datamine(const gx_string_type& param1, const gx_string_type& param2, GXIPJPtr param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportFromDATAMINE_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str());
                    gx_->throw_on_error();
                }
                static double compute_default_cell_size(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rComputeDefaultCellSize_MULTIGRID3DUTIL(
                                     gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                    return ret;
                }
                static void filter(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, const gx_string_type& param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Filter_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void invert_z(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    InvertZ_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void extract_dem(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExtractDEM_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void clip_to_polygon(const gx_string_type& param1, const gx_string_type& param2, GXPLYPtr param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClipToPolygon_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void grid_direct_from_gdb(const gx_string_type& param1, double param2, double param3, double param4, int32_t param5, int32_t param6, int32_t param7, double param8, double param9, double param10, int32_t param11, GXDBPtr param12, int32_t param13, int32_t param14, int32_t param15, int32_t param16)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridDirectFromGDB_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), &param8, &param9, &param10, reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&param13), reinterpret_cast<const long*>(&param14), reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16));
                    gx_->throw_on_error();
                }
                static void grid_idw_from_gdb(const gx_string_type& param1, double param2, double param3, double param4, int32_t param5, int32_t param6, int32_t param7, double param8, double param9, double param10, GXDBPtr param11, int32_t param12, int32_t param13, int32_t param14, int32_t param15, double param16, double param17, double param18, double param19, int32_t param20, double param21, int32_t param22)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridIDWFromGDB_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), &param8, &param9, &param10, reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13), reinterpret_cast<const long*>(&param14), reinterpret_cast<const long*>(&param15), &param16, &param17, &param18, &param19, reinterpret_cast<const long*>(&param20), &param21, reinterpret_cast<const long*>(&param22));
                    gx_->throw_on_error();
                }
                static void get_data_extents(const gx_string_type& param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5, int32_t& param6, int32_t& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetDataExtents_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6), reinterpret_cast<long*>(&param7));
                    gx_->throw_on_error();
                }
                static void get_data_ground_extents(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetDataGroundExtents_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }
                static void grid_points_from_gdb(const gx_string_type& param1, const gx_string_type& param2, double param3, int32_t param4, double param5, double param6, int32_t param7, int32_t param8, int32_t param9, double param10, double param11, double param12, double param13, double param14, int32_t param15, GXDBPtr param16, int32_t param17, int32_t param18, int32_t param19, int32_t param20, GXIPJPtr param21)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridPointsFromGDB_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3, reinterpret_cast<const long*>(&param4), &param5, &param6, reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11, &param12, &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&gx_->handle(param16)), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&param20), reinterpret_cast<const long*>(&gx_->handle(param21)));
                    gx_->throw_on_error();
                }
                static void grid_points_z_from_gdb(const gx_string_type& param1, const gx_string_type& param2, double param3, const gx_string_type& param4, int32_t param5, double param6, double param7, int32_t param8, int32_t param9, int32_t param10, double param11, double param12, double param13, double param14, double param15, int32_t param16, GXDBPtr param17, int32_t param18, int32_t param19, int32_t param20, int32_t param21, GXIPJPtr param22)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridPointsZFromGDB_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&param20), reinterpret_cast<const long*>(&param21), reinterpret_cast<const long*>(&gx_->handle(param22)));
                    gx_->throw_on_error();
                }
                static void grid_points_z_ex_from_gdb(const gx_string_type& param1, const gx_string_type& param2, double param3, const gx_string_type& param4, int32_t param5, double param6, double param7, int32_t param8, int32_t param9, int32_t param10, double param11, double& param12, double& param13, double param14, double& param15, double param16, double param17, double param18, double param19, double param20, int32_t param21, GXDBPtr param22, int32_t param23, int32_t param24, int32_t param25, int32_t param26, GXIPJPtr param27)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridPointsZExFromGDB_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18, &param19, &param20, reinterpret_cast<const long*>(&param21), reinterpret_cast<const long*>(&gx_->handle(param22)), reinterpret_cast<const long*>(&param23), reinterpret_cast<const long*>(&param24), reinterpret_cast<const long*>(&param25), reinterpret_cast<const long*>(&param26), reinterpret_cast<const long*>(&gx_->handle(param27)));
                    gx_->throw_on_error();
                }
                static void log_grid_points_z_ex_from_gdb(const gx_string_type& param1, const gx_string_type& param2, double param3, const gx_string_type& param4, int32_t param5, double param6, double param7, int32_t param8, int32_t param9, int32_t param10, double param11, double& param12, double& param13, double param14, double& param15, double param16, double param17, double param18, double param19, double param20, int32_t param21, double param22, int32_t param23, GXDBPtr param24, int32_t param25, int32_t param26, int32_t param27, int32_t param28, GXIPJPtr param29)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LogGridPointsZExFromGDB_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18, &param19, &param20, reinterpret_cast<const long*>(&param21), &param22, reinterpret_cast<const long*>(&param23), reinterpret_cast<const long*>(&gx_->handle(param24)), reinterpret_cast<const long*>(&param25), reinterpret_cast<const long*>(&param26), reinterpret_cast<const long*>(&param27), reinterpret_cast<const long*>(&param28), reinterpret_cast<const long*>(&gx_->handle(param29)));
                    gx_->throw_on_error();
                }
                static void krig_from_gdb(const gx_string_type& param1, double param2, int32_t param3, GXDBPtr param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, GXIPJPtr param9, GXREGPtr param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    KrigFromGDB_MULTIGRID3DUTIL(
                        gx_->pGeo, param1.c_str(), &param2, reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)));
                    gx_->throw_on_error();
                }
                static GXMULTIGRID3DPtr create_subset(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateSubset_MULTIGRID3DUTIL(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMULTIGRID3D>(ret);
                }
                static GXMULTIGRID3DPtr create_subset_from_double_extents(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateSubsetFromRealExtents_MULTIGRID3DUTIL(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMULTIGRID3D>(ret);
                }

            };
            class GXMVG
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMVG(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMVGPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMVG>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void axis_x(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    AxisX_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void axis_y(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    AxisY_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                static GXMVGPtr create(GXMAPPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MVG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMVG>(ret);
                }
                ~GXMVG()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                GXMVIEWPtr get_mview()
                {
                    int32_t ret = GetMVIEW_MVG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMVIEW>(ret);
                }
                void grid(double param1, double param2, double param3, double param4, double param5, double param6, int32_t param7)
                {
                    Grid_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                void label_x(double param1, double param2, double param3, double param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    LabelX_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                void label_y(double param1, double param2, double param3, double param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    LabelY_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                void poly_line_va(int32_t param1, int32_t param2, GXVVPtr param3, GXVAPtr param4, GXVVPtr param5)
                {
                    PolyLineVA_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                void poly_line_vv(int32_t param1, int32_t param2, GXVVPtr param3, GXVVPtr param4)
                {
                    PolyLineVV_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void rescale_x_range(int32_t param1, double param2, double param3, double param4)
                {
                    RescaleXRange_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void rescale_y_range(int32_t param1, double param2, double param3, double param4)
                {
                    RescaleYRange_MVG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4);
                    gx_->throw_on_error();
                }

            };
            class GXMVIEW
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMVIEW(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMVIEWPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMVIEW>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void box_3d(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    Box3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void crc_view(int32_t& param1, const gx_string_type& param2)
                {
                    CRCView_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void crc_view_group(const gx_string_type& param1, int32_t& param2, const gx_string_type& param3)
                {
                    CRCViewGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                void view_group_json(const gx_string_type& param1, const gx_string_type& param2)
                {
                    ViewGroupJSON_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void cylinder_3d(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, int32_t param9)
                {
                    Cylinder3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                void draw_object_3d(int32_t param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10, GXVVPtr param11, GXVVPtr param12, GXVVPtr param13)
                {
                    DrawObject3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)));
                    gx_->throw_on_error();
                }
                void draw_surface_3d_ex(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, int32_t param9, GXVVPtr param10, GXVVPtr param11, GXVVPtr param12, GXIPJPtr param13)
                {
                    DrawSurface3DEx_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&gx_->handle(param11)), reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)));
                    gx_->throw_on_error();
                }
                void draw_surface_3d_from_file(const gx_string_type& param1, const gx_string_type& param2)
                {
                    DrawSurface3DFromFile_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void font_weight_lst(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FontWeightLST_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_agg_file_names(const gx_string_type& param1, GXVVPtr param2)
                {
                    GetAGGFileNames_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                GXMETAPtr get_meta(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    int32_t ret = IGetMeta_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return gx_->createPtr<GXMETA>(ret);
                }
                void measure_text(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    MeasureText_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                void point_3d(double param1, double param2, double param3)
                {
                    Point3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                void poly_line_3d(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    PolyLine3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void relocate_group(const gx_string_type& param1, double param2, double param3, double param4, double param5, int32_t param6)
                {
                    RelocateGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                void set_meta(const gx_string_type& param1, GXMETAPtr param2, const gx_string_type& param3)
                {
                    SetMeta_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }
                void sphere_3d(double param1, double param2, double param3, double param4)
                {
                    Sphere3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void update_met_afrom_group(const gx_string_type& param1, GXMETAPtr param2)
                {
                    UpdateMETAfromGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void delete_plane(int32_t param1, int32_t param2)
                {
                    DeletePlane_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void get_plane_clip_ply(int32_t param1, GXPLYPtr param2)
                {
                    GetPlaneClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void get_plane_equation(int32_t param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10)
                {
                    GetPlaneEquation_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                }
                void get_view_plane_equation(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9)
                {
                    GetViewPlaneEquation_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }
                int32_t create_plane(const gx_string_type& param1)
                {
                    int32_t ret = iCreatePlane_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t find_plane(const gx_string_type& param1)
                {
                    int32_t ret = iFindPlane_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_surface_plane(const gx_string_type& param1)
                {
                    int32_t ret = iIsSurfacePlane_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_plane_visible(const gx_string_type& param1)
                {
                    int32_t ret = iIsPlaneVisible_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void get_def_plane(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetDefPlane_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                int32_t is_view_3d()
                {
                    int32_t ret = iIsView3D_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_section()
                {
                    int32_t ret = iIsSection_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void list_plane_groups(int32_t param1, GXLSTPtr param2)
                {
                    ListPlaneGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void list_planes(GXLSTPtr param1)
                {
                    ListPlanes_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_all_groups_to_plane(int32_t param1)
                {
                    SetAllGroupsToPlane_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_all_new_groups_to_plane(int32_t param1)
                {
                    SetAllNewGroupsToPlane_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_def_plane(const gx_string_type& param1)
                {
                    SetDefPlane_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_group_to_plane(int32_t param1, const gx_string_type& param2)
                {
                    SetGroupToPlane_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_3dn(GX3DNPtr param1)
                {
                    SetH3DN_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_3d_point_of_view(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    Get3DPointOfView_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void set_3d_point_of_view(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    Set3DPointOfView_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void set_plane_clip_ply(int32_t param1, GXPLYPtr param2)
                {
                    SetPlaneClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void set_plane_equation(int32_t param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10)
                {
                    SetPlaneEquation_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                }
                void set_plane_surface(int32_t param1, const gx_string_type& param2)
                {
                    SetPlaneSurface_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void get_plane_surface(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    GetPlaneSurface_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void set_plane_surf_info(int32_t param1, int32_t param2, double param3, double param4, double param5, double param6)
                {
                    SetPlaneSurfInfo_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void get_plane_surf_info(int32_t param1, int32_t& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetPlaneSurfInfo_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2), &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void define_plane_3d(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9)
                {
                    DefinePlane3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }
                void define_viewer_axis_3d(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    DefineViewerAxis3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void define_viewer_plane_3d(double param1, double param2, double param3)
                {
                    DefineViewerPlane3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                GXLSTPtr get_3d_snapshots()
                {
                    int32_t ret = Get3DSnapshots_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLST>(ret);
                }
                void restore_3d_snapshot(const gx_string_type& param1)
                {
                    Restore3DSnapshot_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void capture_3d_snapshot(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, gx_string_type& param4)
                {
                    int32_t paramSize5 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param4.resize(STR_DEFAULT_SHORT);
                    Capture3DSnapshot_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }
                void clip_poly_ex(GXVVPtr param1, GXVVPtr param2, int32_t param3, int32_t param4)
                {
                    _ClipPolyEx_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void clip_rect_ex(double param1, double param2, double param3, double param4, int32_t param5, int32_t param6)
                {
                    _ClipRectEx_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                void clip_clear()
                {
                    ClipClear_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void clip_groups(int32_t param1)
                {
                    ClipGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void clip_marked_groups(int32_t param1)
                {
                    ClipMarkedGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void clip_poly(GXVVPtr param1, GXVVPtr param2, int32_t param3)
                {
                    ClipPoly_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void clip_rect(double param1, double param2, double param3, double param4, int32_t param5)
                {
                    ClipRect_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                void delete_ext_clip_ply(int32_t param1)
                {
                    DeleteExtClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void ext_clip_ply_list(GXLSTPtr param1)
                {
                    ExtClipPLYList_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_clip_ply(GXPLYPtr param1)
                {
                    GetClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_ext_clip_ply(int32_t param1, GXPLYPtr param2)
                {
                    GetExtClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void get_group_ext_clip_ply(const gx_string_type& param1, int32_t& param2)
                {
                    GetGroupExtClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }
                void get_ply(GXPLYPtr param1)
                {
                    GetPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void group_clip_mode(int32_t param1)
                {
                    GroupClipMode_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void get_name_ext_clip_ply(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetNameExtClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t num_ext_clip_ply()
                {
                    int32_t ret = iNumExtClipPLY_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t set_ext_clip_ply(int32_t param1, const gx_string_type& param2, GXPLYPtr param3)
                {
                    int32_t ret = iSetExtClipPLY_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_clip_ply(GXPLYPtr param1)
                {
                    SetClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_group_ext_clip_ply(const gx_string_type& param1, int32_t param2)
                {
                    SetGroupExtClipPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void color2_rgb(int32_t param1, int32_t& param2, int32_t& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Color2RGB_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }
                static void color_descr(int32_t param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    ColorDescr_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static int32_t color(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iColor_MVIEW(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t color_cmy(int32_t param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iColorCMY_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t color_hsv(int32_t param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iColorHSV_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t color_rgb(int32_t param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iColorRGB_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                void clip_mode(int32_t param1)
                {
                    ClipMode_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void fill_color(int32_t param1)
                {
                    FillColor_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void line_color(int32_t param1)
                {
                    LineColor_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void line_smooth(int32_t param1)
                {
                    LineSmooth_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void line_style(int32_t param1, double param2)
                {
                    LineStyle_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                void line_thick(double param1)
                {
                    LineThick_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void pat_angle(double param1)
                {
                    PatAngle_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void pat_density(double param1)
                {
                    PatDensity_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void pat_number(int32_t param1)
                {
                    PatNumber_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void pat_size(double param1)
                {
                    PatSize_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void pat_style(int32_t param1)
                {
                    PatStyle_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void pat_thick(double param1)
                {
                    PatThick_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void symb_angle(double param1)
                {
                    SymbAngle_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void symb_color(int32_t param1)
                {
                    SymbColor_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void symb_fill_color(int32_t param1)
                {
                    SymbFillColor_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void symb_font(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    SymbFont_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void symb_number(int32_t param1)
                {
                    SymbNumber_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void symb_size(double param1)
                {
                    SymbSize_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void text_angle(double param1)
                {
                    TextAngle_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void text_color(int32_t param1)
                {
                    TextColor_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void text_font(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    TextFont_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void text_ref(int32_t param1)
                {
                    TextRef_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void text_size(double param1)
                {
                    TextSize_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void transparency(double param1)
                {
                    Transparency_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void z_value(double param1)
                {
                    ZValue_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void arc(double param1, double param2, double param3, double param4, double param5, double param6, double param7)
                {
                    Arc_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }
                void chord(double param1, double param2, double param3, double param4, double param5, double param6, double param7)
                {
                    Chord_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }
                void classified_symbols(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8)
                {
                    ClassifiedSymbols_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, param6.c_str(), param7.c_str(), param8.c_str());
                    gx_->throw_on_error();
                }
                void complex_polygon(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    ComplexPolygon_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void ellipse(double param1, double param2, double param3, double param4, double param5)
                {
                    Ellipse_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                void line(double param1, double param2, double param3, double param4)
                {
                    Line_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void line_vv(GXVVPtr param1)
                {
                    LineVV_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void polygon_dm(GXVVPtr param1, GXVVPtr param2)
                {
                    PolygonDm_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void polygon_ply(GXPLYPtr param1)
                {
                    PolygonPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void polygon_mply(GXMPLYPtr param1)
                {
                    PolygonMPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void poly_line(int32_t param1, GXVVPtr param2, GXVVPtr param3)
                {
                    PolyLine_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void poly_line_dm(GXVVPtr param1, GXVVPtr param2)
                {
                    PolyLineDm_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void poly_wrap(GXVVPtr param1, GXVVPtr param2)
                {
                    PolyWrap_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void rectangle(double param1, double param2, double param3, double param4)
                {
                    Rectangle_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void segment(double param1, double param2, double param3, double param4, double param5, double param6, double param7)
                {
                    Segment_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }
                void size_symbols(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    SizeSymbols_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void symbol(double param1, double param2)
                {
                    Symbol_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void symbols(GXVVPtr param1, GXVVPtr param2)
                {
                    Symbols_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void symbols_itr(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    SymbolsITR_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void text(const gx_string_type& param1, double param2, double param3)
                {
                    Text_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3);
                    gx_->throw_on_error();
                }
                void aggregate(GXAGGPtr param1, const gx_string_type& param2)
                {
                    Aggregate_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                GXAGGPtr get_aggregate(int32_t param1)
                {
                    int32_t ret = GetAggregate_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXAGG>(ret);
                }
                void change_line_message(const gx_string_type& param1)
                {
                    ChangeLineMessage_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void col_symbol(const gx_string_type& param1, GXCSYMBPtr param2)
                {
                    ColSymbol_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                GXCSYMBPtr get_col_symbol(int32_t param1)
                {
                    int32_t ret = GetColSymbol_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXCSYMB>(ret);
                }
                void datalinkd(GXDATALINKDPtr param1, const gx_string_type& param2)
                {
                    DATALINKD_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                GXDATALINKDPtr get_datalinkd(int32_t param1)
                {
                    int32_t ret = GetDATALINKD_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXDATALINKD>(ret);
                }
                void easy_maker(const gx_string_type& param1, const gx_string_type& param2)
                {
                    EasyMaker_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void get_maker_name(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    GetMakerName_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void emf_object(double param1, double param2, double param3, double param4, const gx_string_type& param5)
                {
                    EMFObject_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, param5.c_str());
                    gx_->throw_on_error();
                }
                void external_string_object(double param1, double param2, double param3, double param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7)
                {
                    ExternalStringObject_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, param5.c_str(), param6.c_str(), param7.c_str());
                    gx_->throw_on_error();
                }
                void link(GXDBPtr param1, const gx_string_type& param2)
                {
                    Link_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void maker(int32_t param1, int32_t param2, const gx_string_type& param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    Maker_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str(), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }
                void meta(GXMETAPtr param1, const gx_string_type& param2)
                {
                    Meta_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void voxd(GXVOXDPtr param1, const gx_string_type& param2)
                {
                    VOXD_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                GXVOXDPtr get_voxd(int32_t param1)
                {
                    int32_t ret = GetVOXD_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOXD>(ret);
                }
                void draw_vector_voxel_vectors(GXVOXPtr param1, const gx_string_type& param2, GXITRPtr param3, double param4, double param5, double param6, double param7, int32_t param8)
                {
                    DrawVectorVoxelVectors_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                GXVECTOR3DPtr get_vector_3d(int32_t param1)
                {
                    int32_t ret = GetVECTOR3D_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVECTOR3D>(ret);
                }
                void draw_vectors_3d(const gx_string_type& param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXITRPtr param8, double param9, double param10, double param11)
                {
                    DrawVectors3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), &param9, &param10, &param11);
                    gx_->throw_on_error();
                }
                void set_group_itr(int32_t param1, GXITRPtr param2)
                {
                    SetGroupITR_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                GXITRPtr get_group_itr(int32_t param1)
                {
                    int32_t ret = GetGroupITR_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXITR>(ret);
                }
                int32_t group_itr_exists(int32_t param1)
                {
                    int32_t ret = iGroupITRExists_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void delete_group_itr(int32_t param1)
                {
                    DeleteGroupITR_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_group_tpat(int32_t param1, GXTPATPtr param2)
                {
                    SetGroupTPAT_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                GXTPATPtr get_group_tpat(int32_t param1)
                {
                    int32_t ret = GetGroupTPAT_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTPAT>(ret);
                }
                int32_t group_tpat_exists(int32_t param1)
                {
                    int32_t ret = iGroupTPATExists_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void delete_group_tpat(int32_t param1)
                {
                    DeleteGroupTPAT_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                int32_t group_storage_exists(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = iGroupStorageExists_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                GXBFPtr read_group_storage(int32_t param1, const gx_string_type& param2)
                {
                    int32_t ret = ReadGroupStorage_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXBF>(ret);
                }
                void delete_group_storage(int32_t param1, const gx_string_type& param2)
                {
                    DeleteGroupStorage_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void write_group_storage(int32_t param1, const gx_string_type& param2, GXBFPtr param3)
                {
                    WriteGroupStorage_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void copy_marked_groups(GXMVIEWPtr param1)
                {
                    CopyMarkedGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void copy_raw_marked_groups(GXMVIEWPtr param1)
                {
                    CopyRawMarkedGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                int32_t crc_group(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = CRCGroup_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void delete_group(const gx_string_type& param1)
                {
                    DeleteGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void del_marked_groups()
                {
                    DelMarkedGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void get_group_extent(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5, int32_t param6)
                {
                    GetGroupExtent_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                void get_group_transparency(const gx_string_type& param1, double& param2)
                {
                    GetGroupTransparency_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2);
                    gx_->throw_on_error();
                }
                void group_to_ply(const gx_string_type& param1, GXPLYPtr param2)
                {
                    GroupToPLY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void hide_marked_groups(int32_t param1)
                {
                    HideMarkedGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void hide_shadow_2d_interpretations(int32_t param1)
                {
                    HideShadow2DInterpretations_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                int32_t exist_group(const gx_string_type& param1)
                {
                    int32_t ret = iExistGroup_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void gen_new_group_name(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_GROUP * STRING_CHAR_SIZE;
                    param2.resize(STR_GROUP);
                    IGenNewGroupName_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t is_group(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = iIsGroup_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_group_empty(const gx_string_type& param1)
                {
                    int32_t ret = iIsGroupEmpty_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_movable()
                {
                    int32_t ret = iIsMovable_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_visible()
                {
                    int32_t ret = iIsVisible_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t list_groups(GXLSTPtr param1, int32_t param2)
                {
                    int32_t ret = iListGroups_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t render_order()
                {
                    int32_t ret = iRenderOrder_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_group_exportable(const gx_string_type& param1)
                {
                    int32_t ret = IsGroupExportable_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void mark_all_groups(int32_t param1)
                {
                    MarkAllGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void mark_empty_groups(int32_t param1)
                {
                    MarkEmptyGroups_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void mark_group(const gx_string_type& param1, int32_t param2)
                {
                    MarkGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void move_group_backward(const gx_string_type& param1)
                {
                    MoveGroupBackward_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void move_group_forward(const gx_string_type& param1)
                {
                    MoveGroupForward_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void move_group_to_back(const gx_string_type& param1)
                {
                    MoveGroupToBack_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void move_group_to_front(const gx_string_type& param1)
                {
                    MoveGroupToFront_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void rename_group(const gx_string_type& param1, const gx_string_type& param2)
                {
                    RenameGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_group_moveable(const gx_string_type& param1, int32_t param2)
                {
                    SetGroupMoveable_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_group_transparency(const gx_string_type& param1, double param2)
                {
                    SetGroupTransparency_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2);
                    gx_->throw_on_error();
                }
                void set_mark_moveable(int32_t param1)
                {
                    SetMarkMoveable_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_movability(int32_t param1)
                {
                    SetMovability_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_render_order(int32_t param1)
                {
                    SetRenderOrder_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_visibility(int32_t param1)
                {
                    SetVisibility_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void start_group(const gx_string_type& param1, int32_t param2)
                {
                    StartGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void get_group_guid(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_SHORT);
                    GetGroupGUID_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                GXLSTPtr get_folder_items_3d(const gx_string_type& param1)
                {
                    int32_t ret = GetFolderItems3D_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLST>(ret);
                }
                GXLSTPtr get_folder_items_2d(const gx_string_type& param1)
                {
                    int32_t ret = GetFolderItems2D_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLST>(ret);
                }
                void add_folder_3d(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param3.resize(STR_DEFAULT_SHORT);
                    AddFolder3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                void add_folder_2d(const gx_string_type& param1, const gx_string_type& param2)
                {
                    AddFolder2D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void move_group_to_folder_3d(const gx_string_type& param1, int32_t param2)
                {
                    MoveGroupToFolder3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void move_group_to_folder_2d(const gx_string_type& param1, int32_t param2)
                {
                    MoveGroupToFolder2D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void delete_folder_3d(const gx_string_type& param1)
                {
                    DeleteFolder3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void delete_folder_2d(const gx_string_type& param1)
                {
                    DeleteFolder2D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                int32_t find_group_by_guid(const gx_string_type& param1)
                {
                    int32_t ret = iFindGroupByGUID_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void set_working_ipj(GXIPJPtr param1)
                {
                    _SetWorkingIPJ_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void clear_esrild_ts()
                {
                    ClearESRILDTs_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                int32_t is_projection_empty()
                {
                    int32_t ret = iIsProjectionEmpty_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_user_ipj(GXIPJPtr param1)
                {
                    GetUserIPJ_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void mode_pj(int32_t param1)
                {
                    ModePJ_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                double north()
                {
                    double ret = rNorth_MVIEW(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_user_ipj(GXIPJPtr param1)
                {
                    SetUserIPJ_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                int32_t get_3d_group_flags(int32_t param1)
                {
                    int32_t ret = iGet3DGroupFlags_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_3d_group_flags(int32_t param1, int32_t param2)
                {
                    Set3DGroupFlags_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void get_group_freeze_scale(int32_t param1, double& param2)
                {
                    _GetGroupFreezeScale_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                void set_freeze_scale(double param1)
                {
                    _SetFreezeScale_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_group_freeze_scale(int32_t param1, double param2)
                {
                    _SetGroupFreezeScale_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                int32_t find_group(const gx_string_type& param1)
                {
                    int32_t ret = iFindGroup_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void group_name(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IGroupName_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void render(HDC param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6, double param7, double param8, double param9)
                {
                    Render_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1, reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }
                void render_ex(HDC param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double& param6, double& param7, double& param8, double& param9, int32_t param10, int32_t param11, int32_t param12)
                {
                    RenderEx_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1, reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                }
                void set_u_fac(double param1)
                {
                    _SetUFac_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void axis_x(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    AxisX_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void axis_y(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    AxisY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void grid(double param1, double param2, double param3, double param4, int32_t param5)
                {
                    Grid_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                void label_fid(GXVVPtr param1, double param2, double param3, double param4, double param5, double param6)
                {
                    LabelFid_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void label_x(double param1, double param2, double param3, double param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    LabelX_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                void label_y(double param1, double param2, double param3, double param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    LabelY_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void optimum_tick(double param1, double param2, double& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OptimumTick_MVIEW(
                        gx_->pGeo, &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                static GXMVIEWPtr create(GXMAPPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMVIEW>(ret);
                }
                static GXMVIEWPtr create_crooked_section(GXMAPPtr param1, GXIPJPtr param2, const gx_string_type& param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11, GXVVPtr param12, GXVVPtr param13, GXVVPtr param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateCrookedSection_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, reinterpret_cast<const long*>(&gx_->handle(param12)), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMVIEW>(ret);
                }
                static GXMVIEWPtr create_crooked_section_data_profile(GXMAPPtr param1, GXIPJPtr param2, const gx_string_type& param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11, int32_t param12, GXVVPtr param13, GXVVPtr param14, GXVVPtr param15)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateCrookedSectionDataProfile_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMVIEW>(ret);
                }
                ~GXMVIEW()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void extent(int32_t param1, int32_t param2, double& param3, double& param4, double& param5, double& param6)
                {
                    Extent_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                GXMAPPtr get_map()
                {
                    int32_t ret = GetMAP_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXMAP>(ret);
                }
                GXREGPtr get_reg()
                {
                    int32_t ret = GetREG_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXREG>(ret);
                }
                void get_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VIEW * STRING_CHAR_SIZE;
                    param1.resize(STR_VIEW);
                    IGetName_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_guid(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    GetGUID_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void plot_to_view(double& param1, double& param2)
                {
                    _PlotToView_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void set_thin_res(double param1)
                {
                    _SetThinRes_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void view_to_plot(double& param1, double& param2)
                {
                    _ViewToPlot_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void best_fit_window(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, int32_t param9)
                {
                    BestFitWindow_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                void fit_map_window_3d(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8)
                {
                    FitMapWindow3D_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }
                void fit_window(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8)
                {
                    FitWindow_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }
                void get_class_name(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IGetClassName_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void map_origin(double& param1, double& param2)
                {
                    MapOrigin_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void re_scale(double param1)
                {
                    ReScale_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                double get_map_scale()
                {
                    double ret = rGetMapScale_MVIEW(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double scale_mm()
                {
                    double ret = rScaleMM_MVIEW(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double scale_pj_mm()
                {
                    double ret = rScalePjMM_MVIEW(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double scale_ymm()
                {
                    double ret = rScaleYMM_MVIEW(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void scale_all_group(double param1, double param2)
                {
                    ScaleAllGroup_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void scale_window(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8)
                {
                    ScaleWindow_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }
                void set_class_name(const gx_string_type& param1, const gx_string_type& param2)
                {
                    SetClassName_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_window(double param1, double param2, double param3, double param4, int32_t param5)
                {
                    SetWindow_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                void tran_scale(double param1, double param2, double param3, double param4)
                {
                    TranScale_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void user_to_view(double& param1, double& param2)
                {
                    UserToView_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void view_to_user(double& param1, double& param2)
                {
                    ViewToUser_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void get_surface_filename(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    GetSurfaceFilename_MVIEW(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t is_surface_item_visible(const gx_string_type& param1, const gx_string_type& param2)
                {
                    int32_t ret = IsSurfaceItemVisible_MVIEW(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXMVU
            {
            private:
                GXMVU();
                ~GXMVU();
            public:


                static void arrow(GXMVIEWPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Arrow_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void arrow_vector_vv(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, double param6, int32_t param7, int32_t param8, int32_t param9, int32_t param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ArrowVectorVV_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), &param6, reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11);
                    gx_->throw_on_error();
                }
                static void bar_chart(GXMVIEWPtr param1, const gx_string_type& param2, GXDBPtr param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, double param8, const gx_string_type& param9, double param10, const gx_string_type& param11, double param12, double param13, int32_t param14, int32_t param15, int32_t param16, int32_t param17, int32_t param18, int32_t param19, int32_t param20, double param21, double param22, double param23, double param24, double param25, double param26, double param27, double param28)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BarChart_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str(), param7.c_str(), &param8, param9.c_str(), &param10, param11.c_str(), &param12, &param13, reinterpret_cast<const long*>(&param14), reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&param20), &param21, &param22, &param23, &param24, &param25, &param26, &param27, &param28);
                    gx_->throw_on_error();
                }
                static void cdi_pixel_plot(GXMVIEWPtr param1, const gx_string_type& param2, GXVAPtr param3, GXVAPtr param4, GXVVPtr param5, GXITRPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CDIPixelPlot_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static void cdi_pixel_plot_3d(GXMVIEWPtr param1, const gx_string_type& param2, GXVAPtr param3, GXVAPtr param4, GXVVPtr param5, GXVVPtr param6, GXITRPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CDIPixelPlot3D_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                static void color_bar(GXMVIEWPtr param1, GXITRPtr param2, int32_t param3, double param4, double param5, double param6, double param7, double param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBar_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }
                static void color_bar2(GXMVIEWPtr param1, GXITRPtr param2, GXITRPtr param3, int32_t param4, double param5, double param6, double param7, double param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBar2_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }
                static void color_bar2_style(GXMVIEWPtr param1, GXITRPtr param2, GXITRPtr param3, int32_t param4, double param5, double param6, double param7, double param8, double param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBar2Style_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }
                static void color_bar_hor(GXMVIEWPtr param1, GXITRPtr param2, int32_t param3, double param4, double param5, double param6, double param7, double param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBarHor_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                static void color_bar_hor2(GXMVIEWPtr param1, GXITRPtr param2, GXITRPtr param3, int32_t param4, double param5, double param6, double param7, double param8, double param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBarHor2_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }
                static void color_bar_hor2_style(GXMVIEWPtr param1, GXITRPtr param2, GXITRPtr param3, int32_t param4, double param5, double param6, double param7, double param8, double param9, int32_t param10, int32_t param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBarHor2Style_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                }
                static void color_bar_hor_style(GXMVIEWPtr param1, GXITRPtr param2, int32_t param3, double param4, double param5, double param6, double param7, double param8, int32_t param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBarHorStyle_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }
                static void color_bar_style(GXMVIEWPtr param1, GXITRPtr param2, int32_t param3, double param4, double param5, double param6, double param7, double param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBarStyle_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                static void color_bar_reg(GXMVIEWPtr param1, GXITRPtr param2, GXITRPtr param3, GXREGPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBarREG_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void color_bar_reg_ex(GXMVIEWPtr param1, GXSTPtr param2, GXITRPtr param3, GXITRPtr param4, GXREGPtr param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ColorBarREGEx_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static void contour(GXMVIEWPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Contour_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void contour_ply(GXMVIEWPtr param1, GXPLYPtr param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ContourPLY_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                static void c_symb_legend(GXMVIEWPtr param1, double param2, double param3, double param4, double param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CSymbLegend_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, param6.c_str(), param7.c_str(), param8.c_str());
                    gx_->throw_on_error();
                }
                static void decay_curve(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVAPtr param4, GXVAPtr param5, int32_t param6, double param7, double param8, int32_t param9, int32_t param10, double param11, double param12, double param13, double param14, double param15, double param16, double param17, double param18, double param19, int32_t param20, const gx_string_type& param21)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DecayCurve_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18, &param19, reinterpret_cast<const long*>(&param20), param21.c_str());
                    gx_->throw_on_error();
                }
                static void direction_plot(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DirectionPlot_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void em_forward(GXMVIEWPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, int32_t param8, double param9, double param10, double param11, double param12, GXVVPtr param13, GXVVPtr param14, GXVVPtr param15, GXVVPtr param16, int32_t param17, int32_t param18)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EMForward_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), &param9, &param10, &param11, &param12, reinterpret_cast<const long*>(&gx_->handle(param13)), reinterpret_cast<const long*>(&gx_->handle(param14)), reinterpret_cast<const long*>(&gx_->handle(param15)), reinterpret_cast<const long*>(&gx_->handle(param16)), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18));
                    gx_->throw_on_error();
                }
                static void export_datamine_string(GXMVIEWPtr param1, GXLSTPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportDatamineString_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }
                static void export_dxf_3d(GXMVIEWPtr param1, GXLSTPtr param2, GXWAPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportDXF3D_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void export_surpac_str(GXMVIEWPtr param1, GXLSTPtr param2, GXWAPtr param3, GXWAPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportSurpacSTR_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void export_map_groups_to_gdb(GXMVIEWPtr param1, GXLSTPtr param2, GXDBPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportMapGroupsToGDB_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void flight_plot(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, const gx_string_type& param4, int32_t param5, double param6, int32_t param7, double param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FlightPlot_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, reinterpret_cast<const long*>(&param7), &param8, &param9);
                    gx_->throw_on_error();
                }
                static void gen_areas(GXMVIEWPtr param1, const gx_string_type& param2, GXVVPtr param3, GXVVPtr param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenAreas_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5);
                    gx_->throw_on_error();
                }
                static void get_range_gocad_surface(const gx_string_type& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetRangeGOCADSurface_MVU(
                        gx_->pGeo, param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }
                static void histogram(GXMVIEWPtr param1, GXSTPtr param2, GXSTPtr param3, const gx_string_type& param4, const gx_string_type& param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12, double param13, double param14, int32_t param15, int32_t param16, int32_t param17, GXSTPtr param18)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Histogram_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), param5.c_str(), &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&gx_->handle(param18)));
                    gx_->throw_on_error();
                }
                static void histogram2(GXMVIEWPtr param1, GXSTPtr param2, GXSTPtr param3, const gx_string_type& param4, const gx_string_type& param5, double param6, const gx_string_type& param7, double param8, const gx_string_type& param9, double param10, double param11, double param12, double param13, double param14, double param15, double param16, double param17, double param18, int32_t param19, int32_t param20, int32_t param21, GXSTPtr param22, double param23)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Histogram2_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), param5.c_str(), &param6, param7.c_str(), &param8, param9.c_str(), &param10, &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18, reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&param20), reinterpret_cast<const long*>(&param21), reinterpret_cast<const long*>(&gx_->handle(param22)), &param23);
                    gx_->throw_on_error();
                }
                static void histogram3(GXMVIEWPtr param1, GXSTPtr param2, GXSTPtr param3, const gx_string_type& param4, const gx_string_type& param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12, double param13, double param14, int32_t param15, int32_t param16, int32_t param17, int32_t param18, int32_t param19, GXSTPtr param20)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Histogram3_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), param5.c_str(), &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&gx_->handle(param20)));
                    gx_->throw_on_error();
                }
                static void histogram4(GXMVIEWPtr param1, GXSTPtr param2, GXSTPtr param3, const gx_string_type& param4, const gx_string_type& param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12, double param13, double param14, int32_t param15, int32_t param16, int32_t param17, int32_t param18, int32_t param19, int32_t param20, GXSTPtr param21)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Histogram4_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), param5.c_str(), &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&param20), reinterpret_cast<const long*>(&gx_->handle(param21)));
                    gx_->throw_on_error();
                }
                static void histogram5(GXMVIEWPtr param1, GXSTPtr param2, GXSTPtr param3, const gx_string_type& param4, const gx_string_type& param5, double param6, double param7, double param8, double param9, double param10, double param11, double param12, double param13, double param14, double param15, int32_t param16, int32_t param17, int32_t param18, int32_t param19, int32_t param20, int32_t param21, GXSTPtr param22, GXITRPtr param23)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Histogram5_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), param5.c_str(), &param6, &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15, reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&param18), reinterpret_cast<const long*>(&param19), reinterpret_cast<const long*>(&param20), reinterpret_cast<const long*>(&param21), reinterpret_cast<const long*>(&gx_->handle(param22)), reinterpret_cast<const long*>(&gx_->handle(param23)));
                    gx_->throw_on_error();
                }
                static int32_t exportable_dxf_3d_groups_lst(GXMVIEWPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iExportableDXF3DGroupsLST_MVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t mapset_test(double param1, double param2, double param3, double param4, const gx_string_type& param5, int32_t param6, int32_t param7, double& param8, double param9, double param10, double param11, double param12, double param13, double param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iMapsetTest_MVU(
                                      gx_->pGeo, &param1, &param2, &param3, &param4, param5.c_str(), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), &param8, &param9, &param10, &param11, &param12, &param13, &param14);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t mapset2_test(double param1, double param2, double param3, double param4, const gx_string_type& param5, int32_t param6, int32_t param7, double& param8, double param9, double param10, double param11, double param12, double param13, double param14, double param15)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iMapset2Test_MVU(
                                      gx_->pGeo, &param1, &param2, &param3, &param4, param5.c_str(), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), &param8, &param9, &param10, &param11, &param12, &param13, &param14, &param15);
                    gx_->throw_on_error();
                    return ret;
                }
                static void import_gocad_surface(GXMVIEWPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportGOCADSurface_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void load_plot(GXMAPPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadPlot_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void map_from_plt(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MapFromPLT_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), &param5, &param6);
                    gx_->throw_on_error();
                }
                static void map_mdf(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MapMDF_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void mapset(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3, double param4, double param5, double param6, double param7, const gx_string_type& param8, int32_t param9, int32_t param10, double param11, double param12, double param13, double param14, double param15, double param16, double param17)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Mapset_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), &param4, &param5, &param6, &param7, param8.c_str(), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, &param16, &param17);
                    gx_->throw_on_error();
                }
                static void mapset2(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3, double param4, double param5, double param6, double param7, const gx_string_type& param8, int32_t param9, int32_t param10, double param11, double param12, double param13, double param14, double param15, double param16, double param17, double param18)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Mapset2_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), &param4, &param5, &param6, &param7, param8.c_str(), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18);
                    gx_->throw_on_error();
                }
                static void mdf(GXMAPPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MDF_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                static void path_plot(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, const gx_string_type& param4, int32_t param5, double param6, int32_t param7, double param8, double param9, double param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PathPlot_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, reinterpret_cast<const long*>(&param7), &param8, &param9, &param10);
                    gx_->throw_on_error();
                }
                static void path_plot_ex(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, const gx_string_type& param4, int32_t param5, int32_t param6, double param7, int32_t param8, double param9, double param10, double param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PathPlotEx_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8), &param9, &param10, &param11);
                    gx_->throw_on_error();
                }
                static void path_plot_ex2(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, const gx_string_type& param4, int32_t param5, int32_t param6, double param7, int32_t param8, double param9, double param10, double param11, int32_t param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PathPlotEx2_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8), &param9, &param10, &param11, reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                }
                static void plot_voxel_slice(GXMVIEWPtr param1, GXVOXPtr param2, GXITRPtr param3, GXVVPtr param4, GXVVPtr param5, double param6, double param7, double param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PlotVoxelSlice_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }
                static void plot_voxel_surface(GXMVIEWPtr param1, GXVOXPtr param2, double param3, int32_t param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PlotVoxelSurface_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&param4), &param5);
                    gx_->throw_on_error();
                }
                static void plot_voxel_surface2(GXMVIEWPtr param1, GXVOXPtr param2, double param3, int32_t param4, double param5, double param6, const gx_string_type& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PlotVoxelSurface2_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&param4), &param5, &param6, param7.c_str());
                    gx_->throw_on_error();
                }
                static void generate_surface_from_voxel(GXMVIEWPtr param1, GXVOXPtr param2, int32_t param3, int32_t param4, double param5, double param6, int32_t param7, double param8, double param9, const gx_string_type& param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenerateSurfaceFromVoxel_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6, reinterpret_cast<const long*>(&param7), &param8, &param9, param10.c_str());
                    gx_->throw_on_error();
                }
                static void post(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, int32_t param9, double param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Post_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10);
                    gx_->throw_on_error();
                }
                static void post_ex(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, int32_t param6, double param7, double param8, int32_t param9, int32_t param10, int32_t param11, double param12, double param13, int32_t param14, double param15, int32_t param16, double param17, int32_t param18, double param19, int32_t param20)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PostEx_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), &param12, &param13, reinterpret_cast<const long*>(&param14), &param15, reinterpret_cast<const long*>(&param16), &param17, reinterpret_cast<const long*>(&param18), &param19, reinterpret_cast<const long*>(&param20));
                    gx_->throw_on_error();
                }
                static void probability(GXMVIEWPtr param1, GXSTPtr param2, GXSTPtr param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6, double param7, double param8, double param9, double param10, double param11, double param12, double param13, double param14, int32_t param15, int32_t param16, int32_t param17, GXITRPtr param18)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Probability_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6), &param7, &param8, &param9, &param10, &param11, &param12, &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&param17), reinterpret_cast<const long*>(&gx_->handle(param18)));
                    gx_->throw_on_error();
                }
                static void profile_plot(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, int32_t param6, double param7, double param8, double param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProfilePlot_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, reinterpret_cast<const long*>(&param6), &param7, &param8, &param9, reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }
                static void profile_plot_ex(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, int32_t param6, double param7, double param8, double param9, int32_t param10, int32_t param11, double param12, int32_t param13, const gx_string_type& param14, const gx_string_type& param15)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProfilePlotEx_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, reinterpret_cast<const long*>(&param6), &param7, &param8, &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), &param12, reinterpret_cast<const long*>(&param13), param14.c_str(), param15.c_str());
                    gx_->throw_on_error();
                }
                static void prop_symb_legend(GXMVIEWPtr param1, double param2, double param3, double param4, double param5, double param6, int32_t param7, double param8, double param9, const gx_string_type& param10, const gx_string_type& param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PropSymbLegend_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&param7), &param8, &param9, param10.c_str(), param11.c_str());
                    gx_->throw_on_error();
                }
                static void re_gen_areas(GXMVIEWPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReGenAreas_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void symb_off(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SymbOff_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6);
                    gx_->throw_on_error();
                }
                static void text_box(GXMVIEWPtr param1, double param2, double param3, double param4, double param5, const gx_string_type& param6, double param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TextBox_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, param6.c_str(), &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void tick(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7, double param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Tick_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }
                static void tick_ex(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7, double param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TickEx_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }
                static void trnd_path(GXMVIEWPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TrndPath_MVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5);
                    gx_->throw_on_error();
                }

            };
            class GXMXD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXMXD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXMXDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXMXD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static void create_metadata(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateMetadata_MXD(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void convert_to_map(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertToMap_MXD(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void sync(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Sync_MXD(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXPAT
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXPAT(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXPATPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXPAT>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXPATPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_PAT(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPAT>(ret);
                }
                ~GXPAT()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_PAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_lst(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GetLST_PAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

            };
            class GXPDF3D
            {
            private:
                GXPDF3D();
                ~GXPDF3D();
            public:


                static void render(GXMVIEWPtr param1, const gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Render_PDF3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void render_to_page(GXMVIEWPtr param1, const gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RenderToPage_PDF3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void export_2d(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Export2D_PDF3D(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

            };
            class GXPG
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXPG(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXPGPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXPG>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void copy(GXPGPtr param1)
                {
                    Copy_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void copy_subset(GXPGPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    CopySubset_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static GXPGPtr create(int32_t param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_PG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }
                static GXPGPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_PG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }
                ~GXPG()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void dummy()
                {
                    Dummy_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                int32_t e_type()
                {
                    int32_t ret = iEType_PG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t n_cols()
                {
                    int32_t ret = iNCols_PG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t n_rows()
                {
                    int32_t ret = iNRows_PG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t n_slices()
                {
                    int32_t ret = iNSlices_PG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void range(double& param1, double& param2)
                {
                    Range_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                double get(int32_t param1, int32_t param2)
                {
                    double ret = rGet_PG(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void set(int32_t param1, int32_t param2, double param3)
                {
                    Set_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }
                void read_col(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    ReadCol_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void read_row(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    ReadRow_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void re_allocate(int32_t param1, int32_t param2)
                {
                    ReAllocate_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void serial(GXBFPtr param1)
                {
                    Serial_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void statistics(GXSTPtr param1)
                {
                    Statistics_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void write_col(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    WriteCol_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void write_row(int32_t param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    WriteRow_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void copy_subset_3d(GXPGPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, int32_t param9, int32_t param10)
                {
                    CopySubset3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }
                static GXPGPtr create_3d(int32_t param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create3D_PG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }
                void read_col_3d(int32_t param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5)
                {
                    ReadCol3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                void read_row_3d(int32_t param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5)
                {
                    ReadRow3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                void read_trace_3d(int32_t param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5)
                {
                    ReadTrace3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                void re_allocate_3d(int32_t param1, int32_t param2, int32_t param3)
                {
                    ReAllocate3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void write_col_3d(int32_t param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5)
                {
                    WriteCol3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                void write_row_3d(int32_t param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5)
                {
                    WriteRow3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                void write_trace_3d(int32_t param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5)
                {
                    WriteTrace3D_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                void read_bf(GXBFPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    ReadBF_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                void read_ra(GXRAPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, const gx_string_type& param6)
                {
                    ReadRA_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str());
                    gx_->throw_on_error();
                }
                void write_bf(GXBFPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    WriteBF_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                void write_bf_ex(GXBFPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7)
                {
                    WriteBFEx_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7);
                    gx_->throw_on_error();
                }
                void write_wa(GXWAPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, const gx_string_type& param6)
                {
                    WriteWA_PG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), param6.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXPGEXP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXPGEXP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXPGEXPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXPGEXP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_pager(GXPGPtr param1, const gx_string_type& param2)
                {
                    AddPager_PGEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static GXPGEXPPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_PGEXP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPGEXP>(ret);
                }
                ~GXPGEXP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_PGEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void do_formula(const gx_string_type& param1, int32_t param2)
                {
                    DoFormula_PGEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

            };
            class GXPGU
            {
            private:
                GXPGU();
                ~GXPGU();
            public:


                static void bool_mask(GXPGPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Bool_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void expand(GXPGPtr param1, GXPGPtr param2, double param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Expand_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void fill(GXPGPtr param1, int32_t param2, double param3, int32_t param4, int32_t param5, int32_t param6, double param7, double param8, int32_t param9, int32_t param10, const gx_string_type& param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Fill_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), param11.c_str());
                    gx_->throw_on_error();
                }
                static void fill_value(GXPGPtr param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FillValue_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }
                static void filt_sym(GXPGPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, int32_t param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FiltSym_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static void filt_sym5(GXPGPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FiltSym5_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void grid_peak(const gx_string_type& param1, int32_t param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GridPeak_PGU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void dw_gridding_dat(GXPGPtr param1, GXDATPtr param2, GXREGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IDWGriddingDAT_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void dw_gridding_dat_3d(GXPGPtr param1, GXDATPtr param2, GXREGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IDWGriddingDAT3D_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void dw_gridding_db(GXPGPtr param1, GXDBPtr param2, int32_t param3, int32_t param4, int32_t param5, GXREGPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IDWGriddingDB_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static void dw_gridding_db_3d(GXPGPtr param1, GXDBPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, GXREGPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IDWGriddingDB3D_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                static void dw_gridding_vv(GXPGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXREGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IDWGriddingVV_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void numeric_to_thematic(GXPGPtr param1, GXVVPtr param2, GXPGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NumericToThematic_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void peakedness(const gx_string_type& param1, int32_t param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Peakedness_PGU(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void peakedness_grid(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PeakednessGrid_PGU(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }
                static void ref_file(GXPGPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RefFile_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void save_file(GXPGPtr param1, double param2, double param3, double param4, double param5, double param6, GXTRPtr param7, GXIPJPtr param8, const gx_string_type& param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SaveFile_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), param9.c_str());
                    gx_->throw_on_error();
                }
                static void thematic_to_numeric(GXPGPtr param1, GXVVPtr param2, GXPGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ThematicToNumeric_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void trend(GXPGPtr param1, GXPGPtr param2, GXTRPtr param3, int32_t param4, int32_t param5, double param6, double param7, double param8, double param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Trend_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, &param7, &param8, &param9);
                    gx_->throw_on_error();
                }
                static void add_scalar(GXPGPtr param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AddScalar_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }
                static void multiply_scalar(GXPGPtr param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MultiplyScalar_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }
                static void correlation_matrix(GXPGPtr param1, GXPGPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CorrelationMatrix_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void correlation_matrix2(GXPGPtr param1, int32_t param2, GXPGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CorrelationMatrix2_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void invert_matrix(GXPGPtr param1, GXPGPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    InvertMatrix_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void jacobi(GXPGPtr param1, GXVVPtr param2, GXPGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Jacobi_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void lu_back_sub(GXPGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LUBackSub_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void lu_decomp(GXPGPtr param1, GXPGPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LUDecomp_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void matrix_mult(GXPGPtr param1, int32_t param2, GXPGPtr param3, int32_t param4, GXPGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MatrixMult_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void matrix_vector_mult(GXPGPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MatrixVectorMult_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void sv_decompose(GXPGPtr param1, GXPGPtr param2, GXVVPtr param3, GXPGPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SVDecompose_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void sv_recompose(GXPGPtr param1, GXVVPtr param2, GXPGPtr param3, double param4, GXPGPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SVRecompose_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void pc_communality(GXPGPtr param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCCommunality_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void pc_loadings(GXPGPtr param1, GXPGPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCLoadings_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void pc_loadings2(GXPGPtr param1, GXPGPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCLoadings2_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void pc_scores(GXPGPtr param1, GXPGPtr param2, GXPGPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCScores_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void pc_standardize(GXPGPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCStandardize_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void pc_standardize2(GXPGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCStandardize2_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void pc_transform(GXPGPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCTransform_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void pc_varimax(GXPGPtr param1, GXPGPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PCVarimax_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static double maximum_terrain_steepness(GXPGPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rMaximumTerrainSteepness_PGU(
                                     gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static void direct_gridding_db(GXPGPtr param1, double param2, double param3, double param4, double param5, double param6, GXDBPtr param7, int32_t param8, int32_t param9, int32_t param10, int32_t param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DirectGriddingDB_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                }
                static void direct_gridding_db2(GXPGPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, GXDBPtr param9, int32_t param10, int32_t param11, int32_t param12, int32_t param13)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DirectGriddingDB2_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13));
                    gx_->throw_on_error();
                }
                static void direct_gridding_db_3d(GXPGPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, GXDBPtr param9, int32_t param10, int32_t param11, int32_t param12, int32_t param13, int32_t param14)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DirectGriddingDB3D_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13), reinterpret_cast<const long*>(&param14));
                    gx_->throw_on_error();
                }
                static void direct_gridding_vv(GXPGPtr param1, double param2, double param3, double param4, double param5, double param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DirectGriddingVV_PGU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }

            };
            class GXPJ
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXPJ(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXPJPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXPJ>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void clip_ply(double param1, double param2, double param3, double param4, double param5, GXPLYPtr param6)
                {
                    ClipPLY_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                void convert_vv(GXVVPtr param1, GXVVPtr param2)
                {
                    ConvertVV_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void convert_vv3(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    ConvertVV3_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void convert_xy(double& param1, double& param2)
                {
                    ConvertXY_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void convert_xy_from_xyz(double& param1, double& param2, double param3)
                {
                    ConvertXYFromXYZ_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                void convert_xyz(double& param1, double& param2, double& param3)
                {
                    ConvertXYZ_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                static GXPJPtr create(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_PJ(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPJ>(ret);
                }
                static GXPJPtr create_ipj(GXIPJPtr param1, GXIPJPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateIPJ_PJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPJ>(ret);
                }
                static GXPJPtr create_rectified(double param1, double param2, double param3, double param4, double param5, double param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateRectified_PJ(
                                      gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPJ>(ret);
                }
                ~GXPJ()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t elevation()
                {
                    int32_t ret = iElevation_PJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_input_ll()
                {
                    int32_t ret = iIsInputLL_PJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_output_ll()
                {
                    int32_t ret = iIsOutputLL_PJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void project_bounding_rectangle(double& param1, double& param2, double& param3, double& param4)
                {
                    ProjectBoundingRectangle_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void project_bounding_rectangle2(double& param1, double& param2, double& param3, double& param4, double param5)
                {
                    ProjectBoundingRectangle2_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                void project_bounding_rectangle_res(double& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    ProjectBoundingRectangleRes_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                void project_bounding_rectangle_res2(double& param1, double& param2, double& param3, double& param4, double& param5, double param6)
                {
                    ProjectBoundingRectangleRes2_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void project_limited_bounding_rectangle(double param1, double param2, double param3, double param4, double& param5, double& param6, double& param7, double& param8)
                {
                    ProjectLimitedBoundingRectangle_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }
                void setup_ldt()
                {
                    SetupLDT_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void project_bounding_volume(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    ProjectBoundingVolume_PJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }

            };
            class GXPLY
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXPLY(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXPLYPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXPLY>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_polygon(GXVVPtr param1, GXVVPtr param2)
                {
                    AddPolygon_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void add_polygon_ex(GXVVPtr param1, GXVVPtr param2, int32_t param3)
                {
                    AddPolygonEx_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void change_ipj(GXIPJPtr param1)
                {
                    ChangeIPJ_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void clear()
                {
                    Clear_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void copy(GXPLYPtr param1)
                {
                    Copy_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                int32_t is_valid()
                {
                    int32_t ret = IsValid_PLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void combine(GXPLYPtr param1, int32_t param2)
                {
                    Combine_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static GXPLYPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_PLY(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPLY>(ret);
                }
                static GXPLYPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_PLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPLY>(ret);
                }
                ~GXPLY()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void extent(double& param1, double& param2, double& param3, double& param4)
                {
                    Extent_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_polygon(GXVVPtr param1, GXVVPtr param2, int32_t param3)
                {
                    GetPolygon_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void get_polygon_ex(GXVVPtr param1, GXVVPtr param2, int32_t param3, int32_t& param4)
                {
                    GetPolygonEx_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }
                int32_t clip_area(double param1, double param2, double param3, double param4)
                {
                    int32_t ret = iClipArea_PLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t clip_line_int(double param1, double param2, double param3, double param4, GXVVPtr param5, double param6, int32_t& param7)
                {
                    int32_t ret = iClipLineInt_PLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&gx_->handle(param5)), &param6, reinterpret_cast<long*>(&param7));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t clip_ply(GXPLYPtr param1, GXPLYPtr param2)
                {
                    int32_t ret = iClipPLY_PLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t clip_point(double param1, double param2)
                {
                    int32_t ret = iClipPoint_PLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                    return ret;
                }
                void get_description(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IGetDescription_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                int32_t num_poly()
                {
                    int32_t ret = iNumPoly_PLY(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void load_table(const gx_string_type& param1)
                {
                    LoadTable_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                double area()
                {
                    double ret = rArea_PLY(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void rectangle(double param1, double param2, double param3, double param4)
                {
                    Rectangle_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void rotate(double param1, double param2, double param3)
                {
                    Rotate_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                void save_table(const gx_string_type& param1)
                {
                    SaveTable_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void serial(GXBFPtr param1)
                {
                    Serial_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_description(const gx_string_type& param1)
                {
                    SetDescription_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void thin(double param1)
                {
                    Thin_PLY(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }

            };
            class GXPRAGA3
            {
            private:
                GXPRAGA3();
                ~GXPRAGA3();
            public:


                static int32_t launch()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iLaunch_PRAGA3(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXPROJ
            {
            private:
                GXPROJ();
                ~GXPROJ();
            public:


                static void drop_map_clip_data(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_DropMapClipData_PROJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static int32_t add_document(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iAddDocument_PROJ(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t add_document_without_opening(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iAddDocumentWithoutOpening_PROJ(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t add_document_include_meta(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iAddDocumentIncludeMeta_PROJ(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t add_grid_document(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iAddGridDocument_PROJ(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_command_environment()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iGetCommandEnvironment_PROJ(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t list_documents(GXVVPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iListDocuments_PROJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t list_loaded_documents(GXVVPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iListLoadedDocuments_PROJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void current_document(gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize3 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    param2.resize(STR_DEFAULT_SHORT);
                    App_ICurrentDocument_PROJ(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void current_document_of_type(gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    App_ICurrentDocumentOfType_PROJ(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), param2.c_str());
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static int32_t list_tools(GXLSTPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iListTools_PROJ(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t remove_document(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iRemoveDocument_PROJ(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t remove_tool(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iRemoveTool_PROJ(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t save_close_documents(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iSaveCloseDocuments_PROJ(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_name(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    App_IGetName_PROJ(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void get_server_and_project_guid(gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize3 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    param2.resize(STR_DEFAULT_SHORT);
                    App_GetServerAndProjectGUID_PROJ(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void set_central_project_information(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetCentralProjectInformation_PROJ(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str());
                    gx_->throw_on_error();
                }
                static void get_central_project_information(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4, gx_string_type& param5, gx_string_type& param6, gx_string_type& param7, gx_string_type& param8, gx_string_type& param9, gx_string_type& param10, gx_string_type& param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize3 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize7 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize9 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize11 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize13 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize15 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize17 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize19 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize21 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    param2.resize(STR_DEFAULT);
                    param3.resize(STR_DEFAULT_LONG);
                    param4.resize(STR_DEFAULT);
                    param5.resize(STR_DEFAULT);
                    param6.resize(STR_DEFAULT);
                    param7.resize(STR_DEFAULT);
                    param8.resize(STR_DEFAULT);
                    param9.resize(STR_DEFAULT);
                    param10.resize(STR_DEFAULT);
                    param11.resize(STR_DEFAULT);
                    App_GetCentralProjectInformation_PROJ(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize7 ), (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize9 ), (gx_string_char_type*)param6.data(), reinterpret_cast<const long*>(&paramSize11 ), (gx_string_char_type*)param7.data(), reinterpret_cast<const long*>(&paramSize13 ), (gx_string_char_type*)param8.data(), reinterpret_cast<const long*>(&paramSize15 ), (gx_string_char_type*)param9.data(), reinterpret_cast<const long*>(&paramSize17 ), (gx_string_char_type*)param10.data(), reinterpret_cast<const long*>(&paramSize19 ), (gx_string_char_type*)param11.data(), reinterpret_cast<const long*>(&paramSize21 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param5.resize(gx_string_len(param5.c_str()));
                    param6.resize(gx_string_len(param6.c_str()));
                    param7.resize(gx_string_len(param7.c_str()));
                    param8.resize(gx_string_len(param8.c_str()));
                    param9.resize(gx_string_len(param9.c_str()));
                    param10.resize(gx_string_len(param10.c_str()));
                    param11.resize(gx_string_len(param11.c_str()));
                }
                static void save_document_view(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SaveDocumentView_PROJ(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void get_default_project_path(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    App_IGetDefaultProjectPath_PROJ(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void set_default_project_path(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetDefaultProjectPath_PROJ(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static int32_t has_pending_central_publish_event()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_HasPendingCentralPublishEvent_PROJ(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static void register_background_script(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, GXVVPtr param6, const gx_string_type& param7, const gx_string_type& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_RegisterBackgroundScript_PROJ(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)), param7.c_str(), param8.c_str());
                    gx_->throw_on_error();
                }
                static void get_registered_background_script(int32_t param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4, gx_string_type& param5, gx_string_type& param6, GXVVPtr param7, gx_string_type& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = PROJ_OMS_DATETIME_SIZE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = PROJ_OMS_NAME_SIZE * STRING_CHAR_SIZE;
                    int32_t paramSize8 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize11 = PROJ_OMS_PROCESSID_SIZE * STRING_CHAR_SIZE;
                    param2.resize(PROJ_OMS_DATETIME_SIZE);
                    param3.resize(PROJ_OMS_NAME_SIZE);
                    param4.resize(PROJ_OMS_NAME_SIZE);
                    param5.resize(STR_FILE);
                    param6.resize(STR_FILE);
                    param8.resize(PROJ_OMS_PROCESSID_SIZE);
                    App_GetRegisteredBackgroundScript_PROJ(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param3.data(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ), (gx_string_char_type*)param5.data(), (gx_string_char_type*)param6.data(), reinterpret_cast<const long*>(&paramSize8 ), reinterpret_cast<const long*>(&gx_->handle(param7)), (gx_string_char_type*)param8.data(), reinterpret_cast<const long*>(&paramSize11 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param5.resize(gx_string_len(param5.c_str()));
                    param6.resize(gx_string_len(param6.c_str()));
                    param8.resize(gx_string_len(param8.c_str()));
                }
                static int32_t get_num_registered_background_scripts()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iGetNumRegisteredBackgroundScripts_PROJ(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXRA
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXRA(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXRAPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXRA>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXRAPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_RA(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXRA>(ret);
                }
                static GXRAPtr create_sbf(GXSBFPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateSBF_RA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXRA>(ret);
                }
                ~GXRA()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_RA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t gets(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    int32_t ret = IiGets_RA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }
                int32_t len()
                {
                    int32_t ret = iLen_RA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t line()
                {
                    int32_t ret = iLine_RA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t seek(int32_t param1)
                {
                    int32_t ret = iSeek_RA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXREG
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXREG(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXREGPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXREG>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void clear()
                {
                    Clear_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void copy(GXREGPtr param1)
                {
                    Copy_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXREGPtr create(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_REG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXREG>(ret);
                }
                static GXREGPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_REG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXREG>(ret);
                }
                ~GXREG()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    Get_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void get_int(const gx_string_type& param1, int32_t& param2)
                {
                    GetInt_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }
                void get_one(int32_t param1, gx_string_type& param2, gx_string_type& param3)
                {
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    param3.resize(STR_VERY_LONG);
                    GetOne_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }
                void get_double(const gx_string_type& param1, double& param2)
                {
                    GetReal_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2);
                    gx_->throw_on_error();
                }
                int32_t entries()
                {
                    int32_t ret = iEntries_REG(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void load_ini(const gx_string_type& param1)
                {
                    LoadINI_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void match_string(const gx_string_type& param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    MatchString_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void merge(GXREGPtr param1, int32_t param2)
                {
                    Merge_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void save_ini(const gx_string_type& param1)
                {
                    SaveINI_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void serial(GXBFPtr param1)
                {
                    Serial_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set(const gx_string_type& param1, const gx_string_type& param2)
                {
                    Set_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_int(const gx_string_type& param1, int32_t param2)
                {
                    SetInt_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_double(const gx_string_type& param1, double param2)
                {
                    SetReal_REG(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2);
                    gx_->throw_on_error();
                }

            };
            class GXRGRD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXRGRD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXRGRDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXRGRD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void clear()
                {
                    _Clear_RGRD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static GXRGRDPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_RGRD(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXRGRD>(ret);
                }
                static GXIMGPtr create_img(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXIPJPtr param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateIMG_RGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIMG>(ret);
                }
                ~GXRGRD()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_RGRD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t default(const gx_string_type& param1, GXDATPtr param2)
                {
                    int32_t ret = iDefault_RGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t load_parms(const gx_string_type& param1)
                {
                    int32_t ret = iLoadParms_RGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t run(GXDATPtr param1, GXDATPtr param2)
                {
                    int32_t ret = iRun_RGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t run2(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRun2_RGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t run3(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRun3_RGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), param7.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t save_parms(const gx_string_type& param1)
                {
                    int32_t ret = iSaveParms_RGRD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void run_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXIPJPtr param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RunVV_RGRD(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                }
                static void run_list(const gx_string_type& param1, const gx_string_type& param2, GXIPJPtr param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RunList_RGRD(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXSBF
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXSBF(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXSBFPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXSBF>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                GXSBFPtr create(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = Create_SBF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSBF>(ret);
                }
                void create_obj_list(GXLSTPtr param1, int32_t param2)
                {
                    CreateObjList_SBF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void del_dir(const gx_string_type& param1)
                {
                    DelDir_SBF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void del_file(const gx_string_type& param1)
                {
                    DelFile_SBF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                ~GXSBF()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_SBF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                static GXSBFPtr h_get_db(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = hGetDB_SBF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSBF>(ret);
                }
                static GXSBFPtr h_get_map(GXMAPPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = hGetMAP_SBF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSBF>(ret);
                }
                static GXSBFPtr h_get_sys()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = hGetSYS_SBF(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSBF>(ret);
                }
                int32_t exist_dir(const gx_string_type& param1)
                {
                    int32_t ret = iExistDir_SBF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t exist_file(const gx_string_type& param1)
                {
                    int32_t ret = iExistFile_SBF(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void save_log(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4)
                {
                    SaveLog_SBF(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }

            };
            class GXSEGYREADER
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXSEGYREADER(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXSEGYREADERPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXSEGYREADER>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXSEGYREADERPtr open_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = OpenFile_SEGYREADER(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSEGYREADER>(ret);
                }
                void set_is_3d(int32_t param1)
                {
                    SetIs3D_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                int32_t get_is_3d()
                {
                    int32_t ret = GetIs3D_SEGYREADER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_endianess()
                {
                    int32_t ret = GetEndianess_SEGYREADER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_endianess(int32_t param1)
                {
                    SetEndianess_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void get_xy_units(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    GetXYUnits_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void set_z_type(const gx_string_type& param1)
                {
                    SetZType_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void get_z_type(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    GetZType_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_possible_z_units(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    GetPossibleZUnits_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_z_units(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    GetZUnits_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void set_z_units(const gx_string_type& param1)
                {
                    SetZUnits_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void get_z_offset_units(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    GetZOffsetUnits_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void set_z_offset_units(const gx_string_type& param1)
                {
                    SetZOffsetUnits_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void get_last_sample_at(double& param1)
                {
                    GetLastSampleAt_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                static GXLTBPtr list_binary_header_fields()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = ListBinaryHeaderFields_SEGYREADER(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLTB>(ret);
                }
                static GXLTBPtr list_trace_header_fields()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = ListTraceHeaderFields_SEGYREADER(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLTB>(ret);
                }
                void get_text_header(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    GetTextHeader_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                GXLTBPtr get_binary_header()
                {
                    int32_t ret = GetBinaryHeader_SEGYREADER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLTB>(ret);
                }
                GXVVPtr get_trace_data_at(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    int32_t ret = GetTraceDataAt_SEGYREADER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                GXVVPtr get_trace_header_at(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    int32_t ret = GetTraceHeaderAt_SEGYREADER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                int32_t estimate_number_of_traces(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = EstimateNumberOfTraces_SEGYREADER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_num_trace_data_types()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GetNumTraceDataTypes_SEGYREADER(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_trace_data_type_name(int32_t param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    GetTraceDataTypeName_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void get_trace_data_type_display_name(int32_t param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    GetTraceDataTypeDisplayName_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                void get_trace_data_type(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    GetTraceDataType_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void set_trace_data_type(const gx_string_type& param1)
                {
                    SetTraceDataType_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void get_trace_length_configuration(gx_string_type& param1, int32_t& param2)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    GetTraceLengthConfiguration_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void set_trace_length_configuration(const gx_string_type& param1, int32_t param2)
                {
                    SetTraceLengthConfiguration_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                int32_t get_trace_length()
                {
                    int32_t ret = GetTraceLength_SEGYREADER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_sample_interval_configuration(gx_string_type& param1, int32_t& param2)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    GetSampleIntervalConfiguration_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void set_sample_interval_configuration(const gx_string_type& param1, int32_t param2, double param3)
                {
                    SetSampleIntervalConfiguration_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }
                void get_sample_interval(double& param1)
                {
                    GetSampleInterval_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void get_z_offset_configuration(gx_string_type& param1, int32_t& param2)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    GetZOffsetConfiguration_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void set_z_offset_configuration(const gx_string_type& param1, int32_t param2, double param3)
                {
                    SetZOffsetConfiguration_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }
                void get_z_offset(double& param1)
                {
                    GetZOffset_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void scan_file()
                {
                    ScanFile_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                GXLTBPtr get_field_configuration()
                {
                    int32_t ret = GetFieldConfiguration_SEGYREADER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXLTB>(ret);
                }
                void set_field_configuration(GXLTBPtr param1)
                {
                    SetFieldConfiguration_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_trace_count(int32_t& param1)
                {
                    GetTraceCount_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1));
                    gx_->throw_on_error();
                }
                void check_sane_inline_crossline(int32_t& param1, int32_t& param2, int32_t& param3)
                {
                    CheckSaneInlineCrossline_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }
                void get_voxel_dimensions(int32_t& param1, int32_t& param2, int32_t& param3)
                {
                    GetVoxelDimensions_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }
                void get_voxel_cell_size(double& param1, double& param2, double& param3)
                {
                    GetVoxelCellSize_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                void set_auto_voxel_cell_size_xy()
                {
                    SetAutoVoxelCellSizeXY_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void set_user_voxel_cell_size_xy(double param1, double param2)
                {
                    SetUserVoxelCellSizeXY_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                GXIPJPtr get_georeferencing()
                {
                    int32_t ret = GetGeoreferencing_SEGYREADER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXIPJ>(ret);
                }
                void set_georeferencing(GXIPJPtr param1)
                {
                    SetGeoreferencing_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_tie_point(int32_t param1, double& param2, double& param3, int32_t& param4, int32_t& param5)
                {
                    GetTiePoint_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                }
                void set_tie_point(int32_t param1, double param2, double param3, int32_t param4, int32_t param5)
                {
                    SetTiePoint_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                void recalculate_georeferencing()
                {
                    RecalculateGeoreferencing_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void reset_tie_points()
                {
                    ResetTiePoints_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void get_inline_and_crossline_azimuths(double& param1, double& param2)
                {
                    GetInlineAndCrosslineAzimuths_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void export_voxel_and_database(const gx_string_type& param1, const gx_string_type& param2)
                {
                    ExportVoxelAndDatabase_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_gdb_output_filename(const gx_string_type& param1)
                {
                    SetGdbOutputFilename_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_voxel_output_filename(const gx_string_type& param1)
                {
                    SetVoxelOutputFilename_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_section_output_filename(const gx_string_type& param1)
                {
                    SetSectionOutputFilename_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_slice_output_prefix(const gx_string_type& param1)
                {
                    SetSliceOutputPrefix_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_inline_slice_indices(GXVVPtr param1)
                {
                    SetInlineSliceIndices_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_crossline_slice_indices(GXVVPtr param1)
                {
                    SetCrosslineSliceIndices_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_z_slice_indices(GXVVPtr param1)
                {
                    SetZSliceIndices_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_slice_filenames(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    GetSliceFilenames_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void set_z_decimation(int32_t param1)
                {
                    SetZDecimation_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_user_z_range(double param1, double param2)
                {
                    SetUserZRange_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void clear_user_z_range()
                {
                    ClearUserZRange_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void set_user_inline_range(int32_t param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    SetUserInlineRange_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void set_user_crossline_range(int32_t param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    SetUserCrosslineRange_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void clear_user_range()
                {
                    ClearUserRange_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void set_trace_dummy_value(double param1)
                {
                    SetTraceDummyValue_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void clear_trace_dummy_value()
                {
                    ClearTraceDummyValue_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void get_clip_xy_extents(int32_t& param1, double& param2, double& param3, double& param4, double& param5)
                {
                    GetClipXYExtents_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, &param3, &param4, &param5);
                    gx_->throw_on_error();
                }
                void add_trace_filter(int32_t param1, int32_t param2, int32_t param3, const gx_string_type& param4)
                {
                    AddTraceFilter_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str());
                    gx_->throw_on_error();
                }
                void clear_trace_filters()
                {
                    ClearTraceFilters_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                int32_t count_traces_that_pass_filters()
                {
                    int32_t ret = CountTracesThatPassFilters_SEGYREADER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void override_navigation_2d(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    OverrideNavigation2D_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void export_files()
                {
                    ExportFiles_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void get_trace_header_as_json(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    GetTraceHeaderAsJson_SEGYREADER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                GXVVPtr get_trace_data(int32_t param1)
                {
                    int32_t ret = GetTraceData_SEGYREADER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }

            };
            class GXSEMPLOT
            {
            private:
                GXSEMPLOT();
                ~GXSEMPLOT();
            public:


                static void apply_filter_to_mask(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ApplyFilterToMask_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void convert_dummies(GXDBPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ConvertDummies_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void create_groups(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateGroups_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void default_groups(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DefaultGroups_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void edit_map_plot_parameters(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXMAPPtr param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EditMapPlotParameters_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str());
                    gx_->throw_on_error();
                }
                static void edit_plot_components(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EditPlotComponents_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void edit_plot_parameters(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EditPlotParameters_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void export_overlay(const gx_string_type& param1, const gx_string_type& param2, GXMVIEWPtr param3, const gx_string_type& param4, int32_t param5, const gx_string_type& param6, const gx_string_type& param7, const gx_string_type& param8, const gx_string_type& param9, const gx_string_type& param10, const gx_string_type& param11, int32_t param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportOverlay_SEMPLOT(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str(), reinterpret_cast<const long*>(&param5), param6.c_str(), param7.c_str(), param8.c_str(), param9.c_str(), param10.c_str(), param11.c_str(), reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                }
                static void export_view(GXDBPtr param1, GXLSTPtr param2, GXDBPtr param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportView_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str(), param7.c_str());
                    gx_->throw_on_error();
                }
                static void export_view2(GXDBPtr param1, GXLSTPtr param2, GXDBPtr param3, int32_t param4, const gx_string_type& param5, const gx_string_type& param6, const gx_string_type& param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportView2_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), param5.c_str(), param6.c_str(), param7.c_str(), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void filter_lst(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FilterLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void filter_mineral_pos_data(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FilterMineralPosData_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void get_associated_lst(GXDBPtr param1, int32_t param2, GXLSTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetAssociatedLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void get_current_mineral_lst(GXDBPtr param1, const gx_string_type& param2, GXLSTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetCurrentMineralLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void get_current_position_lst(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetCurrentPositionLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void get_full_mineral_lst(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetFullMineralLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void get_full_position_lst(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetFullPositionLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void get_grouping_lst(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetGroupingLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static int32_t create_ascii_template(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCreateASCIITemplate_SEMPLOT(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t create_database_template(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCreateDatabaseTemplate_SEMPLOT(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t edit_filter(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iEditFilter_SEMPLOT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_mineral_channel_name(GXDBPtr param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    IGetMineralChannelName_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void import_ascii_wizard(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param3.resize(STR_DB_SYMBOL);
                    IImportAsciiWizard_SEMPLOT(
                        gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                static void import_database_odbc(gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    param2.resize(STR_FILE);
                    IImportDatabaseODBC_SEMPLOT(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void import_bin(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportBIN_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), &param6);
                    gx_->throw_on_error();
                }
                static void import_database_ado(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ImportDatabaseADO_SEMPLOT(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void init_group_symbols_used(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    InitGroupSymbolsUsed_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static int32_t template_type(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iTemplateType_SEMPLOT(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t view_type(GXMAPPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iViewType_SEMPLOT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void mineral_id(GXDBPtr param1, double param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MineralID_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void new_filter(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NewFilter_SEMPLOT(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void new_template(const gx_string_type& param1, int32_t param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NewTemplate_SEMPLOT(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                static void overlay_lst(GXLSTPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OverlayLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void plot(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Plot_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void plot_symbol_legend(GXDBPtr param1, GXMVIEWPtr param2, double param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PlotSymbolLegend_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                static void prop_symb(GXDBPtr param1, GXMAPPtr param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6, int32_t param7, int32_t param8, double param9, double param10, int32_t param11, int32_t param12, int32_t param13, int32_t param14, int32_t param15)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PropSymb_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str(), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), &param9, &param10, reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&param12), reinterpret_cast<const long*>(&param13), reinterpret_cast<const long*>(&param14), reinterpret_cast<const long*>(&param15));
                    gx_->throw_on_error();
                }
                static void replot(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, GXMAPPtr param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Replot_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), param5.c_str());
                    gx_->throw_on_error();
                }
                static void re_plot_symbol_legend(GXDBPtr param1, GXMVIEWPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RePlotSymbolLegend_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void reset_groups(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ResetGroups_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void reset_used_channel(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ResetUsedChannel_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void select_poly(GXDBPtr param1, GXMVIEWPtr param2, const gx_string_type& param3, const gx_string_type& param4, GXPLYPtr param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SelectPoly_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void set_channel_order(GXDBPtr param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetChannelOrder_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void set_channel_units(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetChannelUnits_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void set_itr(GXDBPtr param1, int32_t param2, GXITRPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetITR_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void set_mask(GXDBPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetMask_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void sort_data(GXDBPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SortData_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void template_lst(GXLSTPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TemplateLST_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void tile_windows()
                {
                    GXContextPtr gx_ = GXContext::current();
                    TileWindows_SEMPLOT(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static void total_oxides(GXDBPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TotalOxides_SEMPLOT(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXSHD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXSHD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXSHDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXSHD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void refresh(const gx_string_type& param1, double param2, double param3, double param4, double& param5, double& param6, int32_t param7)
                {
                    App_Refresh_SHD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                int32_t track_interactive(int32_t param1, double& param2, double& param3)
                {
                    int32_t ret = App_iTrackInteractive_SHD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }
                void end_shading(int32_t param1)
                {
                    App_EndShading_SHD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

            };
            class GXSHP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXSHP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXSHPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXSHP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void append_item()
                {
                    AppendItem_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                static GXSHPPtr create(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_SHP(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSHP>(ret);
                }
                ~GXSHP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t add_int_field(const gx_string_type& param1)
                {
                    int32_t ret = iAddIntField_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t add_double_field(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = iAddRealField_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t add_string_field(const gx_string_type& param1, int32_t param2)
                {
                    int32_t ret = iAddStringField_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t find_field(const gx_string_type& param1)
                {
                    int32_t ret = iFindField_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t max_id_num()
                {
                    int32_t ret = iMaxIDNum_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t num_fields()
                {
                    int32_t ret = iNumFields_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t num_records()
                {
                    int32_t ret = iNumRecords_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t type()
                {
                    int32_t ret = iType_SHP(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                static GXSHPPtr open(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Open_SHP(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSHP>(ret);
                }
                void set_arc(GXVVPtr param1, GXVVPtr param2)
                {
                    SetArc_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void set_arc_z(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    SetArcZ_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void set_int(int32_t param1, int32_t param2)
                {
                    SetInt_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_point(double param1, double param2)
                {
                    SetPoint_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void set_point_z(double param1, double param2, double param3)
                {
                    SetPointZ_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                void set_polygon(GXVVPtr param1, GXVVPtr param2, int32_t param3)
                {
                    SetPolygon_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void set_polygon_z(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4)
                {
                    SetPolygonZ_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void set_double(int32_t param1, double param2)
                {
                    SetReal_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                void set_string(int32_t param1, const gx_string_type& param2)
                {
                    SetString_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void write_item()
                {
                    WriteItem_SHP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

            };
            class GXSQLSRV
            {
            private:
                GXSQLSRV();
                ~GXSQLSRV();
            public:


                static int32_t attach_mdf(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iAttachMDF_SQLSRV(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), param6.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t detach_db(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDetachDB_SQLSRV(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_database_languages_lst(GXLSTPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetDatabaseLanguagesLST_SQLSRV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_databases_lst(GXLSTPtr param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetDatabasesLST_SQLSRV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_login_gui(const gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, int32_t param4, int32_t& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    param3.resize(STR_DEFAULT);
                    IGetLoginGUI_SQLSRV(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ), reinterpret_cast<const long*>(&param4), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }
                static int32_t get_servers_lst(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetServersLST_SQLSRV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXST
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXST(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXSTPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXST>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXSTPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_ST(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXST>(ret);
                }
                static GXSTPtr create_exact()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateExact_ST(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXST>(ret);
                }
                void data(double param1)
                {
                    Data_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void data_vv(GXVVPtr param1)
                {
                    DataVV_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                ~GXST()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_histogram_bins(GXVVPtr param1)
                {
                    GetHistogramBins_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_histogram_info(int32_t& param1, double& param2, double& param3)
                {
                    GetHistogramInfo_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                }
                void histogram(int32_t param1)
                {
                    Histogram_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void histogram2(int32_t param1, double param2, double param3)
                {
                    Histogram2_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                }
                double equivalent_percentile(double param1)
                {
                    double ret = rEquivalentPercentile_ST(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                double equivalent_value(double param1)
                {
                    double ret = rEquivalentValue_ST(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                void reset()
                {
                    Reset_ST(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                double get_info(int32_t param1)
                {
                    double ret = rGetInfo_ST(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                static double get_norm_prob(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rGetNormProb_ST(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double get_norm_prob_x(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rGetNormProbX_ST(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                double normal_test()
                {
                    double ret = rNormalTest_ST(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXST2
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXST2(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXST2Ptr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXST2>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXST2Ptr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_ST2(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXST2>(ret);
                }
                void data_vv(GXVVPtr param1, GXVVPtr param2)
                {
                    DataVV_ST2(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                ~GXST2()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_ST2(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t items()
                {
                    int32_t ret = iItems_ST2(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void reset()
                {
                    Reset_ST2(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                double get(int32_t param1)
                {
                    double ret = rGet_ST2(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXSTK
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXSTK(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXSTKPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXSTK>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void get_trans_parms(int32_t& param1, double& param2, GXVVPtr param3, GXVVPtr param4, int32_t& param5, double& param6, GXVVPtr param7, GXVVPtr param8)
                {
                    GetTransParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<long*>(&param5), &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)));
                    gx_->throw_on_error();
                }
                int32_t get_axis_format(int32_t param1)
                {
                    int32_t ret = iGetAxisFormat_STK(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_axis_parms(int32_t& param1, double& param2, double& param3, double& param4, gx_string_type& param5, double& param6, double& param7, double& param8, int32_t& param9, int32_t param10)
                {
                    int32_t paramSize6 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param5.resize(STR_DEFAULT_SHORT);
                    IGetAxisParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, &param3, &param4, (gx_string_char_type*)param5.data(), reinterpret_cast<const long*>(&paramSize6 ), &param6, &param7, &param8, reinterpret_cast<long*>(&param9), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                    param5.resize(gx_string_len(param5.c_str()));
                }
                void get_fid_parms(double& param1, double& param2, double& param3, gx_string_type& param4, double& param5, gx_string_type& param6)
                {
                    int32_t paramSize5 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize8 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param4.resize(STR_DEFAULT_SHORT);
                    param6.resize(STR_DEFAULT_SHORT);
                    IGetFidParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ), &param5, (gx_string_char_type*)param6.data(), reinterpret_cast<const long*>(&paramSize8 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    param6.resize(gx_string_len(param6.c_str()));
                }
                int32_t get_flag(int32_t param1)
                {
                    int32_t ret = iGetFlag_STK(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_gen_parms(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11)
                {
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_GROUP * STRING_CHAR_SIZE;
                    param1.resize(STR_DB_SYMBOL);
                    param2.resize(STR_DB_SYMBOL);
                    param3.resize(STR_GROUP);
                    IGetGenParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize6 ), &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11);
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }
                void get_grid_parms(int32_t& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, gx_string_type& param10, int32_t param11)
                {
                    int32_t paramSize11 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param10.resize(STR_DEFAULT_SHORT);
                    IGetGridParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, (gx_string_char_type*)param10.data(), reinterpret_cast<const long*>(&paramSize11 ), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                    param10.resize(gx_string_len(param10.c_str()));
                }
                void get_label_parms(int32_t& param1, double& param2, int32_t& param3, double& param4, int32_t& param5, double& param6, gx_string_type& param7, double& param8, gx_string_type& param9, int32_t& param10, int32_t param11)
                {
                    int32_t paramSize8 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize11 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param7.resize(STR_DEFAULT_SHORT);
                    param9.resize(STR_DEFAULT_SHORT);
                    IGetLabelParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, reinterpret_cast<long*>(&param3), &param4, reinterpret_cast<long*>(&param5), &param6, (gx_string_char_type*)param7.data(), reinterpret_cast<const long*>(&paramSize8 ), &param8, (gx_string_char_type*)param9.data(), reinterpret_cast<const long*>(&paramSize11 ), reinterpret_cast<long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                    param7.resize(gx_string_len(param7.c_str()));
                    param9.resize(gx_string_len(param9.c_str()));
                }
                void get_profile(int32_t& param1, double& param2, double& param3, gx_string_type& param4, int32_t& param5, int32_t& param6, int32_t& param7, GXVVPtr param8, gx_string_type& param9, int32_t& param10, gx_string_type& param11, double& param12, gx_string_type& param13, int32_t& param14)
                {
                    int32_t paramSize5 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize11 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize14 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize17 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param4.resize(STR_DEFAULT_SHORT);
                    param9.resize(STR_DEFAULT);
                    param11.resize(STR_DEFAULT_SHORT);
                    param13.resize(STR_DEFAULT_SHORT);
                    IGetProfile_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, &param3, (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6), reinterpret_cast<long*>(&param7), reinterpret_cast<const long*>(&gx_->handle(param8)), (gx_string_char_type*)param9.data(), reinterpret_cast<const long*>(&paramSize11 ), reinterpret_cast<long*>(&param10), (gx_string_char_type*)param11.data(), reinterpret_cast<const long*>(&paramSize14 ), &param12, (gx_string_char_type*)param13.data(), reinterpret_cast<const long*>(&paramSize17 ), reinterpret_cast<long*>(&param14));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    param9.resize(gx_string_len(param9.c_str()));
                    param11.resize(gx_string_len(param11.c_str()));
                    param13.resize(gx_string_len(param13.c_str()));
                }
                void get_profile_ex(int32_t& param1, double& param2, double& param3, gx_string_type& param4, int32_t& param5, int32_t& param6, int32_t& param7, int32_t& param8, GXVVPtr param9, gx_string_type& param10, int32_t& param11, gx_string_type& param12, double& param13, gx_string_type& param14, int32_t& param15)
                {
                    int32_t paramSize5 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize12 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize15 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize18 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param4.resize(STR_DEFAULT_SHORT);
                    param10.resize(STR_DEFAULT);
                    param12.resize(STR_DEFAULT_SHORT);
                    param14.resize(STR_DEFAULT_SHORT);
                    IGetProfileEx_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, &param3, (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize5 ), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6), reinterpret_cast<long*>(&param7), reinterpret_cast<long*>(&param8), reinterpret_cast<const long*>(&gx_->handle(param9)), (gx_string_char_type*)param10.data(), reinterpret_cast<const long*>(&paramSize12 ), reinterpret_cast<long*>(&param11), (gx_string_char_type*)param12.data(), reinterpret_cast<const long*>(&paramSize15 ), &param13, (gx_string_char_type*)param14.data(), reinterpret_cast<const long*>(&paramSize18 ), reinterpret_cast<long*>(&param15));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    param10.resize(gx_string_len(param10.c_str()));
                    param12.resize(gx_string_len(param12.c_str()));
                    param14.resize(gx_string_len(param14.c_str()));
                }
                void get_symb_parms(gx_string_type& param1, double& param2, gx_string_type& param3, gx_string_type& param4, int32_t& param5, int32_t& param6, double& param7, int32_t& param8, GXVVPtr param9, GXVVPtr param10, int32_t& param11, gx_string_type& param12, double& param13, gx_string_type& param14)
                {
                    int32_t paramSize2 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize7 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize16 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize19 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    param3.resize(STR_DEFAULT_SHORT);
                    param4.resize(STR_DEFAULT_SHORT);
                    param12.resize(STR_DEFAULT_SHORT);
                    param14.resize(STR_DEFAULT_SHORT);
                    IGetSymbParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), &param2, (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize7 ), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6), &param7, reinterpret_cast<long*>(&param8), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<long*>(&param11), (gx_string_char_type*)param12.data(), reinterpret_cast<const long*>(&paramSize16 ), &param13, (gx_string_char_type*)param14.data(), reinterpret_cast<const long*>(&paramSize19 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param12.resize(gx_string_len(param12.c_str()));
                    param14.resize(gx_string_len(param14.c_str()));
                }
                void get_title_parms(gx_string_type& param1, gx_string_type& param2, int32_t& param3, double& param4, double& param5, int32_t& param6, double& param7, double& param8, gx_string_type& param9, double& param10, gx_string_type& param11, int32_t param12)
                {
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_DEFAULT * STRING_CHAR_SIZE;
                    int32_t paramSize12 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize15 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    param2.resize(STR_DEFAULT);
                    param9.resize(STR_DEFAULT_SHORT);
                    param11.resize(STR_DEFAULT_SHORT);
                    IGetTitleParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize4 ), reinterpret_cast<long*>(&param3), &param4, &param5, reinterpret_cast<long*>(&param6), &param7, &param8, (gx_string_char_type*)param9.data(), reinterpret_cast<const long*>(&paramSize12 ), &param10, (gx_string_char_type*)param11.data(), reinterpret_cast<const long*>(&paramSize15 ), reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param9.resize(gx_string_len(param9.c_str()));
                    param11.resize(gx_string_len(param11.c_str()));
                }
                void set_flag(int32_t param1, int32_t param2)
                {
                    ISetFlag_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_array_colors(GXITRPtr param1)
                {
                    SetArrayColors_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_axis_format(int32_t param1, int32_t param2)
                {
                    SetAxisFormat_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_axis_parms(int32_t param1, double param2, double param3, double param4, const gx_string_type& param5, double param6, double param7, double param8, int32_t param9, int32_t param10)
                {
                    SetAxisParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, param5.c_str(), &param6, &param7, &param8, reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                }
                void set_fid_parms(double param1, double param2, double param3, const gx_string_type& param4, double param5, const gx_string_type& param6)
                {
                    SetFidParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, param4.c_str(), &param5, param6.c_str());
                    gx_->throw_on_error();
                }
                void set_gen_parms(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, double param11)
                {
                    SetGenParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11);
                    gx_->throw_on_error();
                }
                void set_grid_parms(int32_t param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, const gx_string_type& param10, int32_t param11)
                {
                    SetGridParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, param10.c_str(), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                }
                void set_label_parms(int32_t param1, double param2, int32_t param3, double param4, int32_t param5, double param6, const gx_string_type& param7, double param8, const gx_string_type& param9, int32_t param10, int32_t param11)
                {
                    SetLabelParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, reinterpret_cast<const long*>(&param3), &param4, reinterpret_cast<const long*>(&param5), &param6, param7.c_str(), &param8, param9.c_str(), reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                }
                void set_line_parm(int32_t param1)
                {
                    SetLineParm_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_profile(int32_t param1, double param2, double param3, const gx_string_type& param4, int32_t param5, int32_t param6, int32_t param7, GXVVPtr param8, const gx_string_type& param9, int32_t param10, const gx_string_type& param11, double param12, const gx_string_type& param13, int32_t param14)
                {
                    SetProfile_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&gx_->handle(param8)), param9.c_str(), reinterpret_cast<const long*>(&param10), param11.c_str(), &param12, param13.c_str(), reinterpret_cast<const long*>(&param14));
                    gx_->throw_on_error();
                }
                void set_profile_ex(int32_t param1, double param2, double param3, const gx_string_type& param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, GXVVPtr param9, const gx_string_type& param10, int32_t param11, const gx_string_type& param12, double param13, const gx_string_type& param14, int32_t param15)
                {
                    SetProfileEx_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&gx_->handle(param9)), param10.c_str(), reinterpret_cast<const long*>(&param11), param12.c_str(), &param13, param14.c_str(), reinterpret_cast<const long*>(&param15));
                    gx_->throw_on_error();
                }
                void set_symb_parms(const gx_string_type& param1, double param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, int32_t param6, double param7, int32_t param8, GXVVPtr param9, GXVVPtr param10, int32_t param11, const gx_string_type& param12, double param13, const gx_string_type& param14)
                {
                    SetSymbParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)), reinterpret_cast<const long*>(&param11), param12.c_str(), &param13, param14.c_str());
                    gx_->throw_on_error();
                }
                void set_title_parms(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, double param4, double param5, int32_t param6, double param7, double param8, const gx_string_type& param9, double param10, const gx_string_type& param11, int32_t param12)
                {
                    SetTitleParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), &param4, &param5, reinterpret_cast<const long*>(&param6), &param7, &param8, param9.c_str(), &param10, param11.c_str(), reinterpret_cast<const long*>(&param12));
                    gx_->throw_on_error();
                }
                void set_trans_parms(int32_t param1, double param2, int32_t param3, int32_t param4, int32_t param5, double param6, int32_t param7, int32_t param8)
                {
                    SetTransParms_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                void set_va_index_start(int32_t param1)
                {
                    SetVAIndexStart_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_error_plot_params(int32_t param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    SetErrorPlotParams_STK(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXSTORAGEPROJECT
            {
            private:
                GXSTORAGEPROJECT();
                ~GXSTORAGEPROJECT();
            public:


                static void open(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Open_STORAGEPROJECT(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void close()
                {
                    GXContextPtr gx_ = GXContext::current();
                    Close_STORAGEPROJECT(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static void remove_dataset(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveDataset_STORAGEPROJECT(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXSTR
            {
            private:
                GXSTR();
                ~GXSTR();
            public:


                static int32_t scan_i(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iScanI_STR(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static double scan_date(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rScanDate_STR(
                                     gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static double scan_form(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rScanForm_STR(
                                     gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static double scan_r(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rScanR_STR(
                                     gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static double scan_time(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rScanTime_STR(
                                     gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static void file_combine_parts(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize6 = STR_FILE * STRING_CHAR_SIZE;
                    param6.resize(STR_FILE);
                    IFileCombineParts_STR(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), (gx_string_char_type*)param6.data(), reinterpret_cast<const long*>(&paramSize6 ));
                    gx_->throw_on_error();
                    param6.resize(gx_string_len(param6.c_str()));
                }
                static void file_ext(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    IFileExt_STR(
                        gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                static void file_name_part(const gx_string_type& param1, gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IFileNamePart_STR(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void get_m_file(const gx_string_type& param1, gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetMFile_STR(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void remove_qualifiers(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IRemoveQualifiers_STR(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void format_crc(int32_t param1, gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IFormatCRC_STR(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void format_date(double param1, gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IFormatDate_STR(
                        gx_->pGeo, &param1, (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void format_i(int32_t param1, gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IFormatI_STR(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void format_r(double param1, gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IFormatR_STR(
                        gx_->pGeo, &param1, (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void format_r2(double param1, gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IFormatR2_STR(
                        gx_->pGeo, &param1, (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void format_double(double param1, gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IFormatReal_STR(
                        gx_->pGeo, &param1, (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void format_time(double param1, gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT);
                    IFormatTime_STR(
                        gx_->pGeo, &param1, (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void escape(gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    _Escape_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static int32_t char_(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iChar_STR(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t char_n(const gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = IiCharN_STR(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static void justify(const gx_string_type& param1, gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    IJustify_STR(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void replacei_match_string(gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IReplaceiMatchString_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void replace_match_string(gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IReplaceMatchString_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void set_char_n(gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    ISetCharN_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void split_string(gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    ISplitString_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                static void strcat(gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IStrcat_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static int32_t strcmp(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStrcmp_STR(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static void strcpy(gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IStrcpy_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static int32_t stri_mask(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStriMask_STR(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void strins(gx_string_type& param1, int32_t param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IStrins_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&param2), param3.c_str(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static int32_t strlen(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStrlen_STR(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t str_mask(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStrMask_STR(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t str_min(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStrMin_STR(
                                      gx_->pGeo, (gx_string_char_type*)param1.data());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t str_min2(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStrMin2_STR(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t strncmp(const gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStrncmp_STR(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t str_str(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iStrStr_STR(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static void substr(gx_string_type& param1, const gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    ISubstr_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void to_lower(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IToLower_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void to_upper(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IToUpper_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void xyz_line(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DB_SYMBOL * STRING_CHAR_SIZE;
                    param2.resize(STR_DB_SYMBOL);
                    IXYZLine_STR(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void make_alpha(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MakeAlpha_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data());
                    gx_->throw_on_error();
                }
                static void printf(gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    Printf_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), param2.c_str());
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void replace_char(gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReplaceChar_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void replace_char2(gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReplaceChar2_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void replace_multi_char(gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReplaceMultiChar_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void replace_non_ascii(gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ReplaceNonASCII_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void set_char(gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetChar_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void trim_quotes(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TrimQuotes_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data());
                    gx_->throw_on_error();
                }
                static void trim_space(gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TrimSpace_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void un_quote(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    UnQuote_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data());
                    gx_->throw_on_error();
                }
                static void gen_group_name(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_GROUP * STRING_CHAR_SIZE;
                    param4.resize(STR_GROUP);
                    IGenGroupName_STR(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }
                static int32_t count_tokens(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCountTokens_STR(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_token(gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    IGetToken_STR(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static int32_t tokenize(gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iTokenize_STR(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t tokens(gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iTokens_STR(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t tokens2(gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iTokens2_STR(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void parse_list(const gx_string_type& param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ParseList_STR(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }

            };
            class GXSTRINGS
            {
            private:
                GXSTRINGS();
                ~GXSTRINGS();
            public:


                static void launch_digitization_ui(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LaunchDigitizationUI_STRINGS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXSURFACE
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXSURFACE(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXSURFACEPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXSURFACE>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXSURFACEPtr create(const gx_string_type& param1, GXIPJPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_SURFACE(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSURFACE>(ret);
                }
                static GXSURFACEPtr open(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Open_SURFACE(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSURFACE>(ret);
                }
                ~GXSURFACE()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_SURFACE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_SURFACE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_SURFACE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_surface_items(GXLSTPtr param1)
                {
                    GetSurfaceItems_SURFACE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                GXSURFACEITEMPtr get_surface_item(const gx_string_type& param1)
                {
                    int32_t ret = GetSurfaceItem_SURFACE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSURFACEITEM>(ret);
                }
                void add_surface_item(GXSURFACEITEMPtr param1)
                {
                    AddSurfaceItem_SURFACE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void get_surface_names(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetSurfaceNames_SURFACE(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void get_closed_surface_names(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetClosedSurfaceNames_SURFACE(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void get_extents(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetExtents_SURFACE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                static int32_t crc(const gx_string_type& param1, const gx_string_type& param2, int32_t& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CRC_SURFACE(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static void sync(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Sync_SURFACE(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void create_from_dxf(GXIPJPtr param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateFromDXF_SURFACE(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void create_from_vulcan_triangulation(const gx_string_type& param1, GXIPJPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CreateFromVulcanTriangulation_SURFACE(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }
                static void append_vulcan_triangulation(const gx_string_type& param1, GXIPJPtr param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AppendVulcanTriangulation_SURFACE(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }
                static void dump_geometry_to_text_file(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DumpGeometryToTextFile_SURFACE(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXSURFACEITEM
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXSURFACEITEM(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXSURFACEITEMPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXSURFACEITEM>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXSURFACEITEMPtr create(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_SURFACEITEM(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXSURFACEITEM>(ret);
                }
                ~GXSURFACEITEM()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_guid(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    GetGUID_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void set_properties(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, double param5, const gx_string_type& param6, const gx_string_type& param7, double param8)
                {
                    SetProperties_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), &param5, param6.c_str(), param7.c_str(), &param8);
                    gx_->throw_on_error();
                }
                void set_properties_ex(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, double param5, const gx_string_type& param6, const gx_string_type& param7, int32_t param8, double param9, double param10)
                {
                    SetPropertiesEx_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), &param5, param6.c_str(), param7.c_str(), reinterpret_cast<const long*>(&param8), &param9, &param10);
                    gx_->throw_on_error();
                }
                void get_properties(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4, double& param5, gx_string_type& param6, gx_string_type& param7, double& param8)
                {
                    int32_t paramSize2 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize8 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize11 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize13 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    param2.resize(STR_FILE);
                    param3.resize(STR_DEFAULT_SHORT);
                    param4.resize(STR_FILE);
                    param6.resize(STR_DEFAULT_SHORT);
                    param7.resize(STR_FILE);
                    GetProperties_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize6 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize8 ), &param5, (gx_string_char_type*)param6.data(), reinterpret_cast<const long*>(&paramSize11 ), (gx_string_char_type*)param7.data(), reinterpret_cast<const long*>(&paramSize13 ), &param8);
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param6.resize(gx_string_len(param6.c_str()));
                    param7.resize(gx_string_len(param7.c_str()));
                }
                void get_properties_ex(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4, double& param5, gx_string_type& param6, gx_string_type& param7, int32_t& param8, double& param9, double& param10)
                {
                    int32_t paramSize2 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize8 = STR_FILE * STRING_CHAR_SIZE;
                    int32_t paramSize11 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    int32_t paramSize13 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    param2.resize(STR_FILE);
                    param3.resize(STR_DEFAULT_SHORT);
                    param4.resize(STR_FILE);
                    param6.resize(STR_DEFAULT_SHORT);
                    param7.resize(STR_FILE);
                    GetPropertiesEx_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize6 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize8 ), &param5, (gx_string_char_type*)param6.data(), reinterpret_cast<const long*>(&paramSize11 ), (gx_string_char_type*)param7.data(), reinterpret_cast<const long*>(&paramSize13 ), reinterpret_cast<long*>(&param8), &param9, &param10);
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                    param6.resize(gx_string_len(param6.c_str()));
                    param7.resize(gx_string_len(param7.c_str()));
                }
                void set_default_render_properties(int32_t param1, double param2, int32_t param3)
                {
                    SetDefaultRenderProperties_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void get_default_render_properties(int32_t& param1, double& param2, int32_t& param3)
                {
                    GetDefaultRenderProperties_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, reinterpret_cast<long*>(&param3));
                    gx_->throw_on_error();
                }
                int32_t num_components()
                {
                    int32_t ret = iNumComponents_SURFACEITEM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t add_mesh(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6)
                {
                    int32_t ret = iAddMesh_SURFACEITEM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_mesh(int32_t param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7)
                {
                    GetMesh_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                void get_extents(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetExtents_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void get_mesh_info(int32_t param1, int32_t& param2, int32_t& param3, double& param4, double& param5, double& param6)
                {
                    GetMeshInfo_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void get_info(int32_t& param1, double& param2, double& param3, double& param4)
                {
                    GetInfo_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void get_geometry_info(int32_t& param1, int32_t& param2)
                {
                    GetGeometryInfo_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                }
                void compute_extended_info(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5, int32_t& param6, int32_t& param7)
                {
                    ComputeExtendedInfo_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6), reinterpret_cast<long*>(&param7));
                    gx_->throw_on_error();
                }
                void compute_poly_line_intersections(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6)
                {
                    ComputePolyLineIntersections_SURFACEITEM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                int32_t intersects_bounding_box(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    int32_t ret = iIntersectsBoundingBox_SURFACEITEM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXSYS
            {
            private:
                GXSYS();
                ~GXSYS();
            public:


                static void break_date(double param1, int32_t& param2, int32_t& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BreakDate_SYS(
                        gx_->pGeo, &param1, reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }
                static int32_t dateto_long(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDatetoLong_SYS(
                                      gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t timeto_long(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iTimetoLong_SYS(
                                      gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double date()
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rDate_SYS(
                                     gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static double longto_date(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rLongtoDate_SYS(
                                     gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                static double longto_time(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rLongtoTime_SYS(
                                     gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                static double make_date(int32_t param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rMakeDate_SYS(
                                     gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static double secondsto_time(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rSecondstoTime_SYS(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double time()
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rTime_SYS(
                                     gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static double timeto_seconds(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rTimetoSeconds_SYS(
                                     gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static double utc_date()
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rUTCDate_SYS(
                                     gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static double utc_time()
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rUTCTime_SYS(
                                     gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t exist_env(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iExistEnv_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_env(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    IGetEnv_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void set_env(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetEnv_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static int32_t clear_err_ap()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iClearErrAP_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_top_error_ap()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetTopErrorAP_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_error_ap(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetErrorAP_SYS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_error_message_ap(int32_t param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    IGetErrorMessageAP_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static int32_t num_errors_ap()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iNumErrorsAP_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static void set_server_messages_ap(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetServerMessagesAP_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static int32_t run(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRun_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t run_gs(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRunGS_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t run_gx(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRunGX_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t run_python(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRunPython_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t run_gx_ex(const gx_string_type& param1, int32_t& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRunGXEx_SYS(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t run_pdf(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iRunPDF_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t shell_execute(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iShellExecute_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }
                static void set_return(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetReturn_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static void do_command(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_DoCommand_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void error(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Error_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void error_tag(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ErrorTag_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static int32_t assert_gx(int32_t param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iAssertGX_SYS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t ole_automation(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iOLEAutomation_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static void save_log(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SaveLog_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void terminate(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Terminate_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static int32_t crc_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CRCFile_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t crc_file_offset(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CRCFileOffset_SYS(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                static void file_ren(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FileRen_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void find_files_vv(GXVVPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FindFilesVV_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void absolute_file_name(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IAbsoluteFileName_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static int32_t copy_file(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCopyFile_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t delete_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDeleteFile_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t delete_gi_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDeleteGIFile_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t delete_grid_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDeleteGridFile_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void delete_directory(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DeleteDirectory_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static int32_t dir_exist(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDirExist_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t file_exist(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iFileExist_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t file_size(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iFileSize_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t file_writable(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iFileWritable_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t find_path(const gx_string_type& param1, int32_t param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_FILE * STRING_CHAR_SIZE;
                    param3.resize(STR_FILE);
                    int32_t ret = iFindPath_SYS(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                    return ret;
                }
                static int32_t find_path_ex(const gx_string_type& param1, int32_t param2, int32_t param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_FILE * STRING_CHAR_SIZE;
                    param4.resize(STR_FILE);
                    int32_t ret = iFindPathEx_SYS(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    return ret;
                }
                static void get_directory(int32_t param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetDirectory_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void get_path(int32_t param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IGetPath_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void get_windows_dir(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetWindowsDir_SYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static int32_t make_dir(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iMakeDir_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t make_file_readonly(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iMakeFileReadonly_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t make_file_writable(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iMakeFileWritable_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void relative_file_name(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IRelativeFileName_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void short_path_file_name(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    IShortPathFileName_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void temp_file_ext(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    ITempFileExt_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void temp_file_name(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    ITempFileName_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void transfer_path(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    ITransferPath_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static int32_t valid_file_name(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iValidFileName_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t write_in_dir(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iWriteInDir_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static double file_date(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rFileDate_SYS(
                                     gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static double file_time(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rFileTime_SYS(
                                     gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static double utc_file_date(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rUTCFileDate_SYS(
                                     gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static double utc_file_time(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rUTCFileTime_SYS(
                                     gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_settings_meta(GXMETAPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetSettingsMETA_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void global_reset(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GlobalReset_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void global_set(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GlobalSet_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void global_write(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GlobalWrite_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static int32_t global_(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    int32_t ret = IiGlobal_SYS(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }
                static void reset_settings()
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ResetSettings_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static void set_settings_meta(GXMETAPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetSettingsMETA_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static int32_t check_arc_license()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCheckArcLicense_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t check_arc_license_ex(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    int32_t ret = iCheckArcLicenseEx_SYS(
                                      gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    return ret;
                }
                static int32_t check_intrinsic(int32_t param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCheckIntrinsic_SYS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_geodist()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetGeodist_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static void get_license_class(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT);
                    IGetLicenseClass_SYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void get_licensed_user(gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    param2.resize(STR_DEFAULT_LONG);
                    IGetLicensedUser_SYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static int32_t is_signed_in()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsSignedIn_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static void sign_in()
                {
                    GXContextPtr gx_ = GXContext::current();
                    SignIn_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static void check_product_updates(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CheckProductUpdates_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static void geosoft_connect_authenticate_and_navigate(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GeosoftConnectAuthenticateAndNavigate_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void get_geosoft_id(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetGeosoftID_SYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void publish_datasets_to_central(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4, int32_t& param5, int32_t& param6, const gx_string_type& param7, const gx_string_type& param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param4.resize(STR_DEFAULT_SHORT);
                    PublishDatasetsToCentral_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6), param7.c_str(), param8.c_str());
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                }
                static void get_publish_path_for_central(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param2.resize(STR_FILE);
                    GetPublishPathForCentral_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void connect_with_current_central_instance(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize5 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize7 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    param2.resize(STR_DEFAULT_LONG);
                    param3.resize(STR_DEFAULT_LONG);
                    param4.resize(STR_VERY_LONG);
                    ConnectWithCurrentCentralInstance_SYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize7 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                }
                static void get_profile_name(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetProfileName_SYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void get_profile_url(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetProfileURL_SYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void add_lineage_parameter(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AddLineageParameter_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void add_lineage_source(int32_t param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AddLineageSource_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                static void clear_lineage_parameters()
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClearLineageParameters_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static void clear_lineage_sources()
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClearLineageSources_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static void copy_geo_file(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CopyGeoFile_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void backup_geo_file(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    IBackupGeoFile_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void remove_lineage_output(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveLineageOutput_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void remove_lineage_parameter(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveLineageParameter_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void remove_lineage_source(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveLineageSource_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void restore_geo_file(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RestoreGeoFile_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void set_lineage_description(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetLineageDescription_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void set_lineage_display_name(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetLineageDisplayName_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void set_lineage_name(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetLineageName_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void clear_menus(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_ClearMenus_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static void get_loaded_menus(GXLSTPtr param1, GXLSTPtr param2, GXLSTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_GetLoadedMenus_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void set_loaded_menus(GXLSTPtr param1, GXLSTPtr param2, GXLSTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetLoadedMenus_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void get_entitlement_rights(GXLSTPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetEntitlementRights_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void generate_guid(gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize1 = STR_DEFAULT_SHORT * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_SHORT);
                    GenerateGUID_SYS(
                        gx_->pGeo, (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize1 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                static void clipboard_to_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClipboardToFile_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static GXRAPtr create_clipboard_ra()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateClipboardRA_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXRA>(ret);
                }
                static GXWAPtr create_clipboard_wa()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateClipboardWA_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXWA>(ret);
                }
                static void emf_object_size(const gx_string_type& param1, double& param2, double& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EMFObjectSize_SYS(
                        gx_->pGeo, param1.c_str(), &param2, &param3);
                    gx_->throw_on_error();
                }
                static void file_to_clipboard(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FileToClipboard_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void font_lst(GXLSTPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FontLST_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static int32_t get_dot_net_gx_entries(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    int32_t ret = IiGetDotNetGXEntries_SYS(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }
                static void send_general_message(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SendGeneralMessage_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void write_debug_log(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    WriteDebugLog_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void log_script_run(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LogScriptRun_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static int32_t get_thread_id()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetThreadID_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static void run_multi_user_script(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RunMultiUserScript_SYS(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void clear_group(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClearGroup_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void clear_group_parm(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClearGroupParm_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void clear_parm()
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClearParm_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static void default_int(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DefaultInt_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void default_double(const gx_string_type& param1, const gx_string_type& param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DefaultReal_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3);
                    gx_->throw_on_error();
                }
                static void default_string(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DefaultString_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static void get_pattern(const gx_string_type& param1, int32_t& param2, double& param3, int32_t& param4, double& param5, int32_t& param6, int32_t& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetPattern_SYS(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), &param3, reinterpret_cast<long*>(&param4), &param5, reinterpret_cast<long*>(&param6), reinterpret_cast<long*>(&param7));
                    gx_->throw_on_error();
                }
                static void get_reg(GXREGPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetREG_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static void gt_string(const gx_string_type& param1, const gx_string_type& param2, gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    GtString_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                static int32_t exist_int(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iExistInt_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t exist_double(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iExistReal_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t exist_string(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iExistString_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_int(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetInt_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_yes_no(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetYesNo_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void replace_string(const gx_string_type& param1, gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    IReplaceString_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), param3.c_str());
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void load_parm(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    LoadParm_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static double get_double(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rGetReal_SYS(
                                     gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void save_parm(const gx_string_type& param1, int32_t param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SaveParm_SYS(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                static void filter_parm_group(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FilterParmGroup_SYS(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void set_int(const gx_string_type& param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetInt_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void set_pattern(const gx_string_type& param1, int32_t param2, double param3, int32_t param4, double param5, int32_t param6, int32_t param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetPattern_SYS(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), &param3, reinterpret_cast<const long*>(&param4), &param5, reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void set_double(const gx_string_type& param1, const gx_string_type& param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetReal_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), &param3);
                    gx_->throw_on_error();
                }
                static void set_reg(GXREGPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetREG_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void set_string(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetString_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                }
                static int32_t check_stop()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCheckStop_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t prog_state()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iProgState_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static void prog_name(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProgName_SYS(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void progress(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Progress_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static void prog_update(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProgUpdate_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static void prog_update_l(int32_t param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ProgUpdateL_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void get_sys_info(int32_t param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    IGetSysInfo_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static int32_t registry_get_val(int32_t param1, const gx_string_type& param2, const gx_string_type& param3, gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param4.resize(STR_VERY_LONG);
                    int32_t ret = IiRegistryGetVal_SYS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str(), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param4.resize(gx_string_len(param4.c_str()));
                    return ret;
                }
                static int32_t registry_delete_key(int32_t param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRegistryDeleteKey_SYS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t registry_delete_val(int32_t param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iRegistryDeleteVal_SYS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void registry_set_val(int32_t param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RegistrySetVal_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), param2.c_str(), param3.c_str(), param4.c_str());
                    gx_->throw_on_error();
                }
                static void destroy_ptmp(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DestroyPTMP_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static void get_ptmp(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetPTMP_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static int32_t save_ptmp(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = SavePTMP_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void abort(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    _Abort_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void assert_(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    _Assert_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static void exit_()
                {
                    GXContextPtr gx_ = GXContext::current();
                    _Exit_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static void cancel_()
                {
                    GXContextPtr gx_ = GXContext::current();
                    Cancel_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static int32_t delay(double param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDelay_SYS(
                                      gx_->pGeo, &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t get_timer(int32_t param1, double& param2, double& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iGetTimer_SYS(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }
                static void display_help(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_DisplayHelp_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void display_help_topic(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_DisplayHelpTopic_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void display_int(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_DisplayInt_SYS(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void display_message(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_DisplayMessage_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void display_double(const gx_string_type& param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_DisplayReal_SYS(
                        gx_->pGeo, param1.c_str(), &param2);
                    gx_->throw_on_error();
                }
                static int32_t display_question(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iDisplayQuestion_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t display_question_with_cancel(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = App_iDisplayQuestionWithCancel_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t display_task_dialog_ui(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4, GXLSTPtr param5, int32_t param6, const gx_string_type& param7, int32_t param8, const gx_string_type& param9, int32_t& param10, const gx_string_type& param11, const gx_string_type& param12, const gx_string_type& param13)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDisplayTaskDialogUI_SYS(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), param7.c_str(), reinterpret_cast<const long*>(&param8), param9.c_str(), reinterpret_cast<long*>(&param10), param11.c_str(), param12.c_str(), param13.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t interactive()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iInteractive_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t testing_system_mode()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iTestingSystemMode_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t prompt(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    int32_t ret = App_IiPrompt_SYS(
                                      gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    return ret;
                }
                static int32_t script()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iScript_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t script_record()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iScriptRecord_SYS(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static void set_cursor(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetCursor_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void set_info_line(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    App_SetInfoLine_SYS(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                static void set_interactive(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetInteractive_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static void get_workspace_reg(GXREGPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetWorkspaceREG_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void set_workspace_reg(GXREGPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SetWorkspaceREG_SYS(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void encrypt_string(const gx_string_type& param1, gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    EncryptString_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void decrypt_string(const gx_string_type& param1, gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    DecryptString_SYS(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static int32_t is_encrypted_string(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = IsEncryptedString_SYS(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void disable_gx_debugger()
                {
                    GXContextPtr gx_ = GXContext::current();
                    DisableGXDebugger_SYS(
                        gx_->pGeo);
                    gx_->throw_on_error();
                }
                static void enable_gx_debugger(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EnableGXDebugger_SYS(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXTB
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXTB(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXTBPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXTB>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void set_search_mode(int32_t param1)
                {
                    _SetSearchMode_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_sort_mode(int32_t param1)
                {
                    SetSortMode_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static GXTBPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_TB(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTB>(ret);
                }
                static GXTBPtr create_db(GXDBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateDB_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTB>(ret);
                }
                static GXTBPtr create_ltb(GXLTBPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateLTB_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTB>(ret);
                }
                ~GXTB()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t field(const gx_string_type& param1)
                {
                    int32_t ret = Field_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void get_string(int32_t param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    GetString_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                int32_t data_type(int32_t param1)
                {
                    int32_t ret = iDataType_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void find_col_by_index(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    IFindColByIndex_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t find_col_by_name(const gx_string_type& param1)
                {
                    int32_t ret = iFindColByName_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t format(int32_t param1)
                {
                    int32_t ret = iFormat_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_int(int32_t param1, int32_t param2)
                {
                    int32_t ret = iGetInt_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t num_columns()
                {
                    int32_t ret = iNumColumns_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t num_rows()
                {
                    int32_t ret = iNumRows_TB(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void load_db(GXDBPtr param1, int32_t param2)
                {
                    LoadDB_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                double get_double(int32_t param1, int32_t param2)
                {
                    double ret = rGetReal_TB(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void save(const gx_string_type& param1)
                {
                    Save_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void save_db(GXDBPtr param1, int32_t param2)
                {
                    SaveDB_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void save_to_ascii(const gx_string_type& param1)
                {
                    SaveToAscii_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_int(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetInt_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void set_double(int32_t param1, int32_t param2, double param3)
                {
                    SetReal_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }
                void set_string(int32_t param1, int32_t param2, const gx_string_type& param3)
                {
                    SetString_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                void sort(int32_t param1)
                {
                    Sort_TB(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

            };
            class GXTC
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXTC(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXTCPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXTC>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXTCPtr create(GXIMGPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, int32_t param8, double param9, int32_t param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_TC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), &param9, reinterpret_cast<const long*>(&param10));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTC>(ret);
                }
                static GXTCPtr create_ex(GXIMGPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, int32_t param8, double param9, int32_t param10, int32_t param11)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateEx_TC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTC>(ret);
                }
                static GXTCPtr create_ex2(GXIMGPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, int32_t param8, double param9, int32_t param10, int32_t param11, GXIMGPtr param12)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateEx2_TC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), &param9, reinterpret_cast<const long*>(&param10), reinterpret_cast<const long*>(&param11), reinterpret_cast<const long*>(&gx_->handle(param12)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTC>(ret);
                }
                ~GXTC()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_TC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void grregter(GXIMGPtr param1, GXIMGPtr param2)
                {
                    Grregter_TC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void grterain(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXIMGPtr param6, double param7)
                {
                    Grterain_TC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), &param7);
                    gx_->throw_on_error();
                }
                void grterain2(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXIMGPtr param7, double param8)
                {
                    Grterain2_TC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), &param8);
                    gx_->throw_on_error();
                }
                void g_gterain(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, int32_t param7)
                {
                    GGterain_TC(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

            };
            class GXTEST
            {
            private:
                GXTEST();
                ~GXTEST();
            public:


                static void enable_disable_arc_engine_license(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    EnableDisableArcEngineLicense_TEST(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                static int32_t arc_engine_license()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iArcEngineLicense_TEST(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t test_mode()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iTestMode_TEST(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return ret;
                }
                static void wrapper_test(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    WrapperTest_TEST(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void core_class(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    CoreClass_TEST(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXTIN
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXTIN(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXTINPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXTIN>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void copy(GXTINPtr param1)
                {
                    Copy_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXTINPtr create(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_TIN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTIN>(ret);
                }
                static GXTINPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_TIN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTIN>(ret);
                }
                ~GXTIN()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                static void export_xml(const gx_string_type& param1, int32_t& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportXML_TIN(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                void get_convex_hull(GXPLYPtr param1)
                {
                    GetConvexHull_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_joins(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GetJoins_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void get_mesh(GXVVPtr param1)
                {
                    GetMesh_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_nodes(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GetNodes_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void get_triangles(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GetTriangles_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void get_triangle(int32_t param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7)
                {
                    GetTriangle_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }
                void get_voronoi_edges(GXVVPtr param1)
                {
                    GetVoronoiEdges_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                int32_t is_z_valued()
                {
                    int32_t ret = iIsZValued_TIN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t locate_triangle(int32_t param1, double param2, double param3)
                {
                    int32_t ret = iLocateTriangle_TIN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t nodes()
                {
                    int32_t ret = iNodes_TIN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void interp_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    InterpVV_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                int32_t triangles()
                {
                    int32_t ret = iTriangles_TIN(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void linear_interp_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    LinearInterpVV_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void nearest_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    NearestVV_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void range_xy(double& param1, double& param2, double& param3, double& param4)
                {
                    RangeXY_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void serial(GXBFPtr param1)
                {
                    Serial_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_TIN(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

            };
            class GXTPAT
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXTPAT(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXTPATPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXTPAT>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_color(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, int32_t param4)
                {
                    AddColor_TPAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static GXTPATPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_TPAT(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTPAT>(ret);
                }
                ~GXTPAT()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_TPAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t code(const gx_string_type& param1)
                {
                    int32_t ret = iCode_TPAT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void get_solid_pattern(int32_t param1, gx_string_type& param2, gx_string_type& param3, gx_string_type& param4, int32_t& param5)
                {
                    int32_t paramSize3 = TPAT_CODE_SIZE * STRING_CHAR_SIZE;
                    int32_t paramSize5 = TPAT_LABEL_SIZE * STRING_CHAR_SIZE;
                    int32_t paramSize7 = TPAT_DESC_SIZE * STRING_CHAR_SIZE;
                    param2.resize(TPAT_CODE_SIZE);
                    param3.resize(TPAT_LABEL_SIZE);
                    param4.resize(TPAT_DESC_SIZE);
                    IGetSolidPattern_TPAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize5 ), (gx_string_char_type*)param4.data(), reinterpret_cast<const long*>(&paramSize7 ), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                    param4.resize(gx_string_len(param4.c_str()));
                }
                int32_t size()
                {
                    int32_t ret = iSize_TPAT(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void load_csv(const gx_string_type& param1)
                {
                    LoadCSV_TPAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void setup_translation_vv(GXLTBPtr param1, int32_t param2, GXVVPtr param3)
                {
                    SetupTranslationVV_TPAT(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }

            };
            class GXTR
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXTR(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXTRPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXTR>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXTRPtr create(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_TR(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXTR>(ret);
                }
                ~GXTR()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_TR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void copy(GXTRPtr param1)
                {
                    Copy_TR(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

            };
            class GXTRANSFORMLAYER
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXTRANSFORMLAYER(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXTRANSFORMLAYERPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXTRANSFORMLAYER>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void end(int32_t param1)
                {
                    App_End_TRANSFORMLAYER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void cancel_()
                {
                    App_Cancel_TRANSFORMLAYER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void undo()
                {
                    App_Undo_TRANSFORMLAYER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void redo()
                {
                    App_Redo_TRANSFORMLAYER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                int32_t can_undo()
                {
                    int32_t ret = App_iCanUndo_TRANSFORMLAYER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t can_redo()
                {
                    int32_t ret = App_iCanRedo_TRANSFORMLAYER(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void save_to_new_layer_grid(const gx_string_type& param1)
                {
                    App_SaveToNewLayerGrid_TRANSFORMLAYER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void apply_constant_transform(double param1)
                {
                    App_ApplyConstantTransform_TRANSFORMLAYER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void select_node(int32_t param1)
                {
                    App_SelectNode_TRANSFORMLAYER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void clear_node_selection()
                {
                    App_ClearNodeSelection_TRANSFORMLAYER(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

            };
            class GXTRND
            {
            private:
                GXTRND();
                ~GXTRND();
            public:


                static void get_max_min(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, double param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetMaxMin_TRND(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void get_mesh(GXDBPtr param1, const gx_string_type& param2, double param3, double param4, GXVVPtr param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetMesh_TRND(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void trnd_db(GXDBPtr param1, const gx_string_type& param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TrndDB_TRND(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10);
                    gx_->throw_on_error();
                }

            };
            class GXUNC
            {
            private:
                GXUNC();
                ~GXUNC();
            public:


                static int32_t is_valid_utf16_char(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iIsValidUTF16Char_UNC(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t valid_symbol(const gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iValidSymbol_UNC(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static void utf16_val_to_str(int32_t param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = UTF8_MAX_CHAR * STRING_CHAR_SIZE;
                    param2.resize(UTF8_MAX_CHAR);
                    UTF16ValToSTR_UNC(
                        gx_->pGeo, reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static void validate_symbols(GXVVPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ValidateSymbols_UNC(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

            };
            class GXUSERMETA
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXUSERMETA(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXUSERMETAPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXUSERMETA>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXUSERMETAPtr create(int32_t param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_USERMETA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXUSERMETA>(ret);
                }
                static GXUSERMETAPtr create_s(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_USERMETA(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXUSERMETA>(ret);
                }
                ~GXUSERMETA()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_data_creation_date(double& param1)
                {
                    GetDataCreationDate_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void get_extents2d(double& param1, double& param2, double& param3, double& param4)
                {
                    GetExtents2d_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void get_extents3d(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetExtents3d_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_meta_creation_date(double& param1)
                {
                    GetMetaCreationDate_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void get_xml_format(int32_t& param1)
                {
                    GetXMLFormat_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_xml_format(int32_t param1)
                {
                    SetXMLFormat_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                int32_t compare(GXUSERMETAPtr param1)
                {
                    int32_t ret = iCompare_USERMETA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_data_creator(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetDataCreator_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_format(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetFormat_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_meta_creator(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetMetaCreator_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_project(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetProject_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_title(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_DEFAULT_LONG);
                    IGetTitle_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void serial(int32_t param1, const gx_string_type& param2)
                {
                    Serial_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_data_creation_date(double param1)
                {
                    SetDataCreationDate_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_data_creator(const gx_string_type& param1)
                {
                    SetDataCreator_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_extents2d(double param1, double param2, double param3, double param4)
                {
                    SetExtents2d_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void set_extents3d(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    SetExtents3d_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void set_format(const gx_string_type& param1)
                {
                    SetFormat_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_meta_creation_date(double param1)
                {
                    SetMetaCreationDate_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_meta_creator(const gx_string_type& param1)
                {
                    SetMetaCreator_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_project(const gx_string_type& param1)
                {
                    SetProject_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void set_title(const gx_string_type& param1)
                {
                    SetTitle_USERMETA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                static void update_extents_2d(const gx_string_type& param1, GXIPJPtr param2, double param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    UpdateExtents2D_USERMETA(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                static void update_file_type(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    UpdateFileType_USERMETA(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                static void save_file_lineage(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SaveFileLineage_USERMETA(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

            };
            class GXVA
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVA(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVAPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVA>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }




                template <typename T>
                std::vector<T> get_array(int32_t start_row, int32_t start_column, int32_t num_rows, int32_t num_columns)
                {
                    std::vector<T> data(num_rows*num_columns);
                    iGetArray_VA(gx_->pGeo, reinterpret_cast<const long*>(&handle_), start_row, start_column, num_rows, num_columns, data.data(), gs_cpp_type<T>::type());
                    gx_->throw_on_error();
                    return data;
                }


                template <typename T>
                void set_array(int32_t start_row, int32_t start_column, int32_t num_rows, int32_t num_columns, const std::vector<T>& data)
                {
                    if (data.size() != num_rows*num_columns)
                        throw GXAPIError(gx_string_literal("data size is not equal to num_rows*num_columns"));
                    iSetArray_VA(gx_->pGeo, reinterpret_cast<const long*>(&handle_), start_row, start_column, num_rows, num_columns, data.data(), gs_cpp_type<T>::type());
                    gx_->throw_on_error();
                }

                void add_elevations_vv_to_depths(GXVVPtr param1, int32_t param2)
                {
                    AddElevationsVVToDepths_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void append(GXVAPtr param1)
                {
                    Append_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void average(GXVVPtr param1, int32_t param2)
                {
                    Average_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void copy(GXVAPtr param1)
                {
                    Copy_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void copy2(int32_t param1, int32_t param2, GXVAPtr param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    Copy2_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static GXVAPtr create(int32_t param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVA>(ret);
                }
                static GXVAPtr create_ext(int32_t param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateExt_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVA>(ret);
                }
                static GXVAPtr create_vv(GXVVPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateVV_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVA>(ret);
                }
                ~GXVA()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                GXVVPtr get_full_vv()
                {
                    int32_t ret = GetFullVV_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                void get_vv(int32_t param1, int32_t param2, GXVVPtr param3)
                {
                    GetVV_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                int32_t col()
                {
                    int32_t ret = iCol_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_int(int32_t param1, int32_t param2)
                {
                    int32_t ret = iGetInt_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_string(int32_t param1, int32_t param2, gx_string_type& param3)
                {
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param3.resize(STR_VERY_LONG);
                    IGetString_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize4 ));
                    gx_->throw_on_error();
                    param3.resize(gx_string_len(param3.c_str()));
                }
                int32_t len()
                {
                    int32_t ret = iLen_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                static void index_order(GXVVPtr param1, GXVAPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IndexOrder_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void lookup_index(GXVVPtr param1, GXVAPtr param2)
                {
                    LookupIndex_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void range(int32_t param1, int32_t param2, int32_t param3, int32_t param4, double& param5, double& param6)
                {
                    Range_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), &param5, &param6);
                    gx_->throw_on_error();
                }
                void range_double(double& param1, double& param2)
                {
                    RangeDouble_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void range_columns(int32_t param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5, GXVVPtr param6)
                {
                    RangeColumns_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                void re_fid(double param1, double param2, int32_t param3)
                {
                    ReFid_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void reverse()
                {
                    Reverse_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                double get_fid_incr()
                {
                    double ret = rGetFidIncr_VA(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_fid_start()
                {
                    double ret = rGetFidStart_VA(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_double(int32_t param1, int32_t param2)
                {
                    double ret = rGetReal_VA(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_fid_incr(double param1)
                {
                    SetFidIncr_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_fid_start(double param1)
                {
                    SetFidStart_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_int(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetInt_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void set_int_n(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetIntN_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void set_ln(int32_t param1)
                {
                    SetLn_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_double(int32_t param1, int32_t param2, double param3)
                {
                    SetReal_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }
                void set_string(int32_t param1, int32_t param2, const gx_string_type& param3)
                {
                    SetString_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                void set_vv(int32_t param1, int32_t param2, GXVVPtr param3)
                {
                    SetVV_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void trans(double param1, double param2)
                {
                    Trans_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void window(int32_t param1, int32_t param2, GXVVPtr param3)
                {
                    Window_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void window2(double param1, double param2, GXVVPtr param3)
                {
                    Window2_VA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                int32_t check_for_repeating(GXVVPtr param1, int32_t param2, GXVVPtr param3, double param4)
                {
                    int32_t ret = iCheckForRepeating_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t check_for_repeating2(GXVVPtr param1, int32_t param2, GXVVPtr param3, double param4, int32_t& param5, int32_t& param6)
                {
                    int32_t ret = iCheckForRepeating2_VA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                    return ret;
                }

            };
            class GXVAU
            {
            private:
                GXVAU();
                ~GXVAU();
            public:


                static void prune(GXVAPtr param1, GXVVPtr param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Prune_VAU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void total_vector(GXVAPtr param1, GXVAPtr param2, GXVAPtr param3, GXVAPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TotalVector_VAU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }

            };
            class GXVECTOR3D
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVECTOR3D(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVECTOR3DPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVECTOR3D>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                ~GXVECTOR3D()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VECTOR3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_itr(GXITRPtr param1)
                {
                    GetITR_VECTOR3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_itr(GXITRPtr param1)
                {
                    SetITR_VECTOR3D(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }

            };
            class GXVM
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVM(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVMPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVM>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXVMPtr create(int32_t param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_VM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVM>(ret);
                }
                static GXVMPtr create_ext(int32_t param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateExt_VM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVM>(ret);
                }
                ~GXVM()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                int32_t get_int(int32_t param1)
                {
                    int32_t ret = iGetInt_VM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_string(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    IGetString_VM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t length()
                {
                    int32_t ret = iLength_VM(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void re_size(int32_t param1)
                {
                    ReSize_VM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                double get_double(int32_t param1)
                {
                    double ret = rGetReal_VM(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_int(int32_t param1, int32_t param2)
                {
                    SetInt_VM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_double(int32_t param1, double param2)
                {
                    SetReal_VM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                void set_string(int32_t param1, const gx_string_type& param2)
                {
                    SetString_VM(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXVOX
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVOX(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVOXPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVOX>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void calc_stats(GXSTPtr param1)
                {
                    CalcStats_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXVOXPtr create(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_VOX(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }
                GXPGPtr create_pg()
                {
                    int32_t ret = CreatePG_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }
                GXPGPtr create_type_pg(int32_t param1)
                {
                    int32_t ret = CreateTypePG_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }
                ~GXVOX()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void dump(const gx_string_type& param1)
                {
                    Dump_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void export_img(const gx_string_type& param1, int32_t param2)
                {
                    ExportIMG_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void export_to_grids(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, double param6, int32_t param7)
                {
                    ExportToGrids_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), &param6, reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }
                static void export_xml(const gx_string_type& param1, int32_t& param2, const gx_string_type& param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportXML_VOX(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                void export_seg_y(const gx_string_type& param1, double param2)
                {
                    ExportSegY_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2);
                    gx_->throw_on_error();
                }
                static void export_ji_gs_xml(const gx_string_type& param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExportJIGsXML_VOX(
                        gx_->pGeo, param1.c_str(), param2.c_str());
                    gx_->throw_on_error();
                }
                void export_xyz(const gx_string_type& param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    ExportXYZ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                void filter(int32_t param1, const gx_string_type& param2, int32_t param3, int32_t param4, const gx_string_type& param5)
                {
                    Filter_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), param5.c_str());
                    gx_->throw_on_error();
                }
                static void generate_db(const gx_string_type& param1, GXDBPtr param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenerateDB_VOX(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void generate_vector_voxel_from_db(const gx_string_type& param1, GXDBPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, double param7, double param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenerateVectorVoxelFromDB_VOX(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), &param7, &param8);
                    gx_->throw_on_error();
                }
                static GXVOXPtr generate_pg(const gx_string_type& param1, GXPGPtr param2, double param3, double param4, double param5, double param6, double param7, double param8, GXIPJPtr param9, GXMETAPtr param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GeneratePG_VOX(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, &param6, &param7, &param8, reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }
                static GXVOXPtr generate_pgvv(const gx_string_type& param1, GXPGPtr param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXIPJPtr param9, GXMETAPtr param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GeneratePGVV_VOX(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }
                static GXVOXPtr init_generate_by_subset_pg(int32_t param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = InitGenerateBySubsetPG_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }
                void add_generate_by_subset_pg(GXPGPtr param1, int32_t param2, int32_t param3)
                {
                    AddGenerateBySubsetPG_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void end_generate_by_subset_pg(const gx_string_type& param1, double param2, double param3, double param4, double param5, double param6, double param7, GXIPJPtr param8, GXMETAPtr param9)
                {
                    EndGenerateBySubsetPG_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), &param2, &param3, &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }
                void get_area(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetArea_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void get_gocad_location(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12)
                {
                    GetGOCADLocation_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                }
                void get_grid_section_cell_sizes(double param1, double& param2, double& param3)
                {
                    GetGridSectionCellSizes_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3);
                    gx_->throw_on_error();
                }
                void get_info(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5)
                {
                    GetInfo_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5));
                    gx_->throw_on_error();
                }
                void get_ipj(GXIPJPtr param1)
                {
                    GetIPJ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_limits(int32_t& param1, int32_t& param2, int32_t& param3, int32_t& param4, int32_t& param5, int32_t& param6)
                {
                    GetLimits_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), reinterpret_cast<long*>(&param2), reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4), reinterpret_cast<long*>(&param5), reinterpret_cast<long*>(&param6));
                    gx_->throw_on_error();
                }
                void get_limits_xyz(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetLimitsXYZ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void get_location(double& param1, double& param2, double& param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6)
                {
                    GetLocation_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                void get_location_points(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GetLocationPoints_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void get_meta(GXMETAPtr param1)
                {
                    GetMETA_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_double_location(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8, double& param9, double& param10, double& param11, double& param12)
                {
                    GetRealLocation_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, &param11, &param12);
                    gx_->throw_on_error();
                }
                void get_simple_location(double& param1, double& param2, double& param3, double& param4, double& param5, double& param6)
                {
                    GetSimpleLocation_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                GXSTPtr get_stats()
                {
                    int32_t ret = GetStats_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXST>(ret);
                }
                void get_tpat(GXTPATPtr param1)
                {
                    GetTPAT_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static GXVOXPtr grid_points(const gx_string_type& param1, const gx_string_type& param2, double param3, int32_t param4, double param5, double param6, int32_t param7, int32_t param8, int32_t param9, double param10, double param11, double param12, double param13, double param14, int32_t param15, GXVVPtr param16, GXVVPtr param17, GXVVPtr param18, GXVVPtr param19, GXIPJPtr param20)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GridPoints_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), &param3, reinterpret_cast<const long*>(&param4), &param5, &param6, reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), &param10, &param11, &param12, &param13, &param14, reinterpret_cast<const long*>(&param15), reinterpret_cast<const long*>(&gx_->handle(param16)), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&gx_->handle(param18)), reinterpret_cast<const long*>(&gx_->handle(param19)), reinterpret_cast<const long*>(&gx_->handle(param20)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }
                static GXVOXPtr grid_points_z(const gx_string_type& param1, const gx_string_type& param2, double param3, const gx_string_type& param4, int32_t param5, double param6, double param7, int32_t param8, int32_t param9, int32_t param10, double param11, double param12, double param13, double param14, double param15, int32_t param16, GXVVPtr param17, GXVVPtr param18, GXVVPtr param19, GXVVPtr param20, GXIPJPtr param21)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GridPointsZ_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, reinterpret_cast<const long*>(&param16), reinterpret_cast<const long*>(&gx_->handle(param17)), reinterpret_cast<const long*>(&gx_->handle(param18)), reinterpret_cast<const long*>(&gx_->handle(param19)), reinterpret_cast<const long*>(&gx_->handle(param20)), reinterpret_cast<const long*>(&gx_->handle(param21)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }
                static GXVOXPtr grid_points_z_ex(const gx_string_type& param1, const gx_string_type& param2, double param3, const gx_string_type& param4, int32_t param5, double param6, double param7, int32_t param8, int32_t param9, int32_t param10, double param11, double& param12, double& param13, double param14, double& param15, double param16, double param17, double param18, double param19, double param20, int32_t param21, GXVVPtr param22, GXVVPtr param23, GXVVPtr param24, GXVVPtr param25, GXIPJPtr param26)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GridPointsZEx_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18, &param19, &param20, reinterpret_cast<const long*>(&param21), reinterpret_cast<const long*>(&gx_->handle(param22)), reinterpret_cast<const long*>(&gx_->handle(param23)), reinterpret_cast<const long*>(&gx_->handle(param24)), reinterpret_cast<const long*>(&gx_->handle(param25)), reinterpret_cast<const long*>(&gx_->handle(param26)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }
                int32_t can_append_to(const gx_string_type& param1)
                {
                    int32_t ret = iCanAppendTo_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                void get_cell_size_strings(gx_string_type& param1, gx_string_type& param2, gx_string_type& param3, double param4, double param5, double param6)
                {
                    int32_t paramSize2 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize4 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    int32_t paramSize6 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param1.resize(STR_VERY_LONG);
                    param2.resize(STR_VERY_LONG);
                    param3.resize(STR_VERY_LONG);
                    IGetCellSizeStrings_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize4 ), (gx_string_char_type*)param3.data(), reinterpret_cast<const long*>(&paramSize6 ), &param4, &param5, &param6);
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                    param2.resize(gx_string_len(param2.c_str()));
                    param3.resize(gx_string_len(param3.c_str()));
                }
                int32_t is_thematic()
                {
                    int32_t ret = iIsThematic_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t is_vector_voxel()
                {
                    int32_t ret = iIsVectorVoxel_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t set_cell_size_strings(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3)
                {
                    int32_t ret = iSetCellSizeStrings_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), param2.c_str(), param3.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static GXVOXPtr log_grid_points_z_ex(const gx_string_type& param1, const gx_string_type& param2, double param3, const gx_string_type& param4, int32_t param5, double param6, double param7, int32_t param8, int32_t param9, int32_t param10, double param11, double& param12, double& param13, double param14, double& param15, double param16, double param17, double param18, double param19, double param20, int32_t param21, double param22, int32_t param23, GXVVPtr param24, GXVVPtr param25, GXVVPtr param26, GXVVPtr param27, GXIPJPtr param28)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = LogGridPointsZEx_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), &param3, param4.c_str(), reinterpret_cast<const long*>(&param5), &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, &param13, &param14, &param15, &param16, &param17, &param18, &param19, &param20, reinterpret_cast<const long*>(&param21), &param22, reinterpret_cast<const long*>(&param23), reinterpret_cast<const long*>(&gx_->handle(param24)), reinterpret_cast<const long*>(&gx_->handle(param25)), reinterpret_cast<const long*>(&gx_->handle(param26)), reinterpret_cast<const long*>(&gx_->handle(param27)), reinterpret_cast<const long*>(&gx_->handle(param28)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }
                static GXVOXPtr krig(const gx_string_type& param1, double param2, int32_t param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXIPJPtr param8, GXREGPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Krig_VOX(
                                      gx_->pGeo, param1.c_str(), &param2, reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }
                static GXVOXPtr math(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, const gx_string_type& param4, const gx_string_type& param5, GXLSTPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Math_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }
                void merge(GXVOXPtr param1, GXREGPtr param2, const gx_string_type& param3)
                {
                    Merge_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }
                static GXVOXPtr nearest_neighbour_grid(const gx_string_type& param1, double param2, double param3, int32_t param4, GXVVPtr param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXIPJPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = NearestNeighbourGrid_VOX(
                                      gx_->pGeo, param1.c_str(), &param2, &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }
                static double compute_cell_size(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    double ret = rComputeCellSize_VOX(
                                     gx_->pGeo, &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                    return ret;
                }
                void re_grid(GXVOXPtr param1, GXREGPtr param2, const gx_string_type& param3)
                {
                    ReGrid_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str());
                    gx_->throw_on_error();
                }
                GXPGPtr resample_pg(GXIPJPtr param1, double param2, double param3, double param4, double param5, double param6, double param7, int32_t param8, int32_t param9, int32_t param10, double param11, double param12, int32_t param13)
                {
                    int32_t ret = ResamplePG_VOX(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12, reinterpret_cast<const long*>(&param13));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXPG>(ret);
                }
                void rescale_cell_sizes(double param1)
                {
                    RescaleCellSizes_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void sample_cdi(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8, const gx_string_type& param9)
                {
                    SampleCDI_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8), param9.c_str());
                    gx_->throw_on_error();
                }
                void sample_cdi_to_topography(GXDBPtr param1, int32_t param2, int32_t param3, int32_t param4, GXVVPtr param5, int32_t param6, const gx_string_type& param7, const gx_string_type& param8)
                {
                    SampleCDIToTopography_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&param6), param7.c_str(), param8.c_str());
                    gx_->throw_on_error();
                }
                void sample_vv(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4, GXVVPtr param5)
                {
                    SampleVV_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                void set_ipj(GXIPJPtr param1)
                {
                    SetIPJ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_location(double param1, double param2, double param3, GXVVPtr param4, GXVVPtr param5, GXVVPtr param6)
                {
                    SetLocation_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                void set_meta(GXMETAPtr param1)
                {
                    SetMETA_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_origin(int32_t param1, double param2, double param3, double param4)
                {
                    SetOrigin_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4);
                    gx_->throw_on_error();
                }
                void set_simple_location(double param1, double param2, double param3, double param4, double param5, double param6)
                {
                    SetSimpleLocation_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6);
                    gx_->throw_on_error();
                }
                void set_tpat(GXTPATPtr param1)
                {
                    SetTPAT_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void slice_ipj(const gx_string_type& param1, GXIPJPtr param2, int32_t param3, double param4, double param5, double param6, double param7, int32_t param8, int32_t param9)
                {
                    SliceIPJ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                void slice_multi_layer_ipj(const gx_string_type& param1, GXIPJPtr param2, int32_t param3, double param4, double param5, double param6, double param7, int32_t param8, int32_t param9, int32_t param10, double param11, double param12)
                {
                    SliceMultiLayerIPJ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9), reinterpret_cast<const long*>(&param10), &param11, &param12);
                    gx_->throw_on_error();
                }
                void subset_to_double_extents(const gx_string_type& param1)
                {
                    SubsetToRealExtents_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                static void sync(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Sync_VOX(
                        gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                }
                void window_ply(GXPLYPtr param1, int32_t param2, double param3, double param4, const gx_string_type& param5, int32_t param6)
                {
                    WindowPLY_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, &param4, param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                void window_xyz(double param1, double param2, double param3, double param4, double param5, double param6, const gx_string_type& param7, int32_t param8)
                {
                    WindowXYZ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, param7.c_str(), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                void write_xml(const gx_string_type& param1)
                {
                    WriteXML_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                void convert_numeric_to_thematic(GXVVPtr param1, const gx_string_type& param2)
                {
                    ConvertNumericToThematic_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void convert_thematic_to_numeric(GXVVPtr param1, const gx_string_type& param2)
                {
                    ConvertThematicToNumeric_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void convert_velocity_to_density(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, const gx_string_type& param9)
                {
                    ConvertVelocityToDensity_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, param9.c_str());
                    gx_->throw_on_error();
                }
                void convert_velocity_in_range_to_density(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, const gx_string_type& param11)
                {
                    ConvertVelocityInRangeToDensity_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, param11.c_str());
                    gx_->throw_on_error();
                }
                void convert_density_to_velocity(double param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8, double param9, double param10, const gx_string_type& param11)
                {
                    ConvertDensityToVelocity_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, &param7, &param8, &param9, &param10, param11.c_str());
                    gx_->throw_on_error();
                }
                void invert_z(const gx_string_type& param1)
                {
                    InvertZ_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                static void dw_grid_db(const gx_string_type& param1, GXDBPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, GXREGPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    IDWGridDB_VOX(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                static void tin_grid_db(const gx_string_type& param1, GXDBPtr param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7, GXVVPtr param8, GXREGPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TINGridDB_VOX(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }
                static void get_multi_voxset_guid(const gx_string_type& param1, gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t paramSize2 = STR_DEFAULT_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_DEFAULT_LONG);
                    IGetMultiVoxsetGUID_VOX(
                        gx_->pGeo, param1.c_str(), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                static GXVOXPtr generate_gocad(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, GXIPJPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GenerateGOCAD_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }
                static GXVOXPtr generate_oriented_gocad(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, GXIPJPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GenerateOrientedGOCAD_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }
                static GXVOXPtr generate_ubc(const gx_string_type& param1, const gx_string_type& param2, const gx_string_type& param3, double param4, GXIPJPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = GenerateUBC_VOX(
                                      gx_->pGeo, param1.c_str(), param2.c_str(), param3.c_str(), &param4, reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOX>(ret);
                }
                static void generate_xyz(const gx_string_type& param1, GXRAPtr param2, int32_t param3, GXIPJPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GenerateXYZ_VOX(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void list_gocad_properties(const gx_string_type& param1, GXLSTPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ListGOCADProperties_VOX(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void export_db(GXDBPtr param1, const gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6, int32_t param7)
                {
                    ExportDB_VOX(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7));
                    gx_->throw_on_error();
                }

            };
            class GXVOXD
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVOXD(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVOXDPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVOXD>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXVOXDPtr create(GXVOXPtr param1, const gx_string_type& param2, int32_t param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_VOXD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOXD>(ret);
                }
                static GXVOXDPtr create_itr(GXVOXPtr param1, GXITRPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateITR_VOXD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOXD>(ret);
                }
                static GXVOXDPtr create_thematic(GXVOXPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateThematic_VOXD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOXD>(ret);
                }
                int32_t is_thematic()
                {
                    int32_t ret = iIsThematic_VOXD(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_thematic_info(GXTPATPtr param1, GXVVPtr param2)
                {
                    GetThematicInfo_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void set_thematic_selection(GXVVPtr param1)
                {
                    SetThematicSelection_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                ~GXVOXD()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void get_draw_controls(int32_t& param1, double& param2, double& param3, double& param4, double& param5, double& param6, double& param7, double& param8)
                {
                    GetDrawControls_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }
                void get_name(gx_string_type& param1)
                {
                    int32_t paramSize2 = STR_FILE * STRING_CHAR_SIZE;
                    param1.resize(STR_FILE);
                    IGetName_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), (gx_string_char_type*)param1.data(), reinterpret_cast<const long*>(&paramSize2 ));
                    gx_->throw_on_error();
                    param1.resize(gx_string_len(param1.c_str()));
                }
                void get_itr(GXITRPtr param1)
                {
                    GetITR_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void get_shell_controls(double& param1, double& param2)
                {
                    GetShellControls_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void set_draw_controls(int32_t param1, double param2, double param3, double param4, double param5, double param6, double param7, double param8)
                {
                    SetDrawControls_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2, &param3, &param4, &param5, &param6, &param7, &param8);
                    gx_->throw_on_error();
                }
                void set_itr(GXITRPtr param1)
                {
                    SetITR_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void set_shell_controls(double param1, double param2)
                {
                    SetShellControls_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void get_render_mode(int32_t& param1)
                {
                    GetRenderMode_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_render_mode(int32_t param1)
                {
                    SetRenderMode_VOXD(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }

            };
            class GXVOXE
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVOXE(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVOXEPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVOXE>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                static GXVOXEPtr create(GXVOXPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_VOXE(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVOXE>(ret);
                }
                ~GXVOXE()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VOXE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void profile(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, int32_t param5)
                {
                    Profile_VOXE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                double value(double param1, double param2, double param3, int32_t param4)
                {
                    double ret = rValue_VOXE(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }
                void vector(double param1, double param2, double param3, double param4, double param5, double param6, GXVVPtr param7, int32_t param8)
                {
                    Vector_VOXE(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, &param5, &param6, reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }

            };
            class GXVULCAN
            {
            private:
                GXVULCAN();
                ~GXVULCAN();
            public:


                static int32_t is_valid_triangulation_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = IsValidTriangulationFile_VULCAN(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t is_valid_block_model_file(const gx_string_type& param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = IsValidBlockModelFile_VULCAN(
                                      gx_->pGeo, param1.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void triangulation_to_view(const gx_string_type& param1, GXIPJPtr param2, GXMVIEWPtr param3, const gx_string_type& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    TriangulationToView_VULCAN(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), param4.c_str());
                    gx_->throw_on_error();
                }
                static void get_block_model_variable_info(const gx_string_type& param1, int32_t param2, GXLSTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetBlockModelVariableInfo_VULCAN(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void get_block_model_string_variable_values(const gx_string_type& param1, const gx_string_type& param2, GXLSTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    GetBlockModelStringVariableValues_VULCAN(
                        gx_->pGeo, param1.c_str(), param2.c_str(), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void block_model_to_voxel(const gx_string_type& param1, GXIPJPtr param2, const gx_string_type& param3, const gx_string_type& param4, int32_t param5, const gx_string_type& param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BlockModelToVoxel_VULCAN(
                        gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&gx_->handle(param2)), param3.c_str(), param4.c_str(), reinterpret_cast<const long*>(&param5), param6.c_str());
                    gx_->throw_on_error();
                }

            };
            class GXVV
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVV(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVVPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVV>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }




                template <typename T>
                std::vector<T> get_data(int32_t start, int32_t elements)
                {
                    std::vector<T> data(elements);
                    iGetData_VV(gx_->pGeo, reinterpret_cast<const long*>(&handle_), start, elements, data.data(), gs_cpp_type<T>::type());
                    gx_->throw_on_error();
                    return data;
                }


                template <typename T>
                void set_data(int32_t start, const std::vector<T>& data)
                {
                    iSetData_VV(gx_->pGeo, reinterpret_cast<const long*>(&handle_), start, static_cast<long>(data.size()), data.data(), gs_cpp_type<T>::type());
                    gx_->throw_on_error();
                }

                void copy(GXVVPtr param1)
                {
                    _Copy_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void copy2(int32_t param1, GXVVPtr param2, int32_t param3, int32_t param4)
                {
                    _Copy2_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void log(int32_t param1, int32_t param2, double param3)
                {
                    _Log_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }
                void log_linear(double param1)
                {
                    _LogLinear_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void mask(GXVVPtr param1)
                {
                    _Mask_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void reverse()
                {
                    _Reverse_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void serial(GXBFPtr param1)
                {
                    _Serial_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void trans(double param1, double param2)
                {
                    _Trans_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void abs()
                {
                    Abs_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void add(GXVVPtr param1, GXVVPtr param2)
                {
                    Add_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void add2(double param1, GXVVPtr param2, double param3, GXVVPtr param4)
                {
                    Add2_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void append(GXVVPtr param1)
                {
                    Append_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                int32_t crc(int32_t param1)
                {
                    int32_t ret = CRC_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t crc_inexact(int32_t param1, int32_t param2, int32_t param3)
                {
                    int32_t ret = CRCInexact_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return ret;
                }
                static GXVVPtr create(int32_t param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                static GXVVPtr create_ext(int32_t param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateExt_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                static GXVVPtr create_s(GXBFPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateS_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVV>(ret);
                }
                ~GXVV()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void diff(int32_t param1)
                {
                    Diff_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void divide(GXVVPtr param1, GXVVPtr param2)
                {
                    Divide_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void fid_norm(GXVVPtr param1)
                {
                    FidNorm_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void fill_int(int32_t param1)
                {
                    FillInt_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void fill_double(double param1)
                {
                    FillReal_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void fill_string(const gx_string_type& param1)
                {
                    FillString_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                int32_t count_dummies(int32_t param1, int32_t param2)
                {
                    int32_t ret = iCountDummies_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t find_dum(int32_t param1, int32_t param2, int32_t param3, int32_t param4)
                {
                    int32_t ret = iFindDum_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_fid_expansion()
                {
                    int32_t ret = iGetFidExpansion_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t get_int(int32_t param1)
                {
                    int32_t ret = iGetInt_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void get_string(int32_t param1, gx_string_type& param2)
                {
                    int32_t paramSize3 = STR_VERY_LONG * STRING_CHAR_SIZE;
                    param2.resize(STR_VERY_LONG);
                    IGetString_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), (gx_string_char_type*)param2.data(), reinterpret_cast<const long*>(&paramSize3 ));
                    gx_->throw_on_error();
                    param2.resize(gx_string_len(param2.c_str()));
                }
                int32_t get_ext_type()
                {
                    int32_t ret = iGetExtType_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t index_max(double& param1)
                {
                    int32_t ret = iIndexMax_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                    return ret;
                }
                int32_t length()
                {
                    int32_t ret = iLength_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                void index_insert(GXVVPtr param1, GXVVPtr param2)
                {
                    IndexInsert_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void index_order(GXVVPtr param1)
                {
                    IndexOrder_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void init_index(int32_t param1)
                {
                    InitIndex_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void inv_log(int32_t param1, int32_t param2, double param3)
                {
                    InvLog_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }
                int32_t order(int32_t& param1)
                {
                    int32_t ret = iOrder_VV(
                                      gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                void lines_to_xy(GXVVPtr param1, GXVVPtr param2)
                {
                    LinesToXY_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void lookup_index(GXVVPtr param1, GXVVPtr param2)
                {
                    LookupIndex_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void make_mem_based()
                {
                    MakeMemBased_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void mask_and(GXVVPtr param1, GXVVPtr param2)
                {
                    MaskAND_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void mask_or(GXVVPtr param1, GXVVPtr param2)
                {
                    MaskOR_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void mask_str(GXVVPtr param1, const gx_string_type& param2)
                {
                    MaskStr_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                void multiply(GXVVPtr param1, GXVVPtr param2)
                {
                    Multiply_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void amplitude_3d(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    Amplitude3D_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                void polygon_mask(GXVVPtr param1, GXVVPtr param2, GXPLYPtr param3, int32_t param4)
                {
                    PolygonMask_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void project(GXPJPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Project_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void project_3d(GXPJPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Project3D_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                void range_double(double& param1, double& param2)
                {
                    RangeDouble_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2);
                    gx_->throw_on_error();
                }
                void re_fid(double param1, double param2, int32_t param3)
                {
                    ReFid_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void re_fid_vv(GXVVPtr param1)
                {
                    ReFidVV_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void re_sample(double param1, double param2, double param3, double param4, int32_t param5, int32_t param6)
                {
                    ReSample_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, &param3, &param4, reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                double get_fid_incr()
                {
                    double ret = rGetFidIncr_VV(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_fid_start()
                {
                    double ret = rGetFidStart_VV(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double get_double(int32_t param1)
                {
                    double ret = rGetReal_VV(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                    return ret;
                }
                double sum()
                {
                    double ret = rSum_VV(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                    return ret;
                }
                double weighted_mean(GXVVPtr param1)
                {
                    double ret = rWeightedMean_VV(
                                     gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                void set_fid_expansion(int32_t param1)
                {
                    SetFidExpansion_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_fid_incr(double param1)
                {
                    SetFidIncr_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_fid_start(double param1)
                {
                    SetFidStart_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1);
                    gx_->throw_on_error();
                }
                void set_int(int32_t param1, int32_t param2)
                {
                    SetInt_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void set_int_n(int32_t param1, int32_t param2, int32_t param3)
                {
                    SetIntN_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void set_len(int32_t param1)
                {
                    SetLen_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void set_double(int32_t param1, double param2)
                {
                    SetReal_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), &param2);
                    gx_->throw_on_error();
                }
                void set_double_n(int32_t param1, int32_t param2, double param3)
                {
                    SetRealN_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), &param3);
                    gx_->throw_on_error();
                }
                void set_string(int32_t param1, const gx_string_type& param2)
                {
                    SetString_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), param2.c_str());
                    gx_->throw_on_error();
                }
                void set_string_n(int32_t param1, int32_t param2, const gx_string_type& param3)
                {
                    SetStringN_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1), reinterpret_cast<const long*>(&param2), param3.c_str());
                    gx_->throw_on_error();
                }
                void setup_index(GXVVPtr param1, GXVVPtr param2, int32_t param3, double param4)
                {
                    SetupIndex_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }
                void sort(int32_t param1)
                {
                    Sort_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&param1));
                    gx_->throw_on_error();
                }
                void sort_index(GXVVPtr param1)
                {
                    SortIndex_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                void sort_index1(GXVVPtr param1, int32_t param2)
                {
                    SortIndex1_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                void sort_index2(GXVVPtr param1, GXVVPtr param2, int32_t param3, int32_t param4)
                {
                    SortIndex2_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                void sort_index3(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    SortIndex3_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                void sort_index4(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, int32_t param5, int32_t param6, int32_t param7, int32_t param8)
                {
                    SortIndex4_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6), reinterpret_cast<const long*>(&param7), reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void statistics(GXSTPtr param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Statistics_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void subtract(GXVVPtr param1, GXVVPtr param2)
                {
                    Subtract_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                void swap()
                {
                    Swap_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }
                void window(double param1, double param2, int32_t param3)
                {
                    Window_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), &param1, &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                void write_xml(const gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    WriteXML_VV(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }

            };
            class GXVVEXP
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXVVEXP(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXVVEXPPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXVVEXP>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void add_vv(GXVVPtr param1, const gx_string_type& param2)
                {
                    AddVV_VVEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                }
                static GXVVEXPPtr create()
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_VVEXP(
                                      gx_->pGeo);
                    gx_->throw_on_error();
                    return gx_->createPtr<GXVVEXP>(ret);
                }
                ~GXVVEXP()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_VVEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void do_formula(const gx_string_type& param1, int32_t param2)
                {
                    DoFormula_VVEXP(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }

            };
            class GXVVU
            {
            private:
                GXVVU();
                ~GXVVU();
            public:


                static void average_repeat(GXVVPtr param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AverageRepeat_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void average_repeat_ex(GXVVPtr param1, GXVVPtr param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AverageRepeatEx_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void average_repeat2(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AverageRepeat2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void average_repeat2_ex(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    AverageRepeat2Ex_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void binary_search(GXVVPtr param1, double param2, int32_t& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BinarySearch_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<long*>(&param3), reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }
                static void box_cox(GXVVPtr param1, double param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BoxCox_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2);
                    gx_->throw_on_error();
                }
                static void bp_filt(GXVVPtr param1, GXVVPtr param2, double param3, double param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    BPFilt_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void clip(GXVVPtr param1, double param2, double param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Clip_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void clip_to_detect_limit(GXVVPtr param1, double param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ClipToDetectLimit_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void decimate(GXVVPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Decimate_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void deviation(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, double param6, double param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Deviation_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void distance(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Distance_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }
                static void distance_link_non_dummies(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DistanceLinkNonDummies_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }
                static void distance_non_cumulative(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DistanceNonCumulative_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7);
                    gx_->throw_on_error();
                }
                static void distance_3d(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Distance3D_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void find_gaps_3d(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, GXVVPtr param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FindGaps3D_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, reinterpret_cast<const long*>(&gx_->handle(param5)));
                    gx_->throw_on_error();
                }
                static void dummy_range(GXVVPtr param1, double param2, double param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DummyRange_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void dummy_range_ex(GXVVPtr param1, double param2, double param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DummyRangeEx_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void dummy_repeat(GXVVPtr param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DummyRepeat_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                }
                static void dup_stats(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    DupStats_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void exp_dist(GXVVPtr param1, int32_t param2, double param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    ExpDist_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void filter(GXVVPtr param1, GXVVPtr param2, GXFLTPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Filter_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void find_string_items(GXVVPtr param1, GXVVPtr param2, int32_t param3, int32_t param4, int32_t param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FindStringItems_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static void fractal_filter(GXVVPtr param1, int32_t param2, int32_t param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    FractalFilter_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static int32_t close_xy(GXVVPtr param1, GXVVPtr param2, double param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCloseXY_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t close_xym(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCloseXYM_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t close_xyz(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, double param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCloseXYZ_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t close_xyzm(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iCloseXYZM_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t dummy_back_tracks(GXVVPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iDummyBackTracks_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t find_dummy(GXVVPtr param1, int32_t param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iFindDummy_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                    return ret;
                }
                static void interp(GXVVPtr param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Interp_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static int32_t qc_fill_gaps(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iQCFillGaps_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5);
                    gx_->throw_on_error();
                    return ret;
                }
                static int32_t search_text(GXVVPtr param1, const gx_string_type& param2, int32_t param3, int32_t param4, int32_t param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iSearchText_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                    return ret;
                }
                static void mask(GXVVPtr param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Mask_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void mask_and(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MaskAND_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void mask_or(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    MaskOR_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void nl_filt(GXVVPtr param1, GXVVPtr param2, int32_t param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NLFilt_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), &param4);
                    gx_->throw_on_error();
                }
                static void noise_check(GXVVPtr param1, GXVVPtr param2, double param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NoiseCheck_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void noise_check2(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NoiseCheck2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void normal_dist(GXVVPtr param1, int32_t param2, double param3, double param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    NormalDist_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void offset_circles(GXVVPtr param1, GXVVPtr param2, double param3, double param4, GXVVPtr param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OffsetCircles_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static void offset_correct(GXVVPtr param1, GXVVPtr param2, double param3, int32_t param4, GXVVPtr param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OffsetCorrect_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static void offset_correct2(GXVVPtr param1, GXVVPtr param2, double param3, double param4, GXVVPtr param5, GXVVPtr param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OffsetCorrect2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, reinterpret_cast<const long*>(&gx_->handle(param5)), reinterpret_cast<const long*>(&gx_->handle(param6)));
                    gx_->throw_on_error();
                }
                static void offset_correct3(GXVVPtr param1, GXVVPtr param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OffsetCorrect3_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                static void offset_correct_xyz(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, double param6, double param7, GXVVPtr param8, GXVVPtr param9, GXVVPtr param10)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OffsetCorrectXYZ_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)), reinterpret_cast<const long*>(&gx_->handle(param10)));
                    gx_->throw_on_error();
                }
                static void offset_rectangles(GXVVPtr param1, GXVVPtr param2, double param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    OffsetRectangles_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)));
                    gx_->throw_on_error();
                }
                static void pick_peak(GXVVPtr param1, GXVVPtr param2, double param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PickPeak_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void pick_peak2(GXVVPtr param1, GXVVPtr param2, double param3, double param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PickPeak2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4);
                    gx_->throw_on_error();
                }
                static void pick_peak3(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, GXVVPtr param6, GXVVPtr param7, GXVVPtr param8, GXVVPtr param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PickPeak3_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, reinterpret_cast<const long*>(&gx_->handle(param6)), reinterpret_cast<const long*>(&gx_->handle(param7)), reinterpret_cast<const long*>(&gx_->handle(param8)), reinterpret_cast<const long*>(&gx_->handle(param9)));
                    gx_->throw_on_error();
                }
                static void poly_fill(GXVVPtr param1, int32_t param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PolyFill_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void poly_fill2(GXVVPtr param1, GXVVPtr param2, int32_t param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PolyFill2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void polygon_mask(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXPLYPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    PolygonMask_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void prune(GXVVPtr param1, GXVVPtr param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Prune_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void qc(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, double param4, double param5, double param6, double param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    QC_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), &param4, &param5, &param6, &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void qc2(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, double param5, double param6, double param7, int32_t param8)
                {
                    GXContextPtr gx_ = GXContext::current();
                    QC2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), &param5, &param6, &param7, reinterpret_cast<const long*>(&param8));
                    gx_->throw_on_error();
                }
                static void range_vector_mag(GXVVPtr param1, GXVVPtr param2, double& param3, double& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RangeVectorMag_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4);
                    gx_->throw_on_error();
                }
                static void regress(GXVVPtr param1, GXVVPtr param2, double& param3, double& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Regress_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, &param4);
                    gx_->throw_on_error();
                }
                static void rel_var_dup(GXVVPtr param1, GXVVPtr param2, double& param3, int32_t& param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RelVarDup_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), &param3, reinterpret_cast<long*>(&param4));
                    gx_->throw_on_error();
                }
                static void remove_dummy(GXVVPtr param1)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveDummy_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)));
                    gx_->throw_on_error();
                }
                static void remove_dummy2(GXVVPtr param1, GXVVPtr param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveDummy2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)));
                    gx_->throw_on_error();
                }
                static void remove_dummy3(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveDummy3_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void remove_dummy4(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveDummy4_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void remove_dup(GXVVPtr param1, GXVVPtr param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveDup_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                }
                static void remove_xy_dup(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveXYDup_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                }
                static void remove_xy_dup_index(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RemoveXYDupIndex_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void rolling_stats(GXVVPtr param1, GXVVPtr param2, int32_t param3, int32_t param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    RollingStats_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static void search_replace(GXVVPtr param1, double param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SearchReplace_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3);
                    gx_->throw_on_error();
                }
                static void search_replace_text(GXVVPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SearchReplaceText_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6));
                    gx_->throw_on_error();
                }
                static void search_replace_text_ex(GXVVPtr param1, int32_t param2, int32_t param3, const gx_string_type& param4, const gx_string_type& param5, int32_t param6, int32_t& param7)
                {
                    GXContextPtr gx_ = GXContext::current();
                    SearchReplaceTextEx_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3), param4.c_str(), param5.c_str(), reinterpret_cast<const long*>(&param6), reinterpret_cast<long*>(&param7));
                    gx_->throw_on_error();
                }
                static void spline(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, int32_t param4, double param5, double param6, double param7, int32_t param8, int32_t param9)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Spline_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&param4), &param5, &param6, &param7, reinterpret_cast<const long*>(&param8), reinterpret_cast<const long*>(&param9));
                    gx_->throw_on_error();
                }
                static void spline2(GXVVPtr param1, GXVVPtr param2, GXVVPtr param3, GXVVPtr param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Spline2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&gx_->handle(param3)), reinterpret_cast<const long*>(&gx_->handle(param4)), reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }
                static int32_t tokenize_to_values(GXVVPtr param1, const gx_string_type& param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = iTokenizeToValues_VVU(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str());
                    gx_->throw_on_error();
                    return ret;
                }
                static void translate(GXVVPtr param1, double param2, double param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Translate_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), &param2, &param3);
                    gx_->throw_on_error();
                }
                static void trend(GXVVPtr param1, int32_t param2, GXVVPtr param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Trend_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&gx_->handle(param3)));
                    gx_->throw_on_error();
                }
                static void trend2(GXVVPtr param1, GXVVPtr param2, int32_t param3, GXVVPtr param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    Trend2_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&gx_->handle(param2)), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&gx_->handle(param4)));
                    gx_->throw_on_error();
                }
                static void uniform_dist(GXVVPtr param1, int32_t param2, double param3, double param4, int32_t param5)
                {
                    GXContextPtr gx_ = GXContext::current();
                    UniformDist_VVU(
                        gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), reinterpret_cast<const long*>(&param2), &param3, &param4, reinterpret_cast<const long*>(&param5));
                    gx_->throw_on_error();
                }

            };
            class GXWA
            {
            private:
                friend class GXContext;

                GXContextPtr gx_;
                int32_t handle_;

                GXWA(int32_t handle)
                    : gx_(GXContext::current()), handle_(handle)
                {
                }

            public:
                static GXWAPtr null()
                {
                    return GXContext::current()->createNullHandlePtr<GXWA>();
                }
                bool is_null()
                {
                    return handle_ == 0;
                }

                int32_t _internal_handle()
                {
                    return handle_;
                }



                void puts(const gx_string_type& param1)
                {
                    _Puts_WA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_), param1.c_str());
                    gx_->throw_on_error();
                }
                static GXWAPtr create(const gx_string_type& param1, int32_t param2)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = Create_WA(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXWA>(ret);
                }
                static GXWAPtr create_ex(const gx_string_type& param1, int32_t param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateEx_WA(
                                      gx_->pGeo, param1.c_str(), reinterpret_cast<const long*>(&param2), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXWA>(ret);
                }
                static GXWAPtr create_sbf(GXSBFPtr param1, const gx_string_type& param2, int32_t param3)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateSBF_WA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXWA>(ret);
                }
                static GXWAPtr create_sbf_ex(GXSBFPtr param1, const gx_string_type& param2, int32_t param3, int32_t param4)
                {
                    GXContextPtr gx_ = GXContext::current();
                    int32_t ret = CreateSBFEx_WA(
                                      gx_->pGeo, reinterpret_cast<const long*>(&gx_->handle(param1)), param2.c_str(), reinterpret_cast<const long*>(&param3), reinterpret_cast<const long*>(&param4));
                    gx_->throw_on_error();
                    return gx_->createPtr<GXWA>(ret);
                }
                ~GXWA()
                {
                    if (handle_ == 0)
                        return;
                    Destroy_WA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                }
                void new_line()
                {
                    NewLine_WA(
                        gx_->pGeo, reinterpret_cast<const long*>(&handle_));
                    gx_->throw_on_error();
                }

            };

#ifndef GX_EXLUDE_IMPL
            thread_local std::weak_ptr<GXContext> GXContext::currentContext;
#endif // GX_EXLUDE_IMPL

        }
    }
}